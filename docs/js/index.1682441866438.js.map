{
  "version": 3,
  "sources": ["../../src/docs/client-side/js/menu/side-menu.ts", "../../src/docs/client-side/js/menu/mobile-menu.ts", "../../src/docs/client-side/js/dark-mode.ts", "../../node_modules/mz-particles/node_modules/mz-canvas/src/core/canvas.ts", "../../node_modules/mz-particles/node_modules/mz-canvas/src/core/shapes/primitive-shapes.ts", "../../node_modules/mz-particles/node_modules/mz-math/src/main/format.ts", "../../node_modules/mz-particles/node_modules/mz-math/src/main/angle.ts", "../../node_modules/mz-particles/node_modules/mz-math/src/main/linear-algebra/vector.ts", "../../node_modules/mz-particles/node_modules/mz-math/src/main/linear-algebra/matrix.ts", "../../node_modules/mz-particles/node_modules/mz-math/src/main/linear-algebra/matrix-transformations.ts", "../../node_modules/mz-particles/node_modules/mz-math/src/main/random.ts", "../../node_modules/mz-particles/node_modules/mz-math/src/main/other.ts", "../../node_modules/mz-particles/node_modules/mz-math/src/main/convert.ts", "../../node_modules/mz-particles/node_modules/mz-math/src/main/derivative.ts", "../../node_modules/mz-particles/node_modules/mz-math/src/main/equations/linear-equations.ts", "../../node_modules/mz-particles/node_modules/mz-math/src/main/equations/quadratic-equations.ts", "../../node_modules/mz-particles/node_modules/mz-math/src/main/bezier-curves/bezier-curve.ts", "../../node_modules/mz-particles/node_modules/mz-math/src/main/path-movement.ts", "../../node_modules/mz-particles/node_modules/mz-math/src/main/color.ts", "../../node_modules/mz-particles/node_modules/mz-math/src/main/id.ts", "../../node_modules/mz-particles/node_modules/mz-math/src/main/shapes.ts", "../../node_modules/mz-particles/node_modules/mz-math/src/main/collision-detection.ts", "../../node_modules/mz-particles/node_modules/mz-math/src/main/animation.ts", "../../node_modules/mz-particles/src/core/domain/colors-provider.ts", "../../node_modules/mz-particles/src/core/domain/connections-provider.ts", "../../node_modules/mz-particles/node_modules/mz-svg/src/main/core.ts", "../../node_modules/mz-particles/node_modules/mz-svg/src/main/shapes/primitive-shapes.ts", "../../node_modules/mz-particles/node_modules/mz-svg/node_modules/mz-math/src/main/format.ts", "../../node_modules/mz-particles/node_modules/mz-svg/node_modules/mz-math/src/main/angle.ts", "../../node_modules/mz-particles/node_modules/mz-svg/node_modules/mz-math/src/main/linear-algebra/vector.ts", "../../node_modules/mz-particles/node_modules/mz-svg/node_modules/mz-math/src/main/linear-algebra/matrix.ts", "../../node_modules/mz-particles/node_modules/mz-svg/node_modules/mz-math/src/main/linear-algebra/matrix-transformations.ts", "../../node_modules/mz-particles/node_modules/mz-svg/node_modules/mz-math/src/main/random.ts", "../../node_modules/mz-particles/node_modules/mz-svg/node_modules/mz-math/src/main/other.ts", "../../node_modules/mz-particles/node_modules/mz-svg/node_modules/mz-math/src/main/convert.ts", "../../node_modules/mz-particles/node_modules/mz-svg/node_modules/mz-math/src/main/derivative.ts", "../../node_modules/mz-particles/node_modules/mz-svg/node_modules/mz-math/src/main/equations/linear-equations.ts", "../../node_modules/mz-particles/node_modules/mz-svg/node_modules/mz-math/src/main/equations/quadratic-equations.ts", "../../node_modules/mz-particles/node_modules/mz-svg/node_modules/mz-math/src/main/bezier-curves/bezier-curve.ts", "../../node_modules/mz-particles/node_modules/mz-svg/node_modules/mz-math/src/main/path-movement.ts", "../../node_modules/mz-particles/node_modules/mz-svg/node_modules/mz-math/src/main/color.ts", "../../node_modules/mz-particles/node_modules/mz-svg/node_modules/mz-math/src/main/id.ts", "../../node_modules/mz-particles/node_modules/mz-svg/node_modules/mz-math/src/main/shapes.ts", "../../node_modules/mz-particles/node_modules/mz-svg/src/main/path/scanner.ts", "../../node_modules/mz-particles/node_modules/mz-svg/src/main/path/parser.ts", "../../node_modules/mz-particles/node_modules/mz-svg/src/main/path/minify.ts", "../../node_modules/mz-particles/node_modules/mz-svg/src/main/path/convert.ts", "../../node_modules/mz-particles/node_modules/mz-svg/src/main/path/index.ts", "../../node_modules/mz-particles/node_modules/mz-svg/src/main/shapes/stars.ts", "../../node_modules/mz-particles/node_modules/mz-svg/src/main/shapes/flowers.ts", "../../node_modules/mz-particles/node_modules/mz-svg/src/main/shapes/shape-paths.ts", "../../node_modules/mz-particles/node_modules/mz-svg/src/main/io-browser.ts", "../../node_modules/mz-particles/node_modules/mz-svg/src/main/containers.ts", "../../node_modules/mz-particles/node_modules/mz-svg/src/main/helpers.ts", "../../node_modules/mz-particles/node_modules/mz-svg/src/main/path/bbox.ts", "../../node_modules/mz-particles/node_modules/mz-svg/src/main/path/transform.ts", "../../node_modules/mz-particles/node_modules/mz-svg/src/main/animation/animate.ts", "../../node_modules/mz-particles/node_modules/tinycolor2/esm/tinycolor.js", "../../node_modules/mz-particles/src/core/domain/particles-provider.ts", "../../node_modules/mz-particles/src/core/domain/settings-provider.ts", "../../node_modules/mz-particles/src/core/app.ts", "../../node_modules/mz-particles/src/core/index.ts", "../../src/docs/client-side/js/index.tsx"],
  "sourcesContent": ["const COLLAPSIBLE_STORAGE_KEY = 'side-menu';\n\ninterface ICollapsible {\n    id: string;\n    opened: boolean;\n}\n\nexport const initMenuScroll = () => {\n    const $menu = document.querySelector('.side-menu');\n    if(!$menu) return;\n\n    const path = window.location.pathname;\n    const $link = $menu.querySelector(`a[href='${ path }']`);\n    if(!$link) return;\n\n    $link.scrollIntoView({\n        block: 'center',\n    });\n};\n\nconst getStateFromStorage = (): ICollapsible[] => {\n    const data = window.localStorage.getItem(COLLAPSIBLE_STORAGE_KEY);\n    if(!data) return [];\n\n    let menu: ICollapsible[] = [];\n\n    try{\n        menu = JSON.parse(data) || [];\n    }\n    catch(ex){\n        // ...\n    }\n\n    return menu;\n};\n\nconst saveStateToStorage = () => {\n    const $titles = document.querySelectorAll('.side-menu [data-collapsible-title]');\n    const menu: ICollapsible[] = [];\n\n    for(const $title of $titles){\n        const id = $title.getAttribute('data-id') || '';\n        if(!id) continue;\n\n        const opened = $title.getAttribute('data-opened') === 'true';\n\n        menu.push({\n            id,\n            opened\n        });\n    }\n\n    window.localStorage.setItem(COLLAPSIBLE_STORAGE_KEY, JSON.stringify(menu));\n};\n\nconst restoreCollapsible = () => {\n    const menu = getStateFromStorage();\n    if(!Array.isArray(menu)) return;\n\n    for(const menuItem of menu){\n        const $title = document.querySelector(`.side-menu [data-id=\"${ menuItem.id }\"]`) as HTMLElement;\n        if(!$title) continue;\n\n        toggle($title, menuItem.opened, false);\n    }\n};\n\nconst toggle = ($title: HTMLElement, opened: boolean, saveToStorage: boolean) => {\n\n    $title.setAttribute('data-opened', opened.toString());\n\n    const $arrow = $title.querySelector('[data-arrow]');\n    if(!$arrow) return;\n\n    $arrow.classList.toggle('rotate-90', opened);\n    $title.nextElementSibling?.classList.toggle('hidden', !opened);\n\n    if(saveToStorage){\n        saveStateToStorage();\n    }\n};\n\nexport const initMenuCollapsible = () => {\n    const $titles = document.querySelectorAll('.side-menu [data-collapsible-title]') as NodeListOf<HTMLElement>;\n\n    for(const $title of $titles){\n\n        $title.addEventListener('click', () => {\n            const isOpened = $title.getAttribute('data-opened') === 'true';\n            toggle($title, !isOpened, true);\n        });\n    }\n\n    // try to restore collapsible state on page load\n    restoreCollapsible();\n};", "export const initMobileMenu = () => {\n    const $btn = document.getElementById('mobile-menu-btn');\n    if(!$btn) return;\n\n    $btn.addEventListener('click', (evt) => {\n        evt.stopPropagation();\n        document.body.classList.toggle('mobile-menu-opened');\n    });\n\n    document.body.addEventListener('click', () => {\n        document.body.classList.remove('mobile-menu-opened');\n    });\n\n    const $sideMenu = document.getElementById('side-menu');\n    if(!$sideMenu) return;\n\n    $sideMenu.addEventListener('click', (evt) => {\n        evt.stopPropagation();\n    });\n\n    const $close = document.getElementById('mobile-menu-close-btn');\n    if(!$close) return;\n\n    $close.addEventListener('click', () => {\n        document.body.classList.remove('mobile-menu-opened');\n    });\n};\n", "const MODE_STORAGE_KEY = 'mode';\n\nexport const handleDarkLightModes = () => {\n\n    const mode = window.localStorage.getItem(MODE_STORAGE_KEY) || 'light';\n    document.documentElement.classList.toggle('dark', mode === 'dark');\n\n    const $moveToDarkBtn = document.getElementById('move-to-dark-mode-btn') as HTMLButtonElement;\n    const $moveToLightBtn = document.getElementById('move-to-light-mode-btn') as HTMLButtonElement;\n\n    const moveToDark = () => {\n        document.documentElement.classList.add('dark');\n        $moveToDarkBtn.classList.add('hidden');\n        $moveToLightBtn.classList.remove('hidden');\n        window.localStorage.setItem(MODE_STORAGE_KEY, 'dark');\n    };\n\n    const moveToLight = () => {\n        document.documentElement.classList.remove('dark');\n        $moveToLightBtn.classList.add('hidden');\n        $moveToDarkBtn.classList.remove('hidden');\n        window.localStorage.setItem(MODE_STORAGE_KEY, 'light');\n    };\n\n    if(mode === 'dark'){\n        moveToDark();\n    }\n    else{\n        moveToLight();\n    }\n\n    $moveToDarkBtn?.addEventListener('click', moveToDark);\n    $moveToLightBtn?.addEventListener('click', moveToLight);\n};\n", "import { ICanvas, IFillProps, IStrokeProps } from '../interfaces';\n\nconst setAttributes = ($canvas: HTMLCanvasElement, attributes: [string, string|number|undefined][]) => {\n    for(const attr of attributes){\n\n        const value = attr[1];\n        if(value === undefined) continue;\n\n        const key = attr[0];\n        $canvas.setAttribute(key, value.toString());\n    }\n};\n\nexport const setContextProps = (props: [string, string|number|undefined][], ctx: CanvasRenderingContext2D) => {\n    for(const prop of props){\n\n        const value = prop[1];\n        if(value === undefined) continue;\n\n        const key = prop[0];\n        ctx[key] = value;\n    }\n};\n\nexport const canvas = (props: ICanvas) => {\n\n    const $canvas: HTMLCanvasElement = document.createElement('canvas');\n\n    setAttributes($canvas, [\n        ['id', props.id],\n        ['class', props.classes],\n        ['style', props.style],\n        ['title', props.title],\n        ['tabindex', props.tabindex],\n        ['role', props.role],\n        ['aria-label', props.ariaLabel],\n    ]);\n\n    // Used to make the canvas accessible by providing fallback text\n    // to be displayed when the media doesn't load\n    // or the user is unable to experience it as intended\n    if(props.fallback){\n        $canvas.textContent = props.fallback;\n    }\n\n    const ctx =\n        typeof $canvas.getContext === 'function' ?\n            $canvas.getContext('2d', props.contextAttributes) :\n            null;\n\n    $canvas.width = props.width;\n    $canvas.height = props.height;\n\n    return { ctx, $canvas };\n};\n\nexport const stroke = (props: IStrokeProps, ctx: CanvasRenderingContext2D) => {\n    setContextProps([\n        ['lineWidth', props.lineWidth],\n        ['strokeStyle', props.strokeStyle],\n        ['lineCap', props.lineCap],\n        ['lineJoin', props.lineJoin],\n        ['miterLimit', props.miterLimit],\n        ['lineDashOffset', props.lineDashOffset],\n    ],ctx);\n\n    if(props.lineDashSegments){\n        ctx.setLineDash(props.lineDashSegments);\n    }\n};\n\nexport const fill = (props: IFillProps, ctx: CanvasRenderingContext2D) => {\n\n    if(props.fillStyle !== undefined){\n        ctx.fillStyle = props.fillStyle;\n    }\n\n    setContextProps([\n        ['shadowOffsetX', props.shadowOffsetX],\n        ['shadowOffsetY', props.shadowOffsetY],\n        ['shadowBlur', props.shadowBlur],\n        ['shadowColor', props.shadowColor],\n    ],ctx);\n};", "import { fill, stroke } from '../canvas';\nimport {\n    IPolynomialProps,\n    IRectProps,\n    ICircleProps,\n    ILineProps,\n} from '../../interfaces';\n\n/**\n * Draw a line.\n */\nexport const line = (props: ILineProps, ctx: CanvasRenderingContext2D) => {\n\n    const { x1, y1, x2, y2 } = props;\n\n    ctx.save();\n\n    ctx.beginPath();\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x2, y2);\n\n    if(props.strokeStyle){\n        stroke(props, ctx);\n        ctx.stroke();\n    }\n\n    ctx.restore();\n};\n\n/**\n * Get Path2D of a line, and optionally draw it.\n */\nexport const linePath = (props: ILineProps, ctx?: CanvasRenderingContext2D) : Path2D => {\n\n    const { x1, y1, x2, y2 } = props;\n\n    const path = new Path2D();\n\n    path.moveTo(x1, y1);\n    path.lineTo(x2, y2);\n\n    if(!ctx) return path;\n\n    ctx.save();\n\n    if(props.strokeStyle){\n        stroke(props, ctx);\n        ctx.stroke(path);\n    }\n\n    ctx.restore();\n\n    return path;\n};\n\n/**\n * Draw a rectangle, including a rectangle with rounded corners.\n * Can also \"clear\" a rectangular space.\n */\nexport const rect = (props: IRectProps, ctx: CanvasRenderingContext2D) => {\n\n    const { x, y, w, h} = props;\n\n    if(props.clear){\n        ctx.clearRect(x, y, w, h);\n        return;\n    }\n\n    if(props.radii){\n        ctx.save();\n\n        fill(props, ctx);\n        stroke(props, ctx);\n\n        ctx.beginPath();\n\n        // @ts-ignore\n        ctx.roundRect(x, y, w, h, props.radii)\n        if(props.fillStyle){\n            ctx.fill();\n        }\n\n        if(props.strokeStyle){\n            ctx.stroke();\n        }\n\n        ctx.restore();\n        return;\n    }\n\n    ctx.save();\n\n    if(props.fillStyle){\n        fill(props, ctx);\n        ctx.fillRect(x, y, w, h);\n    }\n\n    if(props.strokeStyle){\n        stroke(props, ctx);\n        ctx.strokeRect(x, y, w, h);\n    }\n\n    ctx.restore();\n};\n\n/**\n * Get Path2D of a rectangle, and optionally draw it.\n */\nexport const rectPath = (props: IRectProps, ctx?: CanvasRenderingContext2D) : Path2D => {\n\n    const { x, y, w, h} = props;\n\n    const path = new Path2D();\n\n    if(props.radii){\n        // @ts-ignore\n        path.roundRect(x, y, w, h, props.radii)\n    }\n    else{\n        path.rect(x, y, w, h);\n    }\n\n    if(!ctx) return path;\n\n    ctx.save();\n\n    if(props.fillStyle){\n        fill(props, ctx);\n        ctx.fill(path);\n    }\n\n    if(props.strokeStyle){\n        stroke(props, ctx);\n        ctx.stroke(path);\n    }\n\n    ctx.restore();\n\n    return path;\n};\n\n/**\n * Used to draw polynomials like triangles etc.\n */\nexport const polynomial = (props: IPolynomialProps, ctx: CanvasRenderingContext2D) => {\n\n    const { points } = props;\n\n    ctx.save();\n\n    fill(props, ctx);\n    stroke(props, ctx);\n\n    ctx.beginPath();\n\n    for(let i= 0; i<points.length; i++) {\n        const point = points[i];\n\n        if(i === 0){\n            ctx.moveTo(point[0], point[1]);\n        }\n        else{\n            ctx.lineTo(point[0], point[1]);\n        }\n    }\n\n    if(props.closed){\n        ctx.closePath();\n    }\n\n    if(props.fillStyle){\n        ctx.fill();\n    }\n\n    if(props.strokeStyle){\n        ctx.stroke();\n    }\n\n    ctx.restore();\n};\n\n/**\n * Used to draw polynomials like triangles etc.\n */\nexport const polynomialPath = (props: IPolynomialProps, ctx?: CanvasRenderingContext2D) : Path2D => {\n\n    const { points } = props;\n\n    const path = new Path2D();\n\n    for(let i= 0; i<points.length; i++) {\n        const point = points[i];\n\n        if(i === 0){\n            path.moveTo(point[0], point[1]);\n        }\n        else{\n            path.lineTo(point[0], point[1]);\n        }\n    }\n\n    if(props.closed){\n        path.closePath();\n    }\n\n    if(!ctx) return path;\n\n    ctx.save();\n\n    if(props.fillStyle){\n        fill(props, ctx);\n        ctx.fill(path);\n    }\n\n    if(props.strokeStyle){\n        stroke(props, ctx);\n        ctx.stroke(path);\n    }\n\n    ctx.restore();\n\n    return path;\n};\n\n/**\n * Draw a circle, or it's segment.\n */\nexport const circle = (props: ICircleProps, ctx: CanvasRenderingContext2D) => {\n    const { cx, cy,r} = props;\n\n    const startAngleRad = props.startAngleRad === undefined ? 0 : props.startAngleRad;\n    const endAngleRad = props.endAngleRad === undefined ? 2 * Math.PI : props.endAngleRad;\n\n    ctx.save();\n\n    ctx.beginPath();\n\n    fill(props, ctx);\n    stroke(props, ctx);\n\n    ctx.arc(cx, cy, r, startAngleRad, endAngleRad, props.counterclockwise);\n\n    if(props.fillStyle){\n        ctx.fill();\n    }\n\n    if(props.strokeStyle){\n        stroke(props, ctx);\n        ctx.stroke();\n    }\n\n    ctx.restore();\n};\n\n/**\n * Get Path2D of a circle or its segment, and optionally draw it.\n */\nexport const circlePath = (props: ICircleProps, ctx?: CanvasRenderingContext2D) : Path2D => {\n    const { cx, cy, r } = props;\n\n    const startAngleRad = props.startAngleRad === undefined ? 0 : props.startAngleRad;\n    const endAngleRad = props.endAngleRad === undefined ? 2 * Math.PI : props.endAngleRad;\n\n    const path = new Path2D();\n\n    path.arc(cx, cy, r, startAngleRad, endAngleRad, props.counterclockwise);\n\n    if(!ctx) return path;\n\n    ctx.save();\n\n    if(props.fillStyle){\n        fill(props, ctx);\n        ctx.fill(path);\n    }\n\n    if(props.strokeStyle){\n        stroke(props, ctx);\n        ctx.stroke(path);\n    }\n\n    ctx.restore();\n\n    return path;\n};\n", "export const setDecimalPlaces = (num: number, decimalPlaces: number | undefined = Infinity) => {\n    if(decimalPlaces === Infinity) return num;\n\n    if(decimalPlaces < 0){\n        decimalPlaces = 0;\n    }\n\n    const coefficient = 10 ** decimalPlaces;\n    return Math.round(num * coefficient) / coefficient;\n};", "import { Vector, Vector2, Vector3 } from '../types';\nimport { setDecimalPlaces } from './format';\nimport { v2Length, vNormalize, vDotProduct, vSub } from './linear-algebra/vector';\n\nexport const getV2Angle = (v2: Vector2, decimalPlaces = Infinity) => {\n    const angle = Math.atan2(v2[1], v2[0]);\n    return setDecimalPlaces(angle, decimalPlaces);\n};\n\nexport const setV2Angle = (v2: Vector2, newAngleRad: number, decimalPlaces = Infinity): Vector2 => {\n    const length = v2Length(v2);\n    return [\n        setDecimalPlaces(Math.cos(newAngleRad) * length, decimalPlaces),\n        setDecimalPlaces(Math.sin(newAngleRad) * length, decimalPlaces),\n    ];\n};\n\nexport const radiansToDegrees = (radians: number, decimalPlaces = Infinity) => {\n    const res = radians * (180 / Math.PI);\n    return setDecimalPlaces(res, decimalPlaces);\n};\n\nexport const degreesToRadians = (degrees: number, decimalPlaces = Infinity) => {\n    const res = degrees * (Math.PI / 180);\n    return setDecimalPlaces(res, decimalPlaces);\n};\n\n/**\n * Returns the range [0, Math.PI]\n * A = Math.acos( dot(v1, v2)/(v1.length()*v2.length()) );\n */\nexport const getVNAngleBetween = (vector1: Vector, vector2: Vector, decimalPlaces = Infinity) : number => {\n    const unitVector1 = vNormalize(vector1);\n    const unitVector2 = vNormalize(vector2);\n    const dotProduct = vDotProduct(unitVector1, unitVector2);\n    const angle = Math.acos(dotProduct);\n    return setDecimalPlaces(angle, decimalPlaces);\n};\n\nexport const getV2AngleBetween = (vector1: Vector2, vector2: Vector2, decimalPlaces = Infinity) : number => {\n    // return getVNAngleBetween(vector1, vector2, decimalPlaces);\n    const diff = vSub(vector1, vector2);\n    const angle = Math.atan2(diff[1], diff[0]);\n    return setDecimalPlaces(angle, decimalPlaces);\n};\n\nexport const getV3AngleBetween = (vector1: Vector3, vector2: Vector3, decimalPlaces = Infinity) : number => {\n    return getVNAngleBetween(vector1, vector2, decimalPlaces);\n};", "import { Vector, Vector2, Vector3, Vector4 } from '../../types';\nimport { setDecimalPlaces } from '../format';\nimport { getV2Angle, setV2Angle } from '../angle';\n\n// ------------ SUM ------------------------\n\nexport const vSum = (vector1: Vector, vector2: Vector, decimalPlaces = Infinity) : Vector => {\n\n    const vector: Vector = [];\n\n    for(let i=0; i<vector1.length; i++){\n        vector.push(setDecimalPlaces(vector1[i] + vector2[i], decimalPlaces));\n    }\n\n    return vector;\n};\n\nexport const v2Sum = (vector1: Vector2, vector2: Vector2, decimalPlaces = Infinity) : Vector2 => {\n    return vSum(vector1, vector2, decimalPlaces) as Vector2;\n};\n\nexport const v3Sum = (vector1: Vector3, vector2: Vector3, decimalPlaces = Infinity) : Vector3 => {\n    return vSum(vector1, vector2, decimalPlaces) as Vector3;\n};\n\n// ------------ SUB ------------------------\n\nexport const vSub = (vector1: Vector, vector2: Vector, decimalPlaces = Infinity) : Vector => {\n\n    const vector: Vector = [];\n\n    for(let i=0; i<vector1.length; i++){\n        vector.push(setDecimalPlaces(vector1[i] - vector2[i], decimalPlaces));\n    }\n\n    return vector;\n};\n\nexport const v2Sub = (vector1: Vector2, vector2: Vector2, decimalPlaces = Infinity) : Vector2 => {\n    return vSub(vector1, vector2, decimalPlaces) as Vector2;\n};\n\nexport const v3Sub = (vector1: Vector3, vector2: Vector3, decimalPlaces = Infinity) : Vector3 => {\n    return vSub(vector1, vector2, decimalPlaces) as Vector3;\n};\n\n// ------------ MUL SCALAR ------------------------\n\nexport const vMulScalar = (v: Vector, scalar: number, decimalPlaces = Infinity): Vector => {\n    const vector: Vector = [];\n\n    for(let i=0; i<v.length; i++){\n        vector.push(setDecimalPlaces(v[i] * scalar, decimalPlaces));\n    }\n\n    return vector;\n};\n\nexport const v2MulScalar = (v2: Vector2, scalar: number, decimalPlaces = Infinity): Vector2 => {\n    return vMulScalar(v2, scalar, decimalPlaces) as Vector2;\n};\n\nexport const v3MulScalar = (v3: Vector3, scalar: number, decimalPlaces = Infinity): Vector3 => {\n    return vMulScalar(v3, scalar, decimalPlaces) as Vector3;\n};\n\n// ------------ DIVIDE ------------------------\n\nexport const vDivideScalar = (v: Vector, scalar: number, decimalPlaces = Infinity): Vector => {\n    if(scalar === 0){\n        throw new Error('Division by zero error.');\n    }\n\n    const vector: Vector = [];\n\n    for(let i=0; i<v.length; i++){\n        vector.push(setDecimalPlaces(v[i] / scalar, decimalPlaces));\n    }\n\n    return vector;\n};\n\nexport const v2DivideScalar = (v2: Vector2, scalar: number, decimalPlaces = Infinity): Vector2 => {\n    return vDivideScalar(v2, scalar, decimalPlaces) as Vector2;\n};\n\nexport const v3DivideScalar = (v3: Vector3, scalar: number, decimalPlaces = Infinity): Vector3 => {\n    return vDivideScalar(v3, scalar, decimalPlaces) as Vector3;\n};\n\n// ------------ LENGTH ------------------------\n\nexport const vLength = (vector: Vector, decimalPlaces = Infinity) => {\n    let sum = 0;\n\n    for(let i=0; i<vector.length; i++){\n        sum += vector[i] * vector[i];\n    }\n\n    return setDecimalPlaces(Math.sqrt(sum), decimalPlaces);\n};\n\nexport const v2Length = (vector: Vector2, decimalPlaces = Infinity) => {\n    return vLength(vector, decimalPlaces);\n};\n\nexport const v3Length = (vector: Vector3, decimalPlaces = Infinity) => {\n    return vLength(vector, decimalPlaces);\n};\n\nexport const v2SetLength = (v2: Vector2, newLength: number, decimalPlaces = Infinity): Vector2 => {\n    const angle = getV2Angle(v2);\n    return [\n        setDecimalPlaces(Math.cos(angle) * newLength, decimalPlaces),\n        setDecimalPlaces(Math.sin(angle) * newLength, decimalPlaces),\n    ];\n};\n\n// ----------- DISTANCE ------------------------\n\nexport const vDistance = (vector1: Vector, vector2: Vector, decimalPlaces = Infinity) => {\n    const diff = vSub(vector1, vector2);\n    return vLength(diff, decimalPlaces);\n};\n\nexport const v2Distance = (vector1: Vector2, vector2: Vector2, decimalPlaces = Infinity) => {\n    const diff = vSub(vector1, vector2);\n    return vLength(diff, decimalPlaces);\n};\n\nexport const v3Distance = (vector1: Vector3, vector2: Vector3, decimalPlaces = Infinity) => {\n    const diff = vSub(vector1, vector2);\n    return vLength(diff, decimalPlaces);\n};\n\n// ------------ NORMALIZE ------------------------\n\n/**\n * Normalization creates a unit vector, which is a vector of length 1.\n */\nexport const vNormalize = (v: Vector, decimalPlaces = Infinity) : Vector => {\n    const length = vLength(v);\n    const unitVector: Vector = [];\n\n    for(let i=0; i<v.length; i++){\n        unitVector.push(length === 0 ? 0 : setDecimalPlaces(v[i] / length, decimalPlaces));\n    }\n\n    return unitVector;\n};\n\nexport const v2Normalize = (v2: Vector2, decimalPlaces = Infinity) : Vector2 => {\n    return vNormalize(v2, decimalPlaces) as Vector2;\n};\n\nexport const v3Normalize = (v3: Vector3, decimalPlaces = Infinity) : Vector3 => {\n    return vNormalize(v3, decimalPlaces) as Vector3;\n};\n\n// ------------ DOT PRODUCT ------------------------\n\nexport const vDotProduct = (vector1: Vector, vector2: Vector, decimalPlaces = Infinity) : number => {\n    let sum = 0;\n\n    for(let i=0; i<vector1.length; i++){\n        sum += vector1[i] * vector2[i];\n    }\n\n    return setDecimalPlaces(sum, decimalPlaces);\n};\n\nexport const v2DotProduct = (vector1: Vector2, vector2: Vector2, decimalPlaces = Infinity) : number => {\n    return vDotProduct(vector1, vector2, decimalPlaces);\n};\n\nexport const v3DotProduct = (vector1: Vector3, vector2: Vector3, decimalPlaces = Infinity) : number => {\n    return vDotProduct(vector1, vector2, decimalPlaces);\n};\n\n// ------------ CROSS PRODUCT ------------------------\n\n/**\n * Cross product is possible on 3D vectors only.\n * The cross product a \u00D7 b is defined as a vector c that is perpendicular (orthogonal) to both a and b.\n */\nexport const v3CrossProduct = (vector1: Vector3, vector2: Vector3, decimalPlaces = Infinity): Vector3 => {\n    return [\n        setDecimalPlaces(vector1[1] * vector2[2] - vector1[2] * vector2[1], decimalPlaces),\n        setDecimalPlaces(vector1[2] * vector2[0] - vector1[0] * vector2[2], decimalPlaces),\n        setDecimalPlaces(vector1[0] * vector2[1] - vector1[1] * vector2[0], decimalPlaces),\n    ];\n};\n\n// --------------- INIT VECTOR HELPER -----------------\n\nexport const v2 = (defaultValue = 0): Vector2 => {\n    return [defaultValue, defaultValue];\n};\n\nexport const v3 = (defaultValue = 0): Vector3 => {\n    return [defaultValue, defaultValue, defaultValue];\n};\n\nexport const v4 = (defaultValue = 0): Vector4 => {\n    return [defaultValue, defaultValue, defaultValue, defaultValue];\n};\n\nexport const vN = (N: number, defaultValue = 0): Vector => {\n\n    if(N < 0){\n        throw new Error('N must be a non-negative number.');\n    }\n\n    const vector: Vector = [];\n    for(let i=0; i<N; i++){\n        vector.push(defaultValue);\n    }\n    return vector;\n};\n\n/**\n * Initialize vector using polar coordinates\n */\nexport const v2FromPolarCoords = (distance: number, angleRad: number): Vector2 => {\n    let vector: Vector2 = [0, 0];\n    vector = v2SetLength(vector, distance);\n    return setV2Angle(vector, angleRad);\n};\n\n// --------------- EQUALITY -------------------------\n\nexport const vEqual = (vector1: Vector, vector2: Vector): boolean => {\n    if(vector1.length !== vector2.length) return false;\n\n    for(let i=0; i<vector1.length; i++){\n        if(vector1[i] !== vector2[i]) return false;\n    }\n\n    return true;\n};\n\n// --------------- NORMAL --------------------------\n\nexport const v2GetNormal = (vector1: Vector2, vector2: Vector2, decimalPlaces = Infinity): Vector2 => {\n    const sub = v2Sub(vector2, vector1);\n    return [\n        -setDecimalPlaces(sub[1], decimalPlaces),\n        setDecimalPlaces(sub[0], decimalPlaces)\n    ];\n};", "import { Matrix2, Matrix3, Matrix4, Matrix, Vector, Vector2, Vector3 } from '../../types';\nimport { vMulScalar, vSum, vSub, vDotProduct, vN, vEqual, vDivideScalar } from './vector';\n\n// --------------- SUM ----------------------\n\nexport const mSum = (matrix1: Matrix, matrix2: Matrix, decimalPlaces = Infinity): Matrix => {\n    const matrix: Matrix = [];\n\n    for(let i=0; i<matrix1.length; i++){\n        matrix.push(vSum(matrix1[i], matrix2[i], decimalPlaces));\n    }\n\n    return matrix;\n};\n\nexport const m2Sum = (matrix1: Matrix2, matrix2: Matrix2, decimalPlaces = Infinity): Matrix2 => {\n    return mSum(matrix1, matrix2, decimalPlaces) as Matrix2;\n};\n\nexport const m3Sum = (matrix1: Matrix3, matrix2: Matrix3, decimalPlaces = Infinity): Matrix3 => {\n    return mSum(matrix1, matrix2, decimalPlaces) as Matrix3;\n};\n\n// --------------- SUB ----------------------\n\nexport const mSub = (matrix1: Matrix, matrix2: Matrix, decimalPlaces = Infinity): Matrix => {\n    const matrix: Matrix = [];\n\n    for(let i=0; i<matrix1.length; i++){\n        matrix.push(vSub(matrix1[i], matrix2[i], decimalPlaces));\n    }\n\n    return matrix;\n};\n\nexport const m2Sub = (matrix1: Matrix2, matrix2: Matrix2, decimalPlaces = Infinity): Matrix2 => {\n    return mSub(matrix1, matrix2, decimalPlaces) as Matrix2;\n};\n\nexport const m3Sub = (matrix1: Matrix3, matrix2: Matrix3, decimalPlaces = Infinity): Matrix3 => {\n    return mSub(matrix1, matrix2, decimalPlaces) as Matrix3;\n};\n\n// --------------- MUL SCALAR ----------------------\n\nexport const mMulScalar = (m: Matrix, scalar: number, decimalPlaces = Infinity): Matrix => {\n    const matrix: Matrix = [];\n\n    for(const v of m){\n        matrix.push(vMulScalar(v, scalar, decimalPlaces));\n    }\n\n    return matrix;\n};\n\nexport const m2MulScalar = (m2: Matrix2, scalar: number, decimalPlaces = Infinity): Matrix2 => {\n    return mMulScalar(m2, scalar, decimalPlaces) as Matrix2;\n};\n\nexport const m3MulScalar = (m3: Matrix3, scalar: number, decimalPlaces = Infinity): Matrix3 => {\n    return mMulScalar(m3, scalar, decimalPlaces) as Matrix3;\n};\n\n// --------------- DIVIDE SCALAR ----------------------\n\nexport const mDivideScalar = (m: Matrix, scalar: number, decimalPlaces = Infinity): Matrix => {\n    if(scalar === 0){\n        throw new Error('Division by zero error.');\n    }\n\n    const matrix: Matrix = [];\n\n    for(const v of m){\n        matrix.push(vDivideScalar(v, scalar, decimalPlaces));\n    }\n\n    return matrix;\n};\n\nexport const m2DivideScalar = (m2: Matrix2, scalar: number, decimalPlaces = Infinity): Matrix2 => {\n    return mDivideScalar(m2, scalar, decimalPlaces) as Matrix2;\n};\n\nexport const m3DivideScalar = (m3: Matrix3, scalar: number, decimalPlaces = Infinity): Matrix3 => {\n    return mDivideScalar(m3, scalar, decimalPlaces) as Matrix3;\n};\n\n\n// --------------- TRANSPOSE ----------------------\n\nexport const mTranspose = (m: Matrix): Matrix => {\n\n    const vectorsCount = m.length;\n    if(vectorsCount <= 0) return m;\n\n    const vectorLength = m[0].length;\n    if(vectorLength <= 0) return m;\n\n    const matrix: Matrix = [];\n    for(let i=0; i<vectorLength; i++){\n        matrix.push([]);\n    }\n\n    for(let i=0; i<vectorsCount; i++){\n        for(let j=0; j<vectorLength; j++){\n            matrix[j].push(m[i][j]);\n        }\n    }\n\n    return matrix;\n};\n\nexport const m2Transpose = (m2: Matrix2): Matrix => {\n    return mTranspose(m2);\n};\n\nexport const m3Transpose = (m3: Matrix3): Matrix => {\n    return mTranspose(m3);\n};\n\n// ----------------- RESET ----------------------\n\nexport const mReset = (m: Matrix, defaultValue = 0): Matrix => {\n\n    if(m.length <= 0) return [];\n\n    const res: Matrix = [];\n\n    for(let i=0; i<m.length; i++){\n        const size = m[i].length;\n\n        const vector: Vector = [];\n        for(let j=0; j<size; j++){\n            vector.push(defaultValue);\n        }\n\n        res.push(vector);\n    }\n\n    return res;\n};\n\nexport const m2Reset = (m2: Matrix2, defaultValue = 0): Matrix2 => {\n    return mReset(m2, defaultValue) as Matrix2;\n};\n\nexport const m3Reset = (m3: Matrix3, defaultValue = 0): Matrix3 => {\n    return mReset(m3, defaultValue) as Matrix3;\n};\n\n// --------------- MATRIX INIT HELPERS -----------------\n\nexport const m2x2 = (defaultValue = 0): Matrix2 => {\n    return [\n        [defaultValue, defaultValue],\n        [defaultValue, defaultValue],\n    ];\n};\n\nexport const m3x3 = (defaultValue = 0): Matrix3 => {\n    return [\n        [defaultValue, defaultValue, defaultValue],\n        [defaultValue, defaultValue, defaultValue],\n        [defaultValue, defaultValue, defaultValue],\n    ];\n};\n\nexport const m4x4 = (defaultValue = 0): Matrix4 => {\n    return [\n        [defaultValue, defaultValue, defaultValue, defaultValue],\n        [defaultValue, defaultValue, defaultValue, defaultValue],\n        [defaultValue, defaultValue, defaultValue, defaultValue],\n        [defaultValue, defaultValue, defaultValue, defaultValue],\n    ];\n};\n\nexport const mNxM = (N: number, M: number, defaultValue = 0): Matrix => {\n    if(N <= 0 || M <= 0){\n        throw new Error('M and N must be positive numbers.');\n    }\n\n    const matrix: Matrix = [];\n\n    for(let i=0; i<N; i++){\n        matrix.push(vN(M, defaultValue));\n    }\n\n    return matrix;\n};\n\nexport const identity2 = (): Matrix2 => {\n    return [\n        [1, 0],\n        [0, 1],\n    ];\n};\n\nexport const identity3 = (): Matrix3 => {\n    return [\n        [1, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1],\n    ];\n};\n\nexport const identity4 = (): Matrix4 => {\n    return [\n        [1, 0, 0, 0],\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\n/**\n * Identity Matrix (I).\n * M x I = I x M = M for any matrix M.\n * Identity Matrix is a special case of scale matrix.\n */\nexport const identityN = (N: number): Matrix => {\n    if(N < 0){\n        throw new Error('N must be a non-negative number.');\n    }\n\n    if(N === 0) return [];\n\n    const matrix: Matrix = [];\n\n    for(let i=0; i<N; i++){\n        const vector: Vector = [];\n        for(let j=0; j<N; j++){\n            vector.push(i === j ? 1 : 0);\n        }\n        matrix.push(vector);\n    }\n\n    return matrix;\n};\n\n// -------------- MATRIX MANIPULATION HELPERS ------------\n\nexport const mDeepCopy = (m: Matrix): Matrix => {\n    const matrix: Matrix = [];\n\n    for(let i=0; i<m.length; i++){\n        const v = m[i];\n        const vector: Vector = [];\n        for(let j=0; j<v.length; j++){\n            vector.push(v[j]);\n        }\n        matrix.push(vector);\n    }\n\n    return matrix;\n};\n\nexport const m2DeepCopy = (m2: Matrix2): Matrix2 => {\n    return mDeepCopy(m2) as Matrix2;\n};\n\nexport const m3DeepCopy = (m3: Matrix3): Matrix3 => {\n    return mDeepCopy(m3) as Matrix3;\n};\n\n// -------------- APPEND / PREPEND ROW OR COLUMN ---------------\n\nexport const mAppendCol = (m: Matrix, col: Vector): Matrix  => {\n    if(m.length <= 0) return [];\n\n    const copy = mDeepCopy(m);\n    for(let i=0; i<copy.length; i++){\n        copy[i].push(col[i]);\n    }\n\n    return copy;\n};\n\nexport const mPrependCol = (m: Matrix, col: Vector): Matrix  => {\n    if(m.length <= 0) return [];\n\n    const copy = mDeepCopy(m);\n    for(let i=0; i<copy.length; i++){\n        copy[i].unshift(col[i]);\n    }\n\n    return copy;\n};\n\nexport const mAppendRow = (m: Matrix, row: Vector) : Matrix => {\n    const copy = mDeepCopy(m);\n    copy.push(row);\n    return copy;\n};\n\nexport const m2AppendRow = (m2: Matrix2, row: Vector2) : Matrix2 => {\n    const copy = m2DeepCopy(m2);\n    copy.push(row);\n    return copy;\n};\n\nexport const m3AppendRow = (m3: Matrix3, row: Vector3) : Matrix3 => {\n    const copy = m3DeepCopy(m3);\n    copy.push(row);\n    return copy;\n};\n\nexport const mPrependRow = (m: Matrix, row: Vector) : Matrix => {\n    const copy = mDeepCopy(m);\n    copy.unshift(row);\n    return copy;\n};\n\nexport const m2PrependRow = (m2: Matrix2, row: Vector2) : Matrix2 => {\n    const copy = m2DeepCopy(m2);\n    copy.unshift(row);\n    return copy;\n};\n\nexport const m3PrependRow = (m3: Matrix3, row: Vector3) : Matrix3 => {\n    const copy = m3DeepCopy(m3);\n    copy.unshift(row);\n    return copy;\n};\n\n// ------------ DELETE ROW OR COLUMN ----------------------------\n\nexport const mDelLastRow = (m: Matrix): Matrix => {\n    if(m.length <= 0) return [];\n\n    const copy = mDeepCopy(m);\n    copy.pop();\n    return copy;\n};\n\nexport const mDelFirstRow = (m: Matrix): Matrix => {\n    if(m.length <= 0) return [];\n\n    const copy = mDeepCopy(m);\n    copy.shift();\n    return copy;\n};\n\nexport const mDelLastColumn = (m: Matrix): Matrix => {\n    if(m.length <= 0) return [];\n\n    const copy = mDeepCopy(m);\n    for(let i=0; i<copy.length; i++){\n        copy[i].pop();\n    }\n\n    return copy;\n};\n\nexport const mDelFirstColumn = (m: Matrix): Matrix => {\n    if(m.length <= 0) return [];\n\n    const copy = mDeepCopy(m);\n    for(let i=0; i<copy.length; i++){\n        copy[i].shift();\n    }\n\n    return copy;\n};\n\n// ----------- GET COLUMN ---------------------------\n\nexport const mGetFirstColumn = (m: Matrix) : Vector => {\n    if(m.length <= 0) return [];\n\n    const vector: Vector = [];\n    for(let i=0; i<m.length; i++){\n        vector.push(m[i][0]);\n    }\n    return vector;\n};\n\nexport const mGetLastColumn = (m: Matrix) : Vector => {\n    if(m.length <= 0) return [];\n\n    const size = m[0].length;\n\n    const vector: Vector = [];\n    for(let i=0; i<m.length; i++){\n        vector.push(m[i][size - 1]);\n    }\n    return vector;\n};\n\nexport const mGetColumn = (m: Matrix, colIndex: number) : Vector => {\n    if(m.length <= 0) return [];\n\n    const vector: Vector = [];\n    for(let i=0; i<m.length; i++){\n        vector.push(m[i][colIndex]);\n    }\n    return vector;\n};\n\n// --------------- MULTIPLICATION ------------------------\n\n/**\n * Matrix Multiplication.\n * - Matrix multiplication is not commutative: M1 x M2 !== M2 x M1\n * - Matrix multiplication is associative: A x (B x C) = (A x B) x C.\n * - A x (B + C) = A x B + A x C\n */\nexport const mMul = (matrix1: Matrix, matrix2: Matrix, decimalPlaces = Infinity): Matrix => {\n\n    const matrix: Matrix = [];\n    for(let i=0; i<matrix1.length; i++){\n        matrix.push([]);\n    }\n\n    const transposed = mTranspose(matrix2);\n\n    if(matrix.length !== transposed.length){\n        throw new Error('The number of columns in the 1st matrix must be equal to the number of rows in the 2nd matrix.');\n    }\n\n    for(let i=0; i<matrix1.length; i++){\n        const vector1 = matrix1[i];\n\n        for(let j=0; j<transposed.length; j++){\n            const vector2 = transposed[j];\n            const product = vDotProduct(vector1, vector2, decimalPlaces);\n            matrix[i].push(product);\n        }\n    }\n\n    return matrix;\n};\n\nexport const mMulVector = (matrix: Matrix, vector: Vector, decimalPlaces = Infinity): Vector => {\n\n    if(matrix.length < 0) return [];\n\n    if(matrix[0].length !== vector.length){\n        throw new Error('The number of columns in the matrix must be equal to the length of the vector.');\n    }\n\n    const res: Vector = [];\n\n    for(let i=0; i<matrix.length; i++){\n        res[i] = vDotProduct(matrix[i], vector, decimalPlaces);\n    }\n\n    return res;\n};\n\n// --------------- EQUALITY -----------------------------\n\nexport const mEqual = (matrix1: Matrix, matrix2: Matrix): boolean => {\n    if(matrix1.length !== matrix2.length) return false;\n\n    for(let i=0; i<matrix1.length; i++){\n        if(!vEqual(matrix1[i], matrix2[i])) return false;\n    }\n\n    return true;\n};\n\n// ------------------- Determinant ---------------\n\n/**\n * Returns a matrix without provided row / col.\n * If we received a matrix M (mxm) ===> returns matrix N (m-1 x m-1)\n * The matrix must be square.\n */\nconst mMinorHelper = (m: Matrix, row: number, col: number) => {\n    const size = m.length;\n\n    if(size <= 0){\n        throw new Error('The matrix should not be empty.');\n    }\n\n    if(size !== m[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    const matrix: Matrix = [];\n\n    for(let i=0; i<size; i++){\n        if(i === row) continue;\n\n        const vector: Vector = [];\n\n        for(let j=0; j<size; j++){\n            if(j === col) continue;\n            vector.push(m[i][j]);\n        }\n\n        matrix.push(vector);\n    }\n\n    return matrix;\n};\n\n/**\n * Calculate matrix minor.\n */\nexport const mMinor = (m: Matrix, row: number, col: number) => {\n    const size = m.length;\n\n    if(size <= 0){\n        throw new Error('The matrix should not be empty.');\n    }\n\n    if(size !== m[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    // prepare the matrix without provided row and column\n    const matrix = mMinorHelper(m, row, col);\n\n    // calculate the matrix determinant\n    return mDeterminant(matrix);\n};\n\n/**\n * Calculate determinant for NxN matrix.\n * Matrix should be square.\n */\nexport const mDeterminant = (matrix: Matrix): number => {\n    const size = matrix.length;\n    if(size === 0) return 1;\n\n    if(size !== matrix[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    if(size === 1) return matrix[0][0];\n    if(size === 2) return m2Determinant(matrix as Matrix2);\n\n    let d = 0;\n\n    for(let i=0; i<size; i++){\n        const minor = mMinor(matrix, 0, i);\n\n        let param = matrix[0][i];\n        if(i % 2 !== 0){\n            param = -param;\n        }\n\n        d += minor * param;\n    }\n\n    return d;\n};\n\n/**\n * Calculate determinant for 2x2 matrix.\n * Matrix should be square.\n */\nexport const m2Determinant = (m2: Matrix2): number => {\n    if(m2.length !== m2[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    return m2[0][0] * m2[1][1] - m2[1][0] * m2[0][1];\n};\n\n/**\n * Calculate determinant for 3x3 matrix.\n * Matrix should be square.\n */\nexport const m3Determinant = (m3: Matrix3): number => {\n    if(m3.length !== m3[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    return mDeterminant(m3);\n};\n\n// ------------------ INVERSE -----------------------\n\nexport const m2Adjugate = (m2: Matrix2): Matrix2|null => {\n    if(m2.length !== m2[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    return [\n      [m2[1][1], -m2[0][1]],\n      [-m2[1][0], m2[0][0]],\n    ];\n};\n\nexport const m3Adjugate = (m3: Matrix3) : Matrix3|null => {\n    return mAdjugate(m3) as (Matrix3|null);\n};\n\n/**\n * Adjugate is a transpose of a cofactor matrix\n */\nexport const mAdjugate = (m: Matrix): Matrix|null => {\n\n    const size = m.length;\n    if(size <= 0) return null;\n\n    if(size !== m[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    if(size === 1) return m;\n\n    if(size === 2) return m2Adjugate(m as Matrix2);\n\n    // build a cofactor matrix ----------------\n    const cofactors: Matrix = [];\n\n    for(let i=0; i<size; i++){\n        const vector: Vector = [];\n        for(let j=0; j<size; j++){\n            const minor = mMinor(m, i, j);\n            const sign = Math.pow(-1, i + j)\n            vector.push(sign * minor);\n        }\n        cofactors.push(vector);\n    }\n\n    // find an Adjugate - a transpose of a cofactor matrix\n    return mTranspose(cofactors);\n};\n\n/**\n * Singular Matrix = a square matrix that does not have a matrix inverse.\n * A matrix is singular iff its determinant is 0.\n */\nexport const isSingularMatrix = (m: Matrix) => {\n    if(m.length > 0 && m.length !== m[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    const d = mDeterminant(m);\n    return d === 0;\n};\n\n/**\n * Square matrix A (nxn) is invertible is there is another square matrix B (nxn) so AxB = BxA = I\n * For A (2x2) matrix, the inverse is:\n * (1 / (determinant(A))) * adj(A)\n */\nexport const m2Inverse = (m2: Matrix2, decimalPlaces = Infinity): (Matrix2 | null) => {\n    if(m2.length > 0 && m2.length !== m2[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    const d = m2Determinant(m2);\n    if(d === 0) return null;\n\n    const adj = m2Adjugate(m2);\n    if(adj === null) return null;\n\n    return m2DivideScalar(adj, d, decimalPlaces);\n};\n\nexport const m3Inverse = (m3: Matrix3, decimalPlaces = Infinity): (Matrix3 | null) => {\n    return mInverse(m3, decimalPlaces) as (Matrix3|null);\n};\n\nexport const mInverse = (m: Matrix, decimalPlaces = Infinity): (Matrix | null) => {\n    const size = m.length;\n\n    if(size > 0 && size !== m[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    // find a determinant ----------------------\n    const d = mDeterminant(m);\n\n    // find an Adjugate - a transpose of a cofactor matrix\n    const adj = mAdjugate(m);\n    if(adj === null) return null;\n\n    return mDivideScalar(adj, d, decimalPlaces);\n};", "import { Matrix2, Matrix3, Matrix4, Matrix, Vector2, Vector3, Vector4 } from '../../types';\nimport { v2Normalize, v3MulScalar, v3Normalize } from './vector';\nimport { mMulVector, mMul } from './matrix';\nimport { setDecimalPlaces } from '../format';\n\n/*\nAny 2D affine transformation can be decomposed\ninto a rotation, followed by a scaling, followed by a\nshearing, and followed by a translation.\n---------------------------------------------------------\nAffine matrix = translation x shearing x scaling x rotation\n */\n\n// ----------------- CSS -------------------------------------\n\n/**\n * Matrix 2D in non-homogeneous coordinates to CSS matrix() function\n * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix\n */\nexport const m2ToCSS = (m: Matrix2) : string => {\n    const a = m[0][0];\n    const b = m[1][0];\n    const c = m[0][1];\n    const d = m[1][1];\n\n    return `matrix(${ a }, ${ b }, ${ c }, ${ d }, 0, 0)`;\n};\n\n/**\n * Matrix 2D in homogeneous coordinates to CSS matrix() function\n * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix\n */\nexport const m2hToCSS = (m: Matrix3) : string => {\n    const a = m[0][0];\n    const b = m[1][0];\n    const c = m[0][1];\n    const d = m[1][1];\n    const tx = m[0][2];\n    const ty = m[1][2];\n\n    return `matrix(${ a }, ${ b }, ${ c }, ${ d }, ${ tx }, ${ ty })`;\n};\n\n/**\n * Matrix 2D in homogeneous coordinates to CSS matrix3d() function\n * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix3d\n */\nexport const m2hToCSS3d = (m: Matrix3) : string => {\n    const a = m[0][0];\n    const b = m[1][0];\n    const c = m[0][1];\n    const d = m[1][1];\n    const tx = m[0][2];\n    const ty = m[1][2];\n\n    return `matrix3d(${ a }, ${ b }, 0, 0, ${ c }, ${ d }, 0, 0, 0, 0, 1, 0, ${ tx }, ${ ty }, 0, 1)`;\n};\n\n/**\n * Matrix 3D in homogeneous coordinates to CSS matrix3d() function\n * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix3d\n */\nexport const m3hToCSS3d = (m: Matrix4) : string => {\n\n    return `matrix3d(\n        ${ m[0][0] }, ${ m[0][1] }, ${ m[0][2] }, ${ m[0][3] },\n        ${ m[1][0] }, ${ m[1][1] }, ${ m[1][2] }, ${ m[1][3] },\n        ${ m[2][0] }, ${ m[2][1] }, ${ m[2][2] }, ${ m[2][3] },\n        ${ m[3][0] }, ${ m[3][1] }, ${ m[3][2] }, ${ m[3][3] }\n    )`;\n};\n\n// ---------------- TRANSLATION MATRICES ----------------------\n\nexport const m2Translation = (position: Vector2, decimalPlaces = Infinity): Matrix2 => {\n\n    return [\n        [1, 0],\n        [0, 1],\n        [setDecimalPlaces(position[0], decimalPlaces), setDecimalPlaces(position[1], decimalPlaces)],\n    ];\n};\n\nexport const m3Translation = (position: Vector3, decimalPlaces = Infinity): Matrix3 => {\n\n    return [\n        [1, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1],\n        [\n            setDecimalPlaces(position[0], decimalPlaces),\n            setDecimalPlaces(position[1], decimalPlaces),\n            setDecimalPlaces(position[2], decimalPlaces)\n        ],\n    ];\n};\n\n/**\n * 2D Translation matrix in homogeneous coordinates.\n */\nexport const m2TranslationH = (position: Vector3, decimalPlaces = Infinity): Matrix3 => {\n\n    return [\n        [1, 0, setDecimalPlaces(position[0], decimalPlaces)],\n        [0, 1, setDecimalPlaces(position[1], decimalPlaces)],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * 3D Translation matrix in homogeneous coordinates.\n */\nexport const m3TranslationH = (position: Vector4, decimalPlaces = Infinity): Matrix4 => {\n\n    return [\n        [1, 0, 0, setDecimalPlaces(position[0], decimalPlaces)],\n        [0, 1, 0, setDecimalPlaces(position[1], decimalPlaces)],\n        [0, 0, 1, setDecimalPlaces(position[2], decimalPlaces)],\n        [0, 0, 0, 1],\n    ];\n};\n\n// ---------------- ROTATION MATRICES -------------------------\n\n/**\n * Rotation of an angle about the origin.\n */\nexport const m2Rotation = (angleRad: number, isClockwise = true, decimalPlaces = Infinity): Matrix2 => {\n    const cos = setDecimalPlaces(Math.cos(angleRad), decimalPlaces);\n    const sin = setDecimalPlaces(Math.sin(angleRad), decimalPlaces);\n\n    return isClockwise ? [\n        [cos, -sin],\n        [sin, cos],\n    ] :\n    [\n        [cos, sin],\n        [-sin, cos],\n    ];\n};\n\n/**\n * Rotation of an angle about the origin in homogeneous coordinates (clockwise).\n */\nexport const m2RotationH = (angleRad: number, isClockwise = true, decimalPlaces = Infinity): Matrix3 => {\n    const cos = setDecimalPlaces(Math.cos(angleRad), decimalPlaces);\n    const sin = setDecimalPlaces(Math.sin(angleRad), decimalPlaces);\n\n    return isClockwise ? [\n        [cos, -sin, 0],\n        [sin, cos, 0],\n        [0, 0, 1],\n    ]:\n    [\n        [cos, sin, 0],\n        [-sin, cos, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Rotation of an angle \"angleRad\" around the given point (transformOrigin) in homogeneous coordinates (clockwise).\n * result_vector = TranslationMatrix(x, y) * RotationMatrix() * TranslationMatrix(-x, -y) * position_vector\n */\nexport const m2RotationAroundPointH = (\n    angleRad: number,\n    transformOrigin: Vector3,\n    isClockwise = true,\n    decimalPlaces = Infinity): Matrix3 => {\n\n    const translation = m2TranslationH(transformOrigin, decimalPlaces);\n    const rotation = m2RotationH(angleRad, isClockwise, decimalPlaces);\n    const translationBack = m2TranslationH(v3MulScalar(transformOrigin, -1), decimalPlaces);\n    const temp1 = mMul(translation, rotation);\n    return mMul(temp1, translationBack) as Matrix3;\n};\n\nexport const m2RotateAroundPointH = (\n    angleRad: number,\n    transformOrigin: Vector3,\n    position: Vector3,\n    isClockwise = true,\n    decimalPlaces = Infinity): Vector3 => {\n\n    const mat3h = m2RotationAroundPointH(angleRad, transformOrigin, isClockwise, decimalPlaces);\n    return mMulVector(mat3h, position) as Vector3;\n};\n\n/**\n * Rotate vector around the origin by angle \"angleRad\" (clockwise).\n */\nexport const v2Rotate = (angleRad: number, vector: Vector2, isClockwise = true, decimalPlaces = Infinity): Vector2 => {\n    const unitVector = v2Normalize(vector);\n    return mMulVector(m2Rotation(angleRad, isClockwise, decimalPlaces), unitVector) as Vector2;\n};\n\n/**\n * Rotate vector around the origin by angle \"angleRad\" (clockwise).\n */\nexport const v2RotateH = (angleRad: number, vector: Vector3, isClockwise = true, decimalPlaces = Infinity): Vector3 => {\n    const unitVector = v3Normalize(vector);\n    return mMulVector(m2RotationH(angleRad, isClockwise, decimalPlaces), unitVector) as Vector3;\n};\n\n/**\n * Rotation around the X axis (clockwise).\n */\nexport const m3RotationX = (angleRad: number, isClockwise = true, decimalPlaces = Infinity): Matrix3 => {\n    const cos = setDecimalPlaces(Math.cos(angleRad), decimalPlaces);\n    const sin = setDecimalPlaces(Math.sin(angleRad), decimalPlaces);\n\n    return isClockwise ? [\n        [1, 0, 0],\n        [0, cos, -sin],\n        [0, sin, cos],\n    ] :\n    [\n        [1, 0, 0],\n        [0, cos, sin],\n        [0, -sin, cos],\n    ];\n};\n\n/**\n * Rotation around the X axis (clockwise) - in homogeneous coordinates\n */\nexport const m3RotationXH = (angleRad: number, isClockwise = true, decimalPlaces = Infinity): Matrix4 => {\n    const cos = setDecimalPlaces(Math.cos(angleRad), decimalPlaces);\n    const sin = setDecimalPlaces(Math.sin(angleRad), decimalPlaces);\n\n    return isClockwise ? [\n            [1, 0, 0, 0],\n            [0, cos, -sin, 0],\n            [0, sin, cos, 0],\n            [0, 0, 0, 1],\n        ] :\n        [\n            [1, 0, 0, 0],\n            [0, cos, sin, 0],\n            [0, -sin, cos, 0],\n            [0, 0, 0, 1],\n        ];\n};\n\nexport const v3RotateX = (angleRad: number, vector: Vector3, isClockwise = true, decimalPlaces = Infinity): Vector3 => {\n    const unitVector = v3Normalize(vector);\n    return mMulVector(m3RotationX(angleRad, isClockwise, decimalPlaces), unitVector) as Vector3;\n};\n\n/**\n * Rotation around the Y axis (clockwise).\n */\nexport const m3RotationY = (angleRad: number, isClockwise = true, decimalPlaces = Infinity): Matrix3 => {\n    const cos = setDecimalPlaces(Math.cos(angleRad), decimalPlaces);\n    const sin = setDecimalPlaces(Math.sin(angleRad), decimalPlaces);\n\n    return isClockwise ? [\n        [cos, 0, sin],\n        [0, 1, 0],\n        [-sin, 0, cos],\n    ] :\n    [\n        [cos, 0, -sin],\n        [0, 1, 0],\n        [sin, 0, cos],\n    ];\n};\n\n/**\n * Rotation around the Y axis (clockwise) - in homogeneous coordinates\n */\nexport const m3RotationYH = (angleRad: number, isClockwise = true, decimalPlaces = Infinity): Matrix4 => {\n    const cos = setDecimalPlaces(Math.cos(angleRad), decimalPlaces);\n    const sin = setDecimalPlaces(Math.sin(angleRad), decimalPlaces);\n\n    return isClockwise ? [\n            [cos, 0, sin, 0],\n            [0, 1, 0, 0],\n            [-sin, 0, cos, 0],\n            [0, 0, 0, 1],\n        ] :\n        [\n            [cos, 0, -sin, 0],\n            [0, 1, 0, 0],\n            [sin, 0, cos, 0],\n            [0, 0, 0, 1],\n        ];\n};\n\nexport const v3RotateY = (angleRad: number, vector: Vector3, isClockwise = true, decimalPlaces = Infinity): Vector3 => {\n    const unitVector = v3Normalize(vector);\n    return mMulVector(m3RotationY(angleRad, isClockwise, decimalPlaces), unitVector) as Vector3;\n};\n\n/**\n * Rotation around the Z axis (clockwise).\n */\nexport const m3RotationZ = (angleRad: number, isClockwise = true, decimalPlaces = Infinity): Matrix3 => {\n\n    const cos = setDecimalPlaces(Math.cos(angleRad), decimalPlaces);\n    const sin = setDecimalPlaces(Math.sin(angleRad), decimalPlaces);\n\n    return isClockwise ? [\n        [cos, -sin, 0],\n        [sin, cos, 0],\n        [0, 0, 1],\n    ] : [\n        [cos, sin, 0],\n        [-sin, cos, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Rotation around the Z axis (clockwise)- in homogeneous coordinates\n */\nexport const m3RotationZH = (angleRad: number, isClockwise = true, decimalPlaces = Infinity): Matrix4 => {\n\n    const cos = setDecimalPlaces(Math.cos(angleRad), decimalPlaces);\n    const sin = setDecimalPlaces(Math.sin(angleRad), decimalPlaces);\n\n    return isClockwise ? [\n        [cos, -sin, 0, 0],\n        [sin, cos, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n    ] : [\n        [cos, sin, 0, 0],\n        [-sin, cos, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\nexport const v3RotateZ = (angleRad: number, vector: Vector3, isClockwise = true, decimalPlaces = Infinity): Vector3 => {\n    const unitVector = v3Normalize(vector);\n    return mMulVector(m3RotationZ(angleRad, isClockwise, decimalPlaces), unitVector) as Vector3;\n};\n\n// ---------------- SCALE MATRICES -------------\n\n/**\n * Get matrix for arbitrary scaling pivot point.\n * result_vector = TranslationMatrix(x, y) * ScaleMatrix() * TranslationMatrix(-x, -y) * scale_vector\n */\nexport const m2ScaleAtPointHMatrix = (\n    scaleVector: Vector3,\n    transformOrigin: Vector3,\n    decimalPlaces = Infinity): Matrix3 => {\n\n    const translation = m2TranslationH(transformOrigin, decimalPlaces);\n    const rotation = m2ScaleH(scaleVector);\n    const translationBack = m2TranslationH(v3MulScalar(transformOrigin, -1), decimalPlaces);\n    const temp1 = mMul(translation, rotation);\n    return mMul(temp1, translationBack) as Matrix3;\n};\n\nexport const m2ScaleAtPointH = (\n    scaleVector: Vector3,\n    transformOrigin: Vector3,\n    point: Vector3,\n    decimalPlaces = Infinity): Vector3 => {\n\n    const mat3h = m2ScaleAtPointHMatrix(scaleVector, transformOrigin, decimalPlaces);\n    return mMulVector(mat3h, point) as Vector3;\n};\n\nexport const m2Scale = (scaleVector: Vector2): Matrix2 => {\n    return [\n        [scaleVector[0], 0],\n        [0, scaleVector[1]],\n    ];\n};\n\nexport const v2Scale = (scaleVector: Vector2, vector: Vector2): Vector2 => {\n    return mMulVector(m2Scale(scaleVector), vector) as Vector2;\n};\n\n/**\n * homogeneous coordinates\n */\nexport const m2ScaleH = (scaleVector: Vector3): Matrix3 => {\n    return [\n        [scaleVector[0], 0, 0],\n        [0, scaleVector[1], 0],\n        [0, 0, 1],\n    ];\n};\n\nexport const m3Scale = (scaleVector: Vector3): Matrix3 => {\n    return [\n        [scaleVector[0], 0, 0],\n        [0, scaleVector[1], 0],\n        [0, 0, scaleVector[2]],\n    ];\n};\n\nexport const m3ScaleH = (scaleVector: Vector4): Matrix4 => {\n    return [\n        [scaleVector[0], 0, 0, 0],\n        [0, scaleVector[1], 0, 0],\n        [0, 0, scaleVector[2], 0],\n        [0, 0, 0, 1]\n    ];\n};\n\nexport const v3Scale = (scaleVector: Vector3, vector: Vector3): Vector3 => {\n    return mMulVector(m3Scale(scaleVector), vector) as Vector3;\n};\n\n/**\n * Stretch, parallel to the x-axis.\n */\nexport const m2ScaleX = (scale: number): Matrix2 => {\n    return [\n        [scale, 0],\n        [0, 1],\n    ];\n};\n\n/**\n * Stretch, parallel to the x-axis - homogeneous coordinates\n */\nexport const m2ScaleXH = (scale: number): Matrix3 => {\n    return [\n        [scale, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Stretch in x-direction\n */\nexport const m3ScaleX = (scale: number): Matrix3 => {\n    return [\n        [scale, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Stretch in x-direction\n */\nexport const m3ScaleXH = (scale: number): Matrix4 => {\n    return [\n        [scale, 0, 0, 0],\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\n/**\n * Stretch in y-direction\n */\nexport const m3ScaleY = (scale: number): Matrix3 => {\n    return [\n        [1, 0, 0],\n        [0, scale, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Stretch in y-direction\n */\nexport const m3ScaleYH = (scale: number): Matrix => {\n    return [\n        [1, 0, 0, 0],\n        [0, scale, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\n/**\n * Stretch in z-direction\n */\nexport const m3ScaleZ = (scale: number): Matrix3 => {\n    return [\n        [1, 0, 0],\n        [0, 1, 0],\n        [0, 0, scale],\n    ];\n};\n\n/**\n * Stretch in z-direction\n */\nexport const m3ScaleZH = (scale: number): Matrix4 => {\n    return [\n        [1, 0, 0, 0],\n        [0, 1, 0, 0],\n        [0, 0, scale, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\n/**\n * Stretch, parallel to the y-axis.\n */\nexport const m2ScaleY = (scale: number): Matrix2 => {\n    return [\n        [1, 0],\n        [0, scale],\n    ];\n};\n\n/**\n * Stretch, parallel to the y-axis - homogeneous coordinates\n */\nexport const m2ScaleYH = (scale: number): Matrix3 => {\n    return [\n        [1, 0, 0],\n        [0, scale, 0],\n        [0, 0, 1],\n    ];\n};\n\n// ---------------- REFLECTION MATRICES -------------------------\n\n/**\n * Reflection about the origin.\n */\nexport const m2ReflectionOrigin = (): Matrix2 => {\n\n    return [\n        [-1, 0],\n        [0, -1],\n    ];\n};\n\n/**\n * Reflection about the origin.\n */\nexport const m2ReflectionOriginH = (): Matrix3 => {\n\n    return [\n        [-1, 0, 0],\n        [0, -1, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Reflection about the origin in non-homogeneous coordinates\n */\nexport const m3ReflectionOrigin = (): Matrix3 => {\n\n    return [\n        [-1, 0, 0],\n        [0, -1, 0],\n        [0, 0, -1],\n    ];\n};\n\n/**\n * Reflection about the origin in homogeneous coordinates\n */\nexport const m3ReflectionOriginH = (): Matrix4 => {\n\n    return [\n        [-1, 0, 0, 0],\n        [0, -1, 0, 0],\n        [0, 0, -1, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\n/**\n * Reflection about y=-x\n */\nexport const m2ReflectionYmX = (): Matrix2 => {\n\n    return [\n        [0, -1],\n        [-1, 0],\n    ];\n};\n\n/**\n * Reflection in the x-axis.\n */\nexport const m2ReflectionX = (): Matrix2 => {\n\n    return [\n        [1, 0],\n        [0, -1],\n    ];\n};\n\n/**\n * Reflection in the x-axis.\n */\nexport const m2ReflectionXH = (): Matrix3 => {\n\n    return [\n        [1, 0, 0],\n        [0, -1, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Reflection in the y-axis.\n */\nexport const m2ReflectionY = (): Matrix2 => {\n\n    return [\n        [-1, 0],\n        [0, 1],\n    ];\n};\n\nexport const m2ReflectionYH = (): Matrix3 => {\n\n    return [\n        [-1, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Reflection relative to YZ plane in non-homogeneous coordinates\n */\nexport const m3ReflectionYZ = (): Matrix3 => {\n\n    return [\n        [-1, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Reflection relative to YZ plane in homogeneous coordinates\n */\nexport const m3ReflectionYZH = (): Matrix4 => {\n\n    return [\n        [-1, 0, 0, 0],\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\n/**\n * Reflection relative to XZ plane in non-homogeneous coordinates\n */\nexport const m3ReflectionXZ = (): Matrix3 => {\n\n    return [\n        [1, 0, 0],\n        [0, -1, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Reflection relative to XZ plane in homogeneous coordinates\n */\nexport const m3ReflectionXZH = (): Matrix4 => {\n\n    return [\n        [1, 0, 0, 0],\n        [0, -1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\n/**\n * Reflection relative to XY plane in non-homogeneous coordinates\n */\nexport const m3ReflectionXY = (): Matrix3 => {\n\n    return [\n        [1, 0, 0],\n        [0, 1, 0],\n        [0, 0, -1],\n    ];\n};\n\n/**\n * Reflection relative to XY plane in homogeneous coordinates\n */\nexport const m3ReflectionXYH = (): Matrix4 => {\n\n    return [\n        [1, 0, 0, 0],\n        [0, 1, 0, 0],\n        [0, 0, -1, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\n// ---------------- SHEARING MATRICES -------------------------\n\n\n/**\n * Shearing in y-axis, with x-axis fixed with (0,1) moving to (factor, 1)\n */\nexport const m2ShearingY = (factor: number): Matrix2 => {\n\n    return [\n        [1, factor],\n        [0, 1],\n    ];\n};\n\n/**\n * Shearing in x-axis, with y-axis fixed with (1,0) moving to (1, factor)\n */\nexport const m2ShearingX = (factor: number): Matrix2 => {\n\n    return [\n        [1, 0],\n        [factor, 1],\n    ];\n};", "import { setDecimalPlaces } from './format';\n\n/**\n * Returns a random number in the [min,max] range.\n */\nexport const getRandom = (min: number, max: number, decimalPlaces = Infinity): number => {\n    return setDecimalPlaces(Math.random() * (max - min) + min, decimalPlaces);\n};\n\n/**\n * Returns a random integer number in the [min,max] range.\n */\nexport const getRandomInt = (min: number, max: number): number => {\n    return Math.floor(Math.random() * (max - min + 1) + min);\n};\n\nexport const getRandomBoolean = () => Math.random() < 0.5;\n\n/* eslint-disable  @typescript-eslint/no-explicit-any */\nexport const getRandomItemFromArray = (array: any[]) => {\n    const randomIndex = getRandomInt(0, array.length - 1);\n    return array[randomIndex];\n};", "export const mod = (n: number, m: number) => {\n    return ((n % m) + m) % m;\n};\n\n/**\n * Convert range [a, b] to [c, d].\n * f(x) = (d - c) * (x - a) / (b - a) + c\n */\nexport const convertRange = (x: number, a: number, b: number, c: number, d: number) => {\n    return (d - c) * (x - a) / (b - a) + c;\n};\n\n/**\n * Check if 2 ranges [a,b] and [c,d] overlap.\n */\nexport const doRangesOverlap = (a: number, b: number, c: number, d: number) => {\n    return Math.max(a, c) <= Math.min(b, d) ;\n};\n\n// eslint-disable-next-line\nexport const isNumber = (value: any) => {\n    return !isNaN(parseFloat(value)) && isFinite(value);\n};\n", "export const stringToNumber = (value: string|undefined|null|number, defaultNumber: number) => {\n    if(value === undefined || value === null) return defaultNumber;\n    const res = Number(value) ?? defaultNumber;\n    return isNaN(res) ? defaultNumber : res;\n};", "import { setDecimalPlaces } from './format';\nimport { Vector2, Vector3 } from '../types';\n\n/**\n * u(x) and v(x) are functions ---------->\n *\n * dx(u + v) = dx(u) + dx(v)\n * dx(u - v) = dx(u) - dx(v)\n * dx(u * v) = dx(u) * v + u * dx(v)\n * dx(u / v) = (dx(u) * v - u * dx(v)) / (v ^ 2), when v(x) != 0\n */\n\n// ------------------ Derivatives of Polynomial ---------------------------\n\n/**\n * y = 3x+2\n * dxPolynomial(10, [[3, 1], [2, 0]])\n */\nexport const dxPolynomial = (x: number, polynomial: number[][], decimalPlaces = Infinity) => {\n    let res = 0;\n\n    for(const part of polynomial){\n        if(part.length !== 2) return NaN;\n\n        const coeff = part[0];\n        const power = part[1];\n        res += coeff * power * Math.pow(x, power - 1);\n    }\n\n    return setDecimalPlaces(res, decimalPlaces);\n}\n\n// ---------------------- Bezier Curves ---------------------------\n\n/**\n * Derivative of Bezier Curve is another Bezier Curve.\n * t must min in range [0, 1]\n */\nexport const dxV2QuadraticBezierCurve = (\n    t: number,\n    startControlPoint: Vector2,\n    centerControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2 => {\n\n    // The derivative: P1 * (2t-2) + (2*P3-4*P2) * t + 2 * P2\n\n    const temp1 = -2 * (1 - t); // Math.pow(1 - t, 2)\n    const temp2 = 2 - 4 * t; // (1 - t) * 2 * t\n    const temp3 = 2 * t; //t * t;\n\n    return [\n        setDecimalPlaces(temp1 * startControlPoint[0] + temp2 * centerControlPoint[0] + temp3 * endControlPoint[0], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[1] + temp2 * centerControlPoint[1] + temp3 * endControlPoint[1], decimalPlaces),\n    ];\n};\n\nexport const dxV3QuadraticBezierCurve = (\n    t: number,\n    startControlPoint: Vector3,\n    centerControlPoint: Vector3,\n    endControlPoint: Vector3,\n    decimalPlaces = Infinity\n) : Vector3 => {\n\n    const temp1 = -2 * (1 - t); // Math.pow(1 - t, 2)\n    const temp2 = 2 - 4 * t; // (1 - t) * 2 * t\n    const temp3 = 2 * t; //t * t;\n\n    return [\n        setDecimalPlaces(temp1 * startControlPoint[0] + temp2 * centerControlPoint[0] + temp3 * endControlPoint[0], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[1] + temp2 * centerControlPoint[1] + temp3 * endControlPoint[1], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[2] + temp2 * centerControlPoint[2] + temp3 * endControlPoint[2], decimalPlaces),\n    ];\n};\n\nexport const dxV2CubicBezierCurve = (\n    t: number,\n    startControlPoint: Vector2,\n    center1ControlPoint: Vector2,\n    center2ControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2 => {\n\n    const temp1 = -3 * Math.pow(1 - t, 2); //Math.pow(1 - t, 3);\n    const temp2 = 3 * (t - 1) * (3 * t - 1); //Math.pow(1 - t, 2) * 3 * t;\n    const temp3 = 6 * t - 9 * t * t; // (1 - t) * 3 * t * t;\n    const temp4 = 3 * t * t; //t * t * t;\n\n    return [\n        setDecimalPlaces(temp1 * startControlPoint[0] + temp2 * center1ControlPoint[0] + temp3 * center2ControlPoint[0] + temp4 * endControlPoint[0], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[1] + temp2 * center1ControlPoint[1] + temp3 * center2ControlPoint[1] + temp4 * endControlPoint[1], decimalPlaces),\n    ];\n};\n\nexport const dxV3CubicBezierCurve = (\n    t: number,\n    startControlPoint: Vector3,\n    center1ControlPoint: Vector3,\n    center2ControlPoint: Vector3,\n    endControlPoint: Vector3,\n    decimalPlaces = Infinity\n) : Vector3 => {\n\n    const temp1 = -3 * Math.pow(1 - t, 2); //Math.pow(1 - t, 3);\n    const temp2 = 3 * (t - 1) * (3 * t - 1); //Math.pow(1 - t, 2) * 3 * t;\n    const temp3 = 6 * t - 9 * t * t; // (1 - t) * 3 * t * t;\n    const temp4 = 3 * t * t; //t * t * t;\n\n    return [\n        setDecimalPlaces(temp1 * startControlPoint[0] + temp2 * center1ControlPoint[0] + temp3 * center2ControlPoint[0] + temp4 * endControlPoint[0], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[1] + temp2 * center1ControlPoint[1] + temp3 * center2ControlPoint[1] + temp4 * endControlPoint[1], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[2] + temp2 * center1ControlPoint[2] + temp3 * center2ControlPoint[2] + temp4 * endControlPoint[2], decimalPlaces),\n    ];\n};\n\n\n// ----------------- Derivatives of trigonometry functions ---------------------------\n\nexport const dxSin = (x: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(Math.cos(x), decimalPlaces);\n};\n\nexport const dxCos = (x: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(-Math.sin(x), decimalPlaces);\n};\n\nexport const dxTan = (x: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(1 / (Math.cos(x) ** 2), decimalPlaces);\n};\n\n/**\n * x != Math.PI * n, where n is an integer\n */\nexport const dxCot = (x: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(-1 / (Math.sin(x) ** 2), decimalPlaces);\n};\n\n/**\n * -1 < x < 1\n */\nexport const dxArcSin = (x: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(1 / (Math.sqrt(1 - x ** 2)), decimalPlaces);\n};\n\n/**\n * -1 < x < 1\n */\nexport const dxArcCos = (x: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(-1 / (Math.sqrt(1 - x ** 2)), decimalPlaces);\n};\n\nexport const dxArcTan = (x: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(1 / (1 + x ** 2), decimalPlaces);\n};\n\nexport const dxArcCot = (x: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(-1 / (1 + x ** 2), decimalPlaces);\n};\n", "import { Matrix, Matrix2, Matrix3, Vector, Vector2, Vector3 } from '../../types';\nimport { m2Inverse, m3Inverse, mInverse, mMulVector, mDelLastColumn, mGetLastColumn } from '../linear-algebra/matrix';\nimport { setDecimalPlaces } from '../format';\n\n/**\n * Linear equation\n * ax + b = c\n * x = (c - b) / a; a != 0\n */\nexport const linearEquation = (equation: Vector3, decimalPlaces = Infinity) : number => {\n    const a = equation[0];\n    const b = equation[1];\n    const c = equation[2];\n\n    const diff = c - b;\n\n    if(a === 0 && diff === 0) return Infinity; // any number is a solution\n    if(a === 0) return NaN; // no solution\n\n    return setDecimalPlaces(diff / a, decimalPlaces);\n};\n\n/**\n * System of 2 linear equations.\n * [x, y] = inverse(Matrix of equation parameters) x (vector of equation results)\n * ---------------\n * 3x + 2y = 7\n * -6x + 6y = 6\n */\nexport const linearEquationSystem2 = (equation1: Vector3, equation2: Vector3, decimalPlaces = Infinity) : Vector2 | null => {\n    const equationParams: Matrix2 = [\n        [equation1[0], equation1[1]],\n        [equation2[0], equation2[1]],\n    ];\n\n    const inversed = m2Inverse(equationParams);\n    if(inversed === null) return null; // no results\n\n    const equationResults: Vector2 = [\n        equation1[2],\n        equation2[2]\n    ];\n\n    return mMulVector(inversed, equationResults, decimalPlaces) as Vector2;\n};\n\n/**\n * System of 3 linear equations.\n * ---------------------------------------\n * 3x + 2y + 5z = 7\n * -6x + 6y + 6z = 6\n * 2x + 7y - z = 4\n */\nexport const linearEquationSystem3 = (\n    equation1: Vector,\n    equation2: Vector,\n    equation3: Vector,\n    decimalPlaces = Infinity) : Vector3 | null => {\n    const equationParams: Matrix3 = [\n        [equation1[0], equation1[1], equation1[2]],\n        [equation2[0], equation2[1], equation2[2]],\n        [equation3[0], equation3[1], equation3[2]],\n    ];\n\n    const inversed = m3Inverse(equationParams);\n    if(inversed === null) return null; // no results\n\n    const equationResults: Vector3 = [\n        equation1[3],\n        equation2[3],\n        equation3[3]\n    ];\n\n    return mMulVector(inversed, equationResults, decimalPlaces) as Vector3;\n};\n\n/**\n * System of N linear equations.\n */\nexport const linearEquationSystemN = (equations: Matrix, decimalPlaces = Infinity) : Vector | null => {\n    if(equations.length <= 0) return null;\n\n    const equationParams = mDelLastColumn(equations);\n\n    const inversed = mInverse(equationParams);\n    if(inversed === null) return null; // no results\n\n    // the last column of the equations matrix\n    const equationResults = mGetLastColumn(equations);\n\n    return mMulVector(inversed, equationResults, decimalPlaces) as Vector;\n};", "import { Vector } from '../../types';\nimport { setDecimalPlaces } from '../format';\nimport { linearEquation } from './linear-equations';\nimport { isNumber } from '../other';\n\n/**\n * Quadratic Equation.\n * ax^2 + bx + c = d\n */\nexport const quadraticEquation = (equation: Vector, decimalPlaces = Infinity) : Vector => {\n    const a = equation[0];\n    const b = equation[1];\n    const c = equation[2];\n    const d = equation[3];\n\n    if(a === 0){\n        // it's a linear equation -------------------------------------------\n        const res = linearEquation([b, c, d], decimalPlaces);\n        if(isNumber(res)) return [res];\n        return [];\n    }\n\n    const diff = c - d;\n\n    const discriminant = b * b - (4 * a * diff);\n\n    if(discriminant < 0){\n        return []; // no results\n    }\n\n    if(discriminant === 0){\n        return [ setDecimalPlaces(-b / (2 * a), decimalPlaces) ]; // 1 result\n    }\n\n    // if(determinant > 0) ---> 2 results\n    const t1 = 2 * a;\n    const t2 = Math.sqrt(discriminant);\n\n    return [\n        setDecimalPlaces((-b + t2) / t1, decimalPlaces),\n        setDecimalPlaces((-b - t2) / t1, decimalPlaces),\n    ];\n};", "import { IBBox, Vector, Vector2, Vector3 } from '../../types';\nimport { setDecimalPlaces } from '../format';\nimport {\n    dxV2CubicBezierCurve,\n    dxV2QuadraticBezierCurve,\n    dxV3CubicBezierCurve,\n    dxV3QuadraticBezierCurve\n} from '../derivative';\nimport { v2Normalize, v3Normalize } from '../linear-algebra/vector';\nimport { linearEquation } from '../equations/linear-equations';\nimport { quadraticEquation } from '../equations/quadratic-equations';\nimport { isNumber } from '../other';\n\n/**\n * B\u00E9zier Curves\n * quadratic: y = P1 * (1-t)\u00B2 + P2 * 2 * (1-t)t + P3 * t\u00B2\n * t in range [0, 1]\n */\n\n// -------------------- GET POINT ON CURVE --------------------------\n\n/**\n * Get a point on a quadratic B\u00E9zier curve as a function of time.\n */\nexport const v2QuadraticBezierCurve = (\n    t: number,\n    startControlPoint: Vector2,\n    centerControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2 => {\n\n    const temp1 = Math.pow(1 - t, 2);\n    const temp2 = (1 - t) * 2 * t;\n    const temp3 = t * t;\n\n    return [\n        setDecimalPlaces(temp1 * startControlPoint[0] + temp2 * centerControlPoint[0] + temp3 * endControlPoint[0], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[1] + temp2 * centerControlPoint[1] + temp3 * endControlPoint[1], decimalPlaces),\n    ];\n};\n\nexport const v3QuadraticBezierCurve = (\n    t: number,\n    startControlPoint: Vector3,\n    centerControlPoint: Vector3,\n    endControlPoint: Vector3,\n    decimalPlaces = Infinity\n) : Vector3 => {\n\n    const temp1 = Math.pow(1 - t, 2);\n    const temp2 = (1 - t) * 2 * t;\n    const temp3 = t * t;\n\n    return [\n        setDecimalPlaces(temp1 * startControlPoint[0] + temp2 * centerControlPoint[0] + temp3 * endControlPoint[0], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[1] + temp2 * centerControlPoint[1] + temp3 * endControlPoint[1], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[2] + temp2 * centerControlPoint[2] + temp3 * endControlPoint[2], decimalPlaces),\n    ];\n};\n\n/**\n * Get a point on a cubic B\u00E9zier curve as a function of time.\n */\nexport const v2CubicBezierCurve = (\n    t: number,\n    startControlPoint: Vector2,\n    center1ControlPoint: Vector2,\n    center2ControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2 => {\n\n    const temp1 = Math.pow(1 - t, 3);\n    const temp2 = Math.pow(1 - t, 2) * 3 * t;\n    const temp3 = (1 - t) * 3 * t * t;\n    const temp4 = t * t * t;\n\n    return [\n        setDecimalPlaces(temp1 * startControlPoint[0] + temp2 * center1ControlPoint[0] + temp3 * center2ControlPoint[0] + temp4 * endControlPoint[0], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[1] + temp2 * center1ControlPoint[1] + temp3 * center2ControlPoint[1] + temp4 * endControlPoint[1], decimalPlaces),\n    ];\n};\n\nexport const v3CubicBezierCurve = (\n    t: number,\n    startControlPoint: Vector3,\n    center1ControlPoint: Vector3,\n    center2ControlPoint: Vector3,\n    endControlPoint: Vector3,\n    decimalPlaces = Infinity\n) : Vector3 => {\n\n    const temp1 = Math.pow(1 - t, 3);\n    const temp2 = Math.pow(1 - t, 2) * 3 * t;\n    const temp3 = (1 - t) * 3 * t * t;\n    const temp4 = t * t * t;\n\n    return [\n        setDecimalPlaces(temp1 * startControlPoint[0] + temp2 * center1ControlPoint[0] + temp3 * center2ControlPoint[0] + temp4 * endControlPoint[0], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[1] + temp2 * center1ControlPoint[1] + temp3 * center2ControlPoint[1] + temp4 * endControlPoint[1], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[2] + temp2 * center1ControlPoint[2] + temp3 * center2ControlPoint[2] + temp4 * endControlPoint[2], decimalPlaces),\n    ];\n};\n\n// -------------------- TANGENT --------------------------\n\n/**\n * Tangent indicates the direction of travel at specific points along the B\u00E9zier curve,\n * and is literally just the first derivative of our curve.\n */\nexport const v2QuadraticBezierCurveTangent = (\n    t: number,\n    startControlPoint: Vector2,\n    centerControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2 => {\n    const dxVector = dxV2QuadraticBezierCurve(t, startControlPoint, centerControlPoint, endControlPoint);\n    return v2Normalize(dxVector, decimalPlaces);\n};\n\nexport const v3QuadraticBezierCurveTangent = (\n    t: number,\n    startControlPoint: Vector3,\n    centerControlPoint: Vector3,\n    endControlPoint: Vector3,\n    decimalPlaces = Infinity\n) : Vector3 => {\n    const dxVector = dxV3QuadraticBezierCurve(t, startControlPoint, centerControlPoint, endControlPoint);\n    return v3Normalize(dxVector, decimalPlaces);\n};\n\nexport const v2CubicBezierCurveTangent = (\n    t: number,\n    startControlPoint: Vector2,\n    center1ControlPoint: Vector2,\n    center2ControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2 => {\n    const dxVector = dxV2CubicBezierCurve(t, startControlPoint, center1ControlPoint, center2ControlPoint, endControlPoint);\n    return v2Normalize(dxVector, decimalPlaces);\n};\n\nexport const v3CubicBezierCurveTangent = (\n    t: number,\n    startControlPoint: Vector3,\n    center1ControlPoint: Vector3,\n    center2ControlPoint: Vector3,\n    endControlPoint: Vector3,\n    decimalPlaces = Infinity\n) : Vector3 => {\n    const dxVector = dxV3CubicBezierCurve(t, startControlPoint, center1ControlPoint, center2ControlPoint, endControlPoint);\n    return v3Normalize(dxVector, decimalPlaces);\n};\n\n// -------------------- NORMAL --------------------------\n\n/**\n * Normal is a vector that runs at a right angle to the direction of the curve, and is typically of length 1.\n * To find it, we take the normalised tangent vector, and then rotate it by a 90 degrees.\n */\nexport const v2QuadraticBezierCurveNormal = (\n    t: number,\n    startControlPoint: Vector2,\n    centerControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2 => {\n\n    const tangent = v2QuadraticBezierCurveTangent(t, startControlPoint, centerControlPoint, endControlPoint, decimalPlaces);\n    return [-tangent[1], tangent[0]];\n};\n\nexport const v2CubicBezierCurveNormal = (\n    t: number,\n    startControlPoint: Vector2,\n    center1ControlPoint: Vector2,\n    center2ControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2 => {\n\n    const tangent = v2CubicBezierCurveTangent(t, startControlPoint, center1ControlPoint, center2ControlPoint, endControlPoint, decimalPlaces);\n    return [-tangent[1], tangent[0]];\n};\n\n// -------------------- EXTREMA --------------------------\n\n/**\n * Find maxima and minima by solving the equation B'(t) = 0\n * Returns result in [0, 1] range.\n */\nexport const v2QuadraticBezierCurveExtrema = (\n    startControlPoint: Vector2,\n    centerControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector => {\n\n   /*\n    (-2 * (1 - t)) * startControlPoint[0] + (2 - 4 * t) * centerControlPoint[0] + (2 * t) * endControlPoint[0]\n    2 * t * startControlPoint[0] - 4 * t * centerControlPoint[0] + 2 * t * endControlPoint[0] - 2 * startControlPoint[0] + 2 * centerControlPoint[0]\n    t * (2  * startControlPoint[0] - 4 * centerControlPoint[0] + 2 * endControlPoint[0]) + (- 2 * startControlPoint[0] + 2 * centerControlPoint[0])\n    */\n\n    const a1 = 2  * startControlPoint[0] - 4 * centerControlPoint[0] + 2 * endControlPoint[0];\n    const b1 = -2 * startControlPoint[0] + 2 * centerControlPoint[0];\n    const equation1: Vector3 = [a1, b1, 0];\n    const res1 = linearEquation(equation1, decimalPlaces);\n\n    const a2 = 2  * startControlPoint[1] - 4 * centerControlPoint[1] + 2 * endControlPoint[1];\n    const b2 = -2 * startControlPoint[1] + 2 * centerControlPoint[1];\n    const equation2: Vector3 = [a2, b2, 0];\n    const res2 = linearEquation(equation2, decimalPlaces);\n\n    const res: Vector = [];\n\n    if(isNumber(res1)){\n        res.push(res1);\n    }\n\n    if(isNumber(res2)){\n        res.push(res2);\n    }\n\n    return res;\n};\n\n/**\n * Find maxima and minima by solving the equation B'(t) = 0\n * Returns result in [0, 1] range.\n */\nexport const v2CubicBezierCurveExtrema = (\n    startControlPoint: Vector2,\n    center1ControlPoint: Vector2,\n    center2ControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2|null => {\n\n    const a1 = -3  * startControlPoint[0] + 9 * center1ControlPoint[0] - 9 * center2ControlPoint[0] + 3 * endControlPoint[0];\n    const b1 = 6  * startControlPoint[0] - 12 * center1ControlPoint[0] + 6 * center2ControlPoint[0];\n    const c1 = -3  * startControlPoint[0] + 3 * center1ControlPoint[0];\n    const equation1: Vector = [a1, b1, c1, 0];\n\n    const a2 = -3  * startControlPoint[1] + 9 * center1ControlPoint[1] - 9 * center2ControlPoint[1] + 3 * endControlPoint[1];\n    const b2 = 6  * startControlPoint[1] - 12 * center1ControlPoint[1] + 6 * center2ControlPoint[1];\n    const c2 = -3  * startControlPoint[1] + 3 * center1ControlPoint[1];\n    const equation2: Vector = [a2, b2, c2, 0];\n\n    // Any value between 0 and 1 is a root that matters for B\u00E9zier curves, anything below or above that is irrelevant (because B\u00E9zier curves are only defined over the interval [0,1]).\n    const res1 = quadraticEquation(equation1, decimalPlaces).filter(num => num >= 0 && num <= 1);\n    const res2 = quadraticEquation(equation2, decimalPlaces).filter(num => num >= 0 && num <= 1);\n\n    const res = [...res1, ...res2];\n    if(res.length === 2){\n        return [...res1, ...res2] as Vector2;\n    }\n\n    return null;\n};\n\n// -------------------- BOUNDING BOX --------------------------\n\nexport const v2QuadraticBezierBBox = (\n    startControlPoint: Vector2,\n    centerControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : IBBox => {\n\n    const extrema = v2QuadraticBezierCurveExtrema(startControlPoint, centerControlPoint, endControlPoint);\n\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n\n    for(const percent of extrema){\n        const point = v2QuadraticBezierCurve(percent, startControlPoint, centerControlPoint, endControlPoint);\n\n        const x = point[0];\n        const y = point[1];\n\n        minX = Math.min(minX, x);\n        maxX = Math.max(maxX, x);\n\n        minY = Math.min(minY, y);\n        maxY = Math.max(maxY, y);\n    }\n\n    minX = setDecimalPlaces(Math.min(minX, startControlPoint[0], endControlPoint[0]), decimalPlaces);\n    maxX = setDecimalPlaces(Math.max(maxX, startControlPoint[0], endControlPoint[0]), decimalPlaces);\n    minY = setDecimalPlaces(Math.min(minY, startControlPoint[1], endControlPoint[1]), decimalPlaces);\n    maxY = setDecimalPlaces(Math.max(maxY, startControlPoint[1], endControlPoint[1]), decimalPlaces);\n\n    return {\n        x: minX,\n        y: minY,\n        w: Math.abs(maxX - minX),\n        h: Math.abs(maxY - minY),\n        x2: maxX,\n        y2: maxY,\n    }\n};\n\nexport const v2CubicBezierBBox = (\n    startControlPoint: Vector2,\n    center1ControlPoint: Vector2,\n    center2ControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : IBBox => {\n\n    const extrema = v2CubicBezierCurveExtrema(startControlPoint, center1ControlPoint, center2ControlPoint, endControlPoint) || [];\n\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n\n    for(const percent of extrema){\n        const point = v2CubicBezierCurve(percent, startControlPoint, center1ControlPoint, center2ControlPoint, endControlPoint);\n\n        const x = point[0];\n        const y = point[1];\n\n        minX = Math.min(minX, x ?? Infinity);\n        maxX = Math.max(maxX, x ?? -Infinity);\n\n        minY = Math.min(minY, y ?? Infinity);\n        maxY = Math.max(maxY, y ?? -Infinity);\n    }\n\n    minX = setDecimalPlaces(Math.min(minX, startControlPoint[0], endControlPoint[0]), decimalPlaces);\n    maxX = setDecimalPlaces(Math.max(maxX, startControlPoint[0], endControlPoint[0]), decimalPlaces);\n    minY = setDecimalPlaces(Math.min(minY, startControlPoint[1], endControlPoint[1]), decimalPlaces);\n    maxY = setDecimalPlaces(Math.max(maxY, startControlPoint[1], endControlPoint[1]), decimalPlaces);\n\n    return {\n        x: minX,\n        y: minY,\n        w: Math.abs(maxX - minX),\n        h: Math.abs(maxY - minY),\n        x2: maxX,\n        y2: maxY,\n    }\n};\n\n\n", "import { Vector2 } from '../types';\nimport { v2Sub } from './linear-algebra/vector';\nimport { getV2Angle } from './angle';\nimport { convertRange } from './other';\n\n/**\n * Circle Equation\n * x^2 + y^2 = radius^2\n * ----------------------\n * Circle Parametric Equation\n * x(t) = radius * cos(t)\n * y(t) = radius * sin(t)\n * t is the parameter = angle\n */\nexport const circleMovement = (center: Vector2, angle: number, radius: number): Vector2 => {\n    angle = angle % Math.PI * 2;\n\n    return [\n        center[0] + Math.cos(angle) * radius,\n        center[1] + Math.sin(angle) * radius\n    ];\n};\n\n/**\n * Circle Movement After Mouse.\n * Mouse Positions:\n * - pageX/Y coordinates are relative to the top left corner of the whole rendered page (including parts hidden by scrolling),\n * - screenX and screenY: Relative to the top left of the physical screen/monitor, this reference point only moves if you increase or decrease the number of monitors or the monitor resolution.\n * - clientX/Y coordinates are relative to the top left corner of the visible part of the page, \"seen\" through browser window.\n * - offsetX and offsetY are relative to the parent container,\n */\nexport const circleMovementAfterMouse = (\n    mouse: Vector2,\n    center: Vector2,\n    radius: number\n): Vector2 => {\n\n    const vector = v2Sub(mouse, center);\n\n    let angle = getV2Angle(vector);\n\n    // convert the angle from the range [0, Math.PI*2] to the range [0, Math.PI]\n    angle = convertRange(angle, 0, Math.PI*2, 0, Math.PI);\n\n    return circleMovement(center, angle, radius);\n};\n\n/**\n * Ellipse Equation\n * (x - centerX)^2 / (radius1^2) + (y - centerY)^2 / (radius2^2) = 1\n * -----------------------------------------------------------------\n * Ellipse Parametric Equation\n * x(t) = radius1 * cos(t)\n * y(t) = radius2 * sin(t)\n * t is the parameter = angle\n */\nexport const ellipseMovement = (center: Vector2, angle: number, radius1: number, radius2: number): Vector2 => {\n    angle = angle % Math.PI * 2;\n\n    return [\n        center[0] + Math.cos(angle) * radius1,\n        center[1] + Math.sin(angle) * radius2\n    ];\n};\n\n/**\n * Sine Wave Equation (Sinusoid)\n * -----------------------------\n * const y = amplitude * Math.sin(2 * Math.PI * frequency * x + phase);\n * amplitude = the peak deviation of the function from zero\n * frequency = number of cycles\n * phase = specifies (in radians) where in its cycle the oscillation is at t = 0.\n * think of it as \"shifting\" the starting point of the function to the right (positive p) or left (negative)\n */\nexport const sineWaveMovement = (x: number, amplitude: number, frequency: number, phase: number) : Vector2 => {\n    /*\n    example values:\n    const amplitude = 50;\n    const frequency = 0.005;\n    const phase = 0;\n    x: [0, 1000]\n     */\n    const y = amplitude * Math.sin(2 * Math.PI * frequency * x + phase);\n\n    return [x, y];\n};\n\n/**\n * Lissajous curve (Lissajous figure or Bowditch curve)\n * Parametric equation #1\n * f(t) = A * sin(k * t + m)\n * f(t) = B * sin(n * t)\n * 0 <= m <= PI/2\n * k, n >= 1\n * -----------------------\n * Parametric equation #2\n * f(t) = A * cos(k * t - m)\n * f(t) = B * cos(n * t - p)\n * -----------------------------\n * Shapes:\n * k = 1, n = 1, m = 0, p = 0 ---> line\n * A = B,  k = 1, n = 1, m = PI/2, p = PI/2 ----> circle\n * A != B, k = 1, n = 1, m = PI/2, p = PI/2 ----> ellipse\n * k = 2, n = 2, m = PI/2, p = PI/2 ----> section of a parabola\n */\nexport const lissajousCurve = (\n    width: number,\n    height: number,\n    t: number,\n    k: number,\n    n: number,\n    m: number,\n    p: number\n) :Vector2 => {\n    return [\n        width * Math.cos(k * t - m),\n        height * Math.cos(n * t - p),\n    ];\n};\n", "import { getRandom } from './random';\nimport { HSLColor, RGBColor } from '../types';\nimport { mod } from './other';\nimport { setDecimalPlaces } from './format';\n\n// ------------------------ RANDOM COLOR -------------------------------------\n\nexport const getRandomRGBColor = () : RGBColor => {\n    const hslColor = getRandomHSLColor();\n    return hslToRgb(hslColor);\n};\n\nexport const getRandomHexColor = () : string => {\n    const hslColor = getRandomHSLColor();\n    return hslToHex(hslColor);\n};\n\nexport const getRandomHSLColor = () : HSLColor => {\n    const h = getRandom(1, 360);\n    const s = getRandom(0, 100);\n    const l = getRandom(0, 100);\n    return [h, s, l];\n};\n\n/**\n * generate random color with the given hue\n */\nexport const getRandomHSLColorWithHue = (h: number) : HSLColor => {\n    const s = getRandom(0, 100);\n    const l = getRandom(0, 100);\n    return [h, s, l];\n};\n\n/**\n * generate random color with the given saturation\n */\nexport const getRandomHSLColorWithSaturation = (s: number) : HSLColor => {\n    const h = getRandom(1, 360);\n    const l = getRandom(0, 100);\n    return [h, s, l];\n};\n\n/**\n * generate random color with the given lightness\n */\nexport const getRandomHSLColorWithLightness = (l: number) : HSLColor => {\n    const h = getRandom(1, 360);\n    const s = getRandom(0, 100);\n    return [h, s, l];\n};\n\nexport const getRandomGrayscaleHSLColor = () : HSLColor => {\n    const l = getRandom(0, 100);\n    return [0, 0, l];\n};\n\nexport const getRandomHSLColorWithinRanges = (\n    hueStart = 1, hueEnd = 360,\n    saturationStart = 0, saturationEnd = 100,\n    lightStart = 0, lightEnd = 100\n) : HSLColor => {\n    const h = getRandom(hueStart, hueEnd);\n    const s = getRandom(saturationStart, saturationEnd);\n    const l = getRandom(lightStart, lightEnd);\n    return [h, s, l];\n};\n\n// ----------------------- CONVERT COLORS --------------------------------------\n\n/**\n * helper: convert hue value to %\n * @param {number} h\n * @return {number} [0, 100] %\n */\nconst convertHueToPercent = (h : number) : number => {\n\n    // the hue value needs to be multiplied by 60 to convert it to degrees\n    h *= 60;\n\n    // if hue becomes negative, you need to add 360 to, because a circle has 360 degrees\n    if(h < 0){\n        h += 360;\n    }\n\n    // convert huw to %\n    return h * 100 / 360;\n};\n\n/**\n * get hue from RGB\n * @param {number} r [0, 255]\n * @param {number} g [0, 255]\n * @param {number} b [0, 255]\n * @param {number|undefined=} min - min number of [r, g, b]\n * @param {number|undefined=} max - max number of [r, g, b]\n * @return {number} [0, 100] % - we use here % instead of [0, 359] degrees\n */\nconst getHue = (r : number, g : number, b : number, min : number | undefined = undefined, max : number | undefined = undefined) : number => {\n\n    // find the minimum and maximum values of r, g, and b if they are not provided\n    min = (min === undefined) ? Math.min(r, g, b) : min;\n    max = (min === undefined) ? Math.max(r, g, b) : max;\n\n    // if the min and max value are the same -> no hue, as it's gray\n    if(min === max) return 0;\n\n    // if red is max\n    if(max === r){\n        return convertHueToPercent((g - b) / (max - min));\n    }\n\n    // if green is max\n    if(max === g){\n        return convertHueToPercent(2.0 + (b - r) / (max - min));\n    }\n\n    // if blue is max\n    if(max === b){\n        return convertHueToPercent(4.0 + (r - g) / (max - min));\n    }\n\n    return 0;\n};\n\n/**\n * get luminance from RGB\n * @param {number} r [0, 255]\n * @param {number} g [0, 255]\n * @param {number} b [0, 255]\n * @param {number|undefined=} min - min number of [r, g, b]\n * @param {number|undefined=} max - max number of [r, g, b]\n * @return {number} [0, 100] %\n */\nconst getLuminance = (\n    r : number,\n    g : number,\n    b : number,\n    min : number | undefined = undefined,\n    max : number | undefined = undefined) : number => {\n\n    // find the minimum and maximum values of r, g, and b if they are not provided\n    min = (min === undefined) ? Math.min(r, g, b) : min;\n    max = (min === undefined) ? Math.max(r, g, b) : max;\n\n    // calculate the luminance value\n    // @ts-ignore\n    const l = (min + max) / 2; // [0, 1]\n\n    // return l value in %\n    return l * 100;\n};\n\n/**\n * get saturation from RGB\n * @param {number} r [0, 255]\n * @param {number} g [0, 255]\n * @param {number} b [0, 255]\n * @param {number|undefined=} min - min number of [r, g, b]\n * @param {number|undefined=} max - max number of [r, g, b]\n * @param {number|undefined=} l - luminance in [0, 100] %\n * @return {number} [0, 100] %\n */\nconst getSaturation = (\n    r : number,\n    g : number,\n    b : number,\n    min : number | undefined = undefined,\n    max : number | undefined = undefined,\n    l : number | undefined = undefined) : number => {\n\n    // find the minimum and maximum values of r, g, and b if they are not provided\n    min = (min === undefined) ? Math.min(r, g, b) : min;\n    max = (min === undefined) ? Math.max(r, g, b) : max;\n\n    // if the min and max value are the same -> no saturation, as it's gray\n    if(min === max) return 0;\n\n    // calculate luminance if it's not provided\n    l = (l === undefined) ? getLuminance(r, g, b) : l;\n\n    // check the level of luminance\n    const s = (l <= 50) ?\n        // @ts-ignore\n        ((max - min) / (max + min)) : // this formula is used when luminance <= 50%\n        // @ts-ignore\n        (max - min) / (2.0 - max - min);  // this formula is used when luminance > 50%\n\n    // return saturation in %\n    return s * 100;\n};\n\nexport const rgbToHsl = (rgb: RGBColor, decimalPlaces = Infinity): HSLColor => {\n\n    // convert rgb values to the range [0, 1]\n    const r = rgb[0] / 255;\n    const g = rgb[1] / 255;\n    const b = rgb[2] / 255;\n\n    // find the minimum and maximum values of r, g, and b\n    const min = Math.min(r, g, b);\n    const max = Math.max(r, g, b);\n\n    // calculate the luminance value in %\n    const l = getLuminance(r, g, b, min, max);\n\n    // calculate the saturation in %\n    const s = getSaturation(r, g, b, min, max, l);\n\n    // calculate the hue in % (not in degrees!)\n    const h = getHue(r, g, b, min, max);\n\n    if(h > 360 || s > 100 || l > 100){\n        return [0, 0, 100];\n    }\n\n    if(h < 0 || s < 0 || l < 0){\n        return [0, 0, 0];\n    }\n\n    return [\n        setDecimalPlaces(h, decimalPlaces),\n        setDecimalPlaces(s, decimalPlaces),\n        setDecimalPlaces(l, decimalPlaces),\n    ];\n};\n\n/**\n * helper: HSL to RGB\n */\nconst hslToRgbHelper = (helper1 : number, helper2 : number, colorHelper : number) : number => {\n\n    // all values need to be between 0 and 1\n    // if you get a negative value you need to add 1 to it\n    if(colorHelper < 0) colorHelper += 1;\n\n    // if you get a value above 1 you need to subtract 1 from it.\n    if(colorHelper > 1) colorHelper -= 1;\n\n    if(colorHelper * 6 < 1) return helper2 + (helper1 - helper2) * 6 * colorHelper;\n\n    if(colorHelper * 2 < 1) return helper1;\n\n    if(colorHelper * 3 < 2){\n        return helper2 + (helper1 - helper2) * (0.666 - colorHelper) * 6;\n    }\n    else{\n        return helper2;\n    }\n};\n\nexport const hslToRgb = (hsl: HSLColor, decimalPlaces = Infinity): RGBColor => {\n\n    // convert all values to [0, 1] from %\n    const h = hsl[0] / 100;\n    const s = hsl[1] / 100;\n    const l = hsl[2] / 100;\n\n    // if there is no saturation -> it\u2019s grey\n    if(s === 0){\n        // convert the luminance from [0, 1] to [0, 255]\n        const gray = l * 255;\n        return [gray, gray, gray];\n    }\n\n    // check the level of luminance\n    const helper1 = (l < 0.5) ?\n        (l * (1.0 + s)) :\n        (l + s - l * s);\n\n    const helper2 = 2 * l - helper1;\n\n    const rHelper = h + 0.333;\n    const gHelper = h;\n    const bHelper = h - 0.333;\n\n    let r = hslToRgbHelper(helper1, helper2, rHelper);\n    let g = hslToRgbHelper(helper1, helper2, gHelper);\n    let b = hslToRgbHelper(helper1, helper2, bHelper);\n\n    // convert rgb to [0, 255]\n    r *= 255;\n    g *= 255;\n    b *= 255;\n\n    if(r > 255 || g > 255 || b > 255){\n        return [255, 255, 255];\n    }\n\n    if(r < 0 || g < 0 || b < 0){\n        return [0, 0, 0];\n    }\n\n    return [\n        setDecimalPlaces(r, decimalPlaces),\n        setDecimalPlaces(g, decimalPlaces),\n        setDecimalPlaces(b, decimalPlaces),\n    ];\n};\n\n/**\n * HSL to hex\n * hslToHex(360, 100, 50)  // [360, 100, 5] ==> \"#ff0000\" (red)\n */\nexport const hslToHex = (hsl: HSLColor) => {\n\n    if(hsl[0] > 360 || hsl[1] > 100 || hsl[2] > 100){\n        return '#ffffff';\n    }\n\n    if(hsl[0] < 0 || hsl[1] < 0 || hsl[2] < 0){\n        return '#000000';\n    }\n\n    const h = hsl[0] / 360;\n    const s = hsl[1] / 100;\n    const l = hsl[2] / 100;\n\n    let r, g, b;\n    if (s === 0) {\n        r = g = b = l; // achromatic\n    } else {\n        const hue2rgb = (p: number, q: number, t: number) => {\n            if (t < 0) t += 1;\n            if (t > 1) t -= 1;\n            if (t < 1 / 6) return p + (q - p) * 6 * t;\n            if (t < 1 / 2) return q;\n            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n            return p;\n        };\n        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n        const p = 2 * l - q;\n        r = hue2rgb(p, q, h + 1 / 3);\n        g = hue2rgb(p, q, h);\n        b = hue2rgb(p, q, h - 1 / 3);\n    }\n    const toHex = (x: number) => {\n        const hex = Math.round(x * 255).toString(16);\n        return hex.length === 1 ? '0' + hex : hex;\n    };\n\n    return `#${toHex(r)}${toHex(g)}${toHex(b)}`;\n};\n\n// ----------------------- GET SHIFTED COLORS --------------------------------------\n\nexport const getShiftedHue = (color: HSLColor, shift = 180) : HSLColor => {\n    let hue = color[0];\n    hue += shift;\n\n    if (hue > 360 || hue < 0) {\n        hue = mod(hue, 360);\n    }\n\n    return [hue, color[1], color[2]];\n};\n\nexport const getShiftedLightness = (color: HSLColor, shift = 10) : HSLColor => {\n    let lightness = color[2];\n    lightness += shift;\n\n    if (lightness > 100 || lightness < 0) {\n        lightness = mod(lightness, 100);\n    }\n\n    return [color[0], color[1], lightness];\n};\n\nexport const getShiftedSaturation = (color: HSLColor, shift = 10) : HSLColor => {\n    let saturation = color[1];\n    saturation += shift;\n\n    if (saturation > 100) {\n        saturation -= 100;\n    }\n\n    if(saturation < 0){\n        saturation += 100;\n    }\n\n    return [color[0], saturation, color[2]];\n};\n", "/**\n * guid like '932ade5e-c515-4807-ac01-73b20ab3fb66'\n */\nexport const guid = () => {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g,  (c) => {\n        const r = Math.random() * 16 | 0;\n        return (c == 'x' ? r : r & 0x3 | 0x8).toString(16);\n    });\n};\n\n/**\n * id like 'df4unio1opulby2uqh4'\n */\nexport const newId = () => {\n  return Math.random().toString(36).substring(2) + (new Date()).getTime().toString(36);\n};\n", "import { setDecimalPlaces } from './format';\n\n/**\n * get the side of a square inscribed in a circle\n */\nexport const getSquareInCircleSide = (radius: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(radius * 2 / Math.sqrt(2), decimalPlaces);\n};\n", "import { ICircle, IPolygon, IRect, Matrix2, Vector2 } from '../types';\nimport { mod } from './other';\nimport { v2GetNormal, v2DotProduct } from './linear-algebra/vector';\n\n/**\n * Rectangles collision detection.\n * Rectangles should not be rotated.\n * The algorithm works by ensuring there is no gap between any of the 4 sides of the rectangles.\n * Any gap means a collision does not exist.\n * Returns true if collision is detected.\n */\nexport const rectCollide = (rect1: IRect, rect2: IRect) : boolean => {\n    return rect1.x <= rect2.x + rect2.w &&\n            rect1.x + rect1.w >= rect2.x &&\n            rect1.y <= rect2.y + rect2.h &&\n            rect1.h + rect1.y >= rect2.y;\n};\n\n/**\n * Circles collision detection.\n * This algorithm works by taking the center points of the two circles\n * and ensuring the distance between the center points\n * are less than the two radii added together.\n * Returns true if collision is detected.\n */\nexport const circleCollide = (circle1: ICircle, circle2: ICircle) => {\n    const dx = Math.abs(circle1.cx - circle2.cx);\n    const dy = Math.abs(circle1.cy - circle2.cy);\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    return distance <= circle1.r + circle2.r;\n};\n\n//-------------------- Separating Axis Theorem (SAT) Collision detection -------------------------\n\nconst getEdges = (poly: IPolygon) : Matrix2[] => {\n    const edges: Matrix2[] = [];\n\n    for(let i= 0; i<poly.length; i++){\n        const nextIndex = mod(i + 1, poly.length);\n        const edge: Matrix2 = [poly[i], poly[nextIndex]];\n        edges.push(edge);\n    }\n\n    return edges;\n};\n\nexport const convexPolygonsCollide = (poly1: IPolygon, poly2: IPolygon): boolean => {\n    const edges: Matrix2[] = [];\n\n    // collect polygon edges, and combine then into a single array\n    edges.push(...getEdges(poly1));\n    edges.push(...getEdges(poly2));\n\n    // for each edge, find the normal vector and project both polygons onto it\n    for (const edge of edges) {\n        const normal = v2GetNormal(edge[0], edge[1]);\n        const p1Proj = projectPolygon(poly1, normal);\n        const p2Proj = projectPolygon(poly2, normal);\n\n        // Check if the projections overlap\n        const isOverlap = p1Proj.max >= p2Proj.min && p2Proj.max >= p1Proj.min;\n\n        // Check if the projections overlap; if not, the polygons do not collide\n        if (!isOverlap) return false;\n    }\n\n    // If all tests pass, the polygons overlap and collide\n    return true;\n};\n\n/**\n * Project every polygon point onto the normal.\n * Then find min and max.\n */\nconst projectPolygon = (polygon: IPolygon, normal: Vector2): { min: number, max: number } => {\n    let min = Infinity;\n    let max = -Infinity;\n\n    // Project each vertex of the polygon onto the axis\n    for (const vertex of polygon) {\n        const projection = v2DotProduct(vertex, normal);\n        min = Math.min(min, projection);\n        max = Math.max(max, projection);\n    }\n\n    return { min, max };\n};", "export interface IAnimationProps {\n    duration?: number;\n    callback: (result: IAnimationResult) => void;\n    restartOnResize?: boolean;\n    resizeCallback?: (_entries: ResizeObserverEntry[], _observer: ResizeObserver) => void;\n}\n\nexport interface IAnimationResult {\n    start: () => void;\n    stop: () => void;\n    pause: () => void;\n    resume: () => void;\n    restart: () => void;\n    isAnimating: () => boolean;\n    getStartTime: () => number|undefined;\n    getElapsedTime: () => number|undefined;\n    getPercent: () => number|undefined;\n    getResizeObserver: () => ResizeObserver|undefined;\n}\n\nexport const animate = (props: IAnimationProps) : IAnimationResult => {\n\n    const _duration = props.duration !== undefined ? props.duration : Infinity;\n\n    let startTime: number|undefined = undefined; // in milliseconds\n    let animationId: number|undefined = undefined;\n\n    // the time elapsed since the start of the animation (in milliseconds)\n    let elapsed: number|undefined = undefined;\n    let previousTimeStamp: number|undefined = undefined;\n\n    let animating = false;\n    let observer: ResizeObserver|undefined = undefined;\n\n    // -------------------- COMMANDS ---------------------\n\n    const stop = () => {\n        startTime = undefined;\n        elapsed = undefined;\n        previousTimeStamp = undefined;\n        animating = false;\n\n        /*if(observer !== undefined){\n            observer.disconnect();\n            observer = undefined;\n        }*/\n\n        if(animationId === undefined) return;\n        window.cancelAnimationFrame(animationId);\n    };\n\n    const restart = () => {\n        stop();\n        start();\n    };\n\n    const pause = () => {\n        animating = false;\n    };\n\n    const resume = () => {\n        animating = true;\n    };\n\n    /**\n     * Animation Step.\n     * @param {number} timeStamp in milliseconds\n     */\n    const step = (timeStamp: DOMHighResTimeStamp) => {\n\n        if (startTime === undefined) {\n            startTime = timeStamp;\n        }\n\n        // the time elapsed since the start of the animation (in milliseconds)\n        elapsed = timeStamp - startTime;\n\n        if (animating && previousTimeStamp !== timeStamp && typeof props.callback === 'function') {\n\n            // do the rendering .............\n            props.callback(getResult());\n        }\n\n        if(elapsed <= _duration){\n            previousTimeStamp = timeStamp;\n            animationId = window.requestAnimationFrame(step);\n        }\n        else{\n            stop();\n        }\n    };\n\n    const observerHandler = (_entries: ResizeObserverEntry[], _observer: ResizeObserver) => {\n        restart();\n\n        if(typeof props.resizeCallback === 'function'){\n            props.resizeCallback(_entries, _observer);\n        }\n    };\n\n    const start = () => {\n        startTime = undefined;\n        elapsed = undefined;\n        previousTimeStamp = undefined;\n        animating = true;\n\n        if(props.restartOnResize && window.ResizeObserver && observer === undefined){\n            observer = new ResizeObserver(observerHandler);\n            observer.observe(document.body, { box: 'border-box' });\n        }\n        else{\n            animationId = window.requestAnimationFrame(step);\n        }\n    };\n\n    // --------------- GET INFO ----------------------\n\n    /**\n     * the time elapsed since the start of the animation (in milliseconds)\n     */\n    const getElapsedTime = () : number|undefined => {\n        return elapsed;\n    };\n\n    const isAnimating = () => {\n        return animating;\n    };\n\n    const getStartTime = () => {\n        return startTime;\n    };\n\n    const getPercent = () => {\n        if(_duration === Infinity || elapsed === undefined) return undefined;\n        return elapsed * 100 / _duration;\n    };\n\n    const getResizeObserver = () => {\n      return observer;\n    };\n\n    const getResult = () : IAnimationResult => {\n        return {\n\n            // commands --------------\n            start,\n            stop,\n            pause,\n            resume,\n            restart,\n\n            // information -------\n            isAnimating,\n            getElapsedTime,\n            getStartTime,\n            getPercent,\n            getResizeObserver,\n        };\n    };\n\n    return getResult();\n};\n", "export const rgbaToString = (r: number, g: number, b: number, a: number) => {\n    return `rgba(${ r }, ${ g }, ${ b }, ${ a } )`;\n};", "import { ISettings, IState } from '../interfaces';\nimport { line } from 'mz-canvas';\nimport { v2Distance } from 'mz-math';\nimport { rgbaToString } from './colors-provider';\n\n/**\n * Draw connection between the shapes.\n */\nexport const drawConnections = (options: ISettings, state: IState) => {\n\n    const { particles, ctx, connectionRgbColor } = state;\n\n    const maxConnectionSize = options.maxConnectionSize as number;\n\n    for(let i= 0; i<particles.length; i++){\n        const particle1 = particles[i];\n\n        for(let j= 0; j<particles.length; j++){\n            const particle2 = particles[j];\n\n            const distance = v2Distance(particle1.center, particle2.center);\n            if(distance < maxConnectionSize){\n\n                const opacity = options.maxConnectionSize === 0 ? 1 : (1 - distance / maxConnectionSize);\n\n                line({\n                    x1: particle1.center[0],\n                    y1: particle1.center[1],\n                    x2: particle2.center[0],\n                    y2: particle2.center[1],\n                    strokeStyle: rgbaToString(\n                        connectionRgbColor[0],\n                        connectionRgbColor[1],\n                        connectionRgbColor[2],\n                        opacity,\n                    ),\n                }, ctx);\n            }\n        }\n    }\n};", "import { IPrimitiveShapeProps } from '../interfaces';\n\n/**\n * SVG namespace that is defined in SVG v1.0 Specification\n * and subsequently added to by SVG 1.1, SVG 1.2 and SVG 2\n */\nexport const SVG_NAMESPACE= 'http://www.w3.org/2000/svg';\nexport const XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/';\nexport const DEFAULT_DECIMAL_PLACES = 2;\n\nexport interface ICreateSVGProps extends IPrimitiveShapeProps{\n    x?: string|number;\n    y?: string|number;\n    width?: string|number;\n    height?: string|number;\n    preserveAspectRatio?: string;\n    viewBox?: string;\n    autoViewBox?: boolean;\n}\n\n/**\n * Create new SVG element in browser or Node.js environment.\n * In case of Node.js, JSDom document can be provided.\n */\nexport const createSVG = (props?: ICreateSVGProps) : SVGSVGElement => {\n\n    const doc = props?.document || window.document;\n    const $svg= doc.createElementNS(SVG_NAMESPACE, 'svg');\n\n    $svg.setAttributeNS(XMLNS_NAMESPACE, 'xmlns', SVG_NAMESPACE);\n\n    let viewBox = props?.viewBox;\n    if(props?.autoViewBox){\n        viewBox = `${ props?.x || 0 } ${ props?.y || 0 } ${ props?.width || 0 } ${ props?.height || 0 }`;\n    }\n\n    setAttributes($svg, [\n        ['x', props?.x],\n        ['y', props?.y],\n        ['width', props?.width],\n        ['height', props?.height],\n        ['viewBox', viewBox],\n        ['preserveAspectRatio', props?.preserveAspectRatio],\n        ...getCommonAttributes(props),\n    ]);\n\n    return $svg;\n};\n\n/**\n * Create SVG document from string\n */\nexport const createSVGFromString = (props: {\n    document?: Document;\n    svg: string;\n}) : SVGSVGElement => {\n    const {\n        document: _document,\n        svg,\n    } = props;\n\n    const doc = _document || window.document;\n\n    const $box = doc.createElement('div');\n    $box.innerHTML = svg;\n    return $box.firstElementChild as SVGSVGElement;\n};\n\nexport const getSVGAsString = ($svg: SVGSVGElement) => {\n    return $svg.outerHTML;\n};\n\nexport const setAttributes = ($svgElement: SVGElement, attr: [string, string|number|undefined][]) => {\n    if(!$svgElement || !attr) return;\n\n    for(const pair of attr){\n        if(pair.length !== 2) continue;\n\n        const prop = pair[0];\n        if(prop === null || prop === undefined) continue;\n\n        const value = pair[1];\n        if(value === null || value === undefined) continue;\n\n        $svgElement.setAttribute(prop, value.toString());\n    }\n};\n\nexport const getCommonAttributes = (props?: IPrimitiveShapeProps) : [string, string|number|undefined][] => {\n\n    if(!props) return [];\n\n    return [\n        ['id', props.id],\n        ['class', props.classes],\n        ['style', props.style],\n\n        ['stroke', props.stroke],\n        ['stroke-width', props.strokeWidth],\n        ['stroke-opacity', props.strokeOpacity],\n        ['stroke-linecap', props.strokeLinecap],\n        ['stroke-linejoin', props.strokeLinejoin],\n        ['stroke-dasharray', props.strokeDasharray],\n        ['stroke-dashoffset', props.strokeDashoffset],\n        ['stroke-miterlimit', props.strokeMiterlimit],\n\n        ['fill', props.fill],\n        ['fill-opacity', props.fillOpacity],\n        ['fill-rule', props.fillRule],\n\n        ['filter', props.filter],\n        ['mask', props.mask],\n        ['transform', props.transform],\n\n        ['vector-effect', props.vectorEffect],\n        ['shape-rendering', props.shapeRendering],\n\n        ['clip-path', props.clipPath],\n        ['clip-rule', props.clipRule],\n\n        ['opacity', props.opacity],\n        ['visibility', props.visibility],\n    ];\n};\n", "import { getCommonAttributes, setAttributes, SVG_NAMESPACE } from '../core';\nimport { IPrimitiveShapeProps } from '../../interfaces';\n\nexport interface ICreatePathProps extends IPrimitiveShapeProps{\n    d?: string;\n    pathLength?: string|number;\n}\n\nexport const createPath = (props?: ICreatePathProps) : SVGPathElement => {\n\n    const doc = props?.document || window.document;\n\n    const $path = doc.createElementNS(SVG_NAMESPACE, 'path');\n\n    if(props?.d){\n        // remove newlines and double spaces\n        props.d = props?.d.replace(/\\s\\s+/g, ' ');\n    }\n\n    setAttributes($path, [\n        ['d', props?.d],\n        ['pathLength', props?.pathLength],\n        ...getCommonAttributes(props),\n    ]);\n\n    return $path;\n};\n\nexport interface ICreateRectProps extends IPrimitiveShapeProps{\n    x?: number|string;\n    y?: number|string;\n    width?: number|string;\n    height?: number|string;\n    rx?: number|string;\n    ry?: number|string;\n    pathLength?: string|number;\n}\n\nexport const createRect = (props?: ICreateRectProps) : SVGRectElement => {\n    const doc = props?.document || window.document;\n\n    const $rect = doc.createElementNS(SVG_NAMESPACE, 'rect');\n\n    setAttributes($rect, [\n        ['x', props?.x],\n        ['y', props?.y],\n        ['rx', props?.rx],\n        ['ry', props?.ry],\n        ['width', props?.width],\n        ['height', props?.height],\n        ['pathLength', props?.pathLength],\n        ...getCommonAttributes(props),\n    ]);\n\n    return $rect;\n};\n\nexport interface ICreateCircleProps extends IPrimitiveShapeProps{\n    cx?: string|number;\n    cy?: string|number;\n    r?: string|number;\n    pathLength?: string|number;\n}\n\nexport const createCircle = (props?: ICreateCircleProps) : SVGCircleElement => {\n\n    const doc = props?.document || window.document;\n    const $circle = doc.createElementNS(SVG_NAMESPACE, 'circle');\n\n    setAttributes($circle, [\n        ['cx', props?.cx],\n        ['cy', props?.cy],\n        ['r', props?.r],\n        ['pathLength', props?.pathLength],\n        ...getCommonAttributes(props),\n    ]);\n\n    return $circle;\n};\n\nexport interface ICreateEllipseProps extends IPrimitiveShapeProps{\n    cx?: string|number;\n    cy?: string|number;\n    rx?: string|number;\n    ry?: string|number;\n    pathLength?: string|number;\n}\n\nexport const createEllipse = (props?: ICreateEllipseProps) : SVGEllipseElement => {\n    const doc = props?.document || window.document;\n    const $ellipse = doc.createElementNS(SVG_NAMESPACE, 'ellipse');\n\n    setAttributes($ellipse, [\n        ['cx', props?.cx],\n        ['cy', props?.cy],\n        ['rx', props?.rx],\n        ['ry', props?.ry],\n        ['pathLength', props?.pathLength],\n        ...getCommonAttributes(props),\n    ]);\n\n    return $ellipse;\n};\n\nexport interface ICreateLineProps extends IPrimitiveShapeProps{\n    x1?: string|number;\n    y1?: string|number;\n    x2?: string|number;\n    y2?: string|number;\n    pathLength?: string|number;\n}\n\nexport const createLine = (props?: ICreateLineProps) : SVGLineElement => {\n    const doc = props?.document || window.document;\n    const $line = doc.createElementNS(SVG_NAMESPACE, 'line');\n\n    setAttributes($line, [\n        ['x1', props?.x1],\n        ['x2', props?.x2],\n        ['y1', props?.y1],\n        ['y2', props?.y2],\n        ['pathLength', props?.pathLength],\n        ...getCommonAttributes(props),\n    ]);\n\n    return $line;\n};\n\nexport interface ICreatePolygonProps extends IPrimitiveShapeProps{\n    points?: string;\n    pathLength?: string|number;\n}\n\nexport const createPolygon = (props?: ICreatePolygonProps) : SVGPolygonElement => {\n    const doc = props?.document || window.document;\n    const $polygon = doc.createElementNS(SVG_NAMESPACE, 'polygon');\n\n    setAttributes($polygon, [\n        ['id', props?.id],\n        ['class', props?.classes],\n        ['style', props?.style],\n        ['points', props?.points],\n        ['pathLength', props?.pathLength],\n        ...getCommonAttributes(props),\n    ]);\n\n    return $polygon;\n};\n\nexport interface ICreatePolylineProps extends IPrimitiveShapeProps{\n    points?: string;\n    pathLength?: string|number;\n}\n\nexport const createPolyline = (props?: ICreatePolylineProps) : SVGPolylineElement => {\n    const doc = props?.document || window.document;\n\n    const $polyline = doc.createElementNS(SVG_NAMESPACE, 'polyline');\n\n    setAttributes($polyline, [\n        ['id', props?.id],\n        ['class', props?.classes],\n        ['style', props?.style],\n        ['points', props?.points],\n        ['pathLength', props?.pathLength],\n        ...getCommonAttributes(props),\n    ]);\n\n    return $polyline;\n};\n", "export const setDecimalPlaces = (num: number, decimalPlaces: number | undefined = Infinity) => {\n    if(decimalPlaces === Infinity) return num;\n\n    if(decimalPlaces < 0){\n        decimalPlaces = 0;\n    }\n\n    const coefficient = 10 ** decimalPlaces;\n    return Math.round(num * coefficient) / coefficient;\n};", "import { Vector, Vector2, Vector3 } from '../types';\nimport { setDecimalPlaces } from './format';\nimport { v2Length, vNormalize, vDotProduct, vSub } from './linear-algebra/vector';\n\nexport const getV2Angle = (v2: Vector2, decimalPlaces = Infinity) => {\n    const angle = Math.atan2(v2[1], v2[0]);\n    return setDecimalPlaces(angle, decimalPlaces);\n};\n\nexport const setV2Angle = (v2: Vector2, newAngleRad: number, decimalPlaces = Infinity): Vector2 => {\n    const length = v2Length(v2);\n    return [\n        setDecimalPlaces(Math.cos(newAngleRad) * length, decimalPlaces),\n        setDecimalPlaces(Math.sin(newAngleRad) * length, decimalPlaces),\n    ];\n};\n\nexport const radiansToDegrees = (radians: number, decimalPlaces = Infinity) => {\n    const res = radians * (180 / Math.PI);\n    return setDecimalPlaces(res, decimalPlaces);\n};\n\nexport const degreesToRadians = (degrees: number, decimalPlaces = Infinity) => {\n    const res = degrees * (Math.PI / 180);\n    return setDecimalPlaces(res, decimalPlaces);\n};\n\n/**\n * Returns the range [0, Math.PI]\n * A = Math.acos( dot(v1, v2)/(v1.length()*v2.length()) );\n */\nexport const getVNAngleBetween = (vector1: Vector, vector2: Vector, decimalPlaces = Infinity) : number => {\n    const unitVector1 = vNormalize(vector1);\n    const unitVector2 = vNormalize(vector2);\n    const dotProduct = vDotProduct(unitVector1, unitVector2);\n    const angle = Math.acos(dotProduct);\n    return setDecimalPlaces(angle, decimalPlaces);\n};\n\nexport const getV2AngleBetween = (vector1: Vector2, vector2: Vector2, decimalPlaces = Infinity) : number => {\n    // return getVNAngleBetween(vector1, vector2, decimalPlaces);\n    const diff = vSub(vector1, vector2);\n    const angle = Math.atan2(diff[1], diff[0]);\n    return setDecimalPlaces(angle, decimalPlaces);\n};\n\nexport const getV3AngleBetween = (vector1: Vector3, vector2: Vector3, decimalPlaces = Infinity) : number => {\n    return getVNAngleBetween(vector1, vector2, decimalPlaces);\n};", "import { Vector, Vector2, Vector3, Vector4 } from '../../types';\nimport { setDecimalPlaces } from '../format';\nimport { getV2Angle, setV2Angle } from '../angle';\n\n// ------------ SUM ------------------------\n\nexport const vSum = (vector1: Vector, vector2: Vector, decimalPlaces = Infinity) : Vector => {\n\n    const vector: Vector = [];\n\n    for(let i=0; i<vector1.length; i++){\n        vector.push(setDecimalPlaces(vector1[i] + vector2[i], decimalPlaces));\n    }\n\n    return vector;\n};\n\nexport const v2Sum = (vector1: Vector2, vector2: Vector2, decimalPlaces = Infinity) : Vector2 => {\n    return vSum(vector1, vector2, decimalPlaces) as Vector2;\n};\n\nexport const v3Sum = (vector1: Vector3, vector2: Vector3, decimalPlaces = Infinity) : Vector3 => {\n    return vSum(vector1, vector2, decimalPlaces) as Vector3;\n};\n\n// ------------ SUB ------------------------\n\nexport const vSub = (vector1: Vector, vector2: Vector, decimalPlaces = Infinity) : Vector => {\n\n    const vector: Vector = [];\n\n    for(let i=0; i<vector1.length; i++){\n        vector.push(setDecimalPlaces(vector1[i] - vector2[i], decimalPlaces));\n    }\n\n    return vector;\n};\n\nexport const v2Sub = (vector1: Vector2, vector2: Vector2, decimalPlaces = Infinity) : Vector2 => {\n    return vSub(vector1, vector2, decimalPlaces) as Vector2;\n};\n\nexport const v3Sub = (vector1: Vector3, vector2: Vector3, decimalPlaces = Infinity) : Vector3 => {\n    return vSub(vector1, vector2, decimalPlaces) as Vector3;\n};\n\n// ------------ MUL SCALAR ------------------------\n\nexport const vMulScalar = (v: Vector, scalar: number, decimalPlaces = Infinity): Vector => {\n    const vector: Vector = [];\n\n    for(let i=0; i<v.length; i++){\n        vector.push(setDecimalPlaces(v[i] * scalar, decimalPlaces));\n    }\n\n    return vector;\n};\n\nexport const v2MulScalar = (v2: Vector2, scalar: number, decimalPlaces = Infinity): Vector2 => {\n    return vMulScalar(v2, scalar, decimalPlaces) as Vector2;\n};\n\nexport const v3MulScalar = (v3: Vector3, scalar: number, decimalPlaces = Infinity): Vector3 => {\n    return vMulScalar(v3, scalar, decimalPlaces) as Vector3;\n};\n\n// ------------ DIVIDE ------------------------\n\nexport const vDivideScalar = (v: Vector, scalar: number, decimalPlaces = Infinity): Vector => {\n    if(scalar === 0){\n        throw new Error('Division by zero error.');\n    }\n\n    const vector: Vector = [];\n\n    for(let i=0; i<v.length; i++){\n        vector.push(setDecimalPlaces(v[i] / scalar, decimalPlaces));\n    }\n\n    return vector;\n};\n\nexport const v2DivideScalar = (v2: Vector2, scalar: number, decimalPlaces = Infinity): Vector2 => {\n    return vDivideScalar(v2, scalar, decimalPlaces) as Vector2;\n};\n\nexport const v3DivideScalar = (v3: Vector3, scalar: number, decimalPlaces = Infinity): Vector3 => {\n    return vDivideScalar(v3, scalar, decimalPlaces) as Vector3;\n};\n\n// ------------ LENGTH ------------------------\n\nexport const vLength = (vector: Vector, decimalPlaces = Infinity) => {\n    let sum = 0;\n\n    for(let i=0; i<vector.length; i++){\n        sum += vector[i] * vector[i];\n    }\n\n    return setDecimalPlaces(Math.sqrt(sum), decimalPlaces);\n};\n\nexport const v2Length = (vector: Vector2, decimalPlaces = Infinity) => {\n    return vLength(vector, decimalPlaces);\n};\n\nexport const v3Length = (vector: Vector3, decimalPlaces = Infinity) => {\n    return vLength(vector, decimalPlaces);\n};\n\nexport const v2SetLength = (v2: Vector2, newLength: number, decimalPlaces = Infinity): Vector2 => {\n    const angle = getV2Angle(v2);\n    return [\n        setDecimalPlaces(Math.cos(angle) * newLength, decimalPlaces),\n        setDecimalPlaces(Math.sin(angle) * newLength, decimalPlaces),\n    ];\n};\n\n// ----------- DISTANCE ------------------------\n\nexport const vDistance = (vector1: Vector, vector2: Vector, decimalPlaces = Infinity) => {\n    const diff = vSub(vector1, vector2);\n    return vLength(diff, decimalPlaces);\n};\n\nexport const v2Distance = (vector1: Vector2, vector2: Vector2, decimalPlaces = Infinity) => {\n    const diff = vSub(vector1, vector2);\n    return vLength(diff, decimalPlaces);\n};\n\nexport const v3Distance = (vector1: Vector3, vector2: Vector3, decimalPlaces = Infinity) => {\n    const diff = vSub(vector1, vector2);\n    return vLength(diff, decimalPlaces);\n};\n\n// ------------ NORMALIZE ------------------------\n\n/**\n * Normalization creates a unit vector, which is a vector of length 1.\n */\nexport const vNormalize = (v: Vector, decimalPlaces = Infinity) : Vector => {\n    const length = vLength(v);\n    const unitVector: Vector = [];\n\n    for(let i=0; i<v.length; i++){\n        unitVector.push(length === 0 ? 0 : setDecimalPlaces(v[i] / length, decimalPlaces));\n    }\n\n    return unitVector;\n};\n\nexport const v2Normalize = (v2: Vector2, decimalPlaces = Infinity) : Vector2 => {\n    return vNormalize(v2, decimalPlaces) as Vector2;\n};\n\nexport const v3Normalize = (v3: Vector3, decimalPlaces = Infinity) : Vector3 => {\n    return vNormalize(v3, decimalPlaces) as Vector3;\n};\n\n// ------------ DOT PRODUCT ------------------------\n\nexport const vDotProduct = (vector1: Vector, vector2: Vector, decimalPlaces = Infinity) => {\n    let sum = 0;\n\n    for(let i=0; i<vector1.length; i++){\n        sum += vector1[i] * vector2[i];\n    }\n\n    return setDecimalPlaces(sum, decimalPlaces);\n};\n\nexport const v2DotProduct = (vector1: Vector2, vector2: Vector2, decimalPlaces = Infinity) => {\n    return vDotProduct(vector1, vector2, decimalPlaces);\n};\n\nexport const v3DotProduct = (vector1: Vector3, vector2: Vector3, decimalPlaces = Infinity) => {\n    return vDotProduct(vector1, vector2, decimalPlaces);\n};\n\n// ------------ CROSS PRODUCT ------------------------\n\n/**\n * Cross product is possible on 3D vectors only.\n * The cross product a \u00D7 b is defined as a vector c that is perpendicular (orthogonal) to both a and b.\n */\nexport const v3CrossProduct = (vector1: Vector3, vector2: Vector3, decimalPlaces = Infinity): Vector3 => {\n    return [\n        setDecimalPlaces(vector1[1] * vector2[2] - vector1[2] * vector2[1], decimalPlaces),\n        setDecimalPlaces(vector1[2] * vector2[0] - vector1[0] * vector2[2], decimalPlaces),\n        setDecimalPlaces(vector1[0] * vector2[1] - vector1[1] * vector2[0], decimalPlaces),\n    ];\n};\n\n// --------------- INIT VECTOR HELPER -----------------\n\nexport const v2 = (defaultValue = 0): Vector2 => {\n    return [defaultValue, defaultValue];\n};\n\nexport const v3 = (defaultValue = 0): Vector3 => {\n    return [defaultValue, defaultValue, defaultValue];\n};\n\nexport const v4 = (defaultValue = 0): Vector4 => {\n    return [defaultValue, defaultValue, defaultValue, defaultValue];\n};\n\nexport const vN = (N: number, defaultValue = 0): Vector => {\n\n    if(N < 0){\n        throw new Error('N must be a non-negative number.');\n    }\n\n    const vector: Vector = [];\n    for(let i=0; i<N; i++){\n        vector.push(defaultValue);\n    }\n    return vector;\n};\n\n/**\n * Initialize vector using polar coordinates\n */\nexport const v2FromPolarCoords = (distance: number, angleRad: number): Vector2 => {\n    let vector: Vector2 = [0, 0];\n    vector = v2SetLength(vector, distance);\n    return setV2Angle(vector, angleRad);\n};\n\n// --------------- EQUALITY -------------------------\n\nexport const vEqual = (vector1: Vector, vector2: Vector): boolean => {\n    if(vector1.length !== vector2.length) return false;\n\n    for(let i=0; i<vector1.length; i++){\n        if(vector1[i] !== vector2[i]) return false;\n    }\n\n    return true;\n};", "import { Matrix2, Matrix3, Matrix4, Matrix, Vector, Vector2, Vector3 } from '../../types';\nimport { vMulScalar, vSum, vSub, vDotProduct, vN, vEqual, vDivideScalar } from './vector';\n\n// --------------- SUM ----------------------\n\nexport const mSum = (matrix1: Matrix, matrix2: Matrix, decimalPlaces = Infinity): Matrix => {\n    const matrix: Matrix = [];\n\n    for(let i=0; i<matrix1.length; i++){\n        matrix.push(vSum(matrix1[i], matrix2[i], decimalPlaces));\n    }\n\n    return matrix;\n};\n\nexport const m2Sum = (matrix1: Matrix2, matrix2: Matrix2, decimalPlaces = Infinity): Matrix2 => {\n    return mSum(matrix1, matrix2, decimalPlaces) as Matrix2;\n};\n\nexport const m3Sum = (matrix1: Matrix3, matrix2: Matrix3, decimalPlaces = Infinity): Matrix3 => {\n    return mSum(matrix1, matrix2, decimalPlaces) as Matrix3;\n};\n\n// --------------- SUB ----------------------\n\nexport const mSub = (matrix1: Matrix, matrix2: Matrix, decimalPlaces = Infinity): Matrix => {\n    const matrix: Matrix = [];\n\n    for(let i=0; i<matrix1.length; i++){\n        matrix.push(vSub(matrix1[i], matrix2[i], decimalPlaces));\n    }\n\n    return matrix;\n};\n\nexport const m2Sub = (matrix1: Matrix2, matrix2: Matrix2, decimalPlaces = Infinity): Matrix2 => {\n    return mSub(matrix1, matrix2, decimalPlaces) as Matrix2;\n};\n\nexport const m3Sub = (matrix1: Matrix3, matrix2: Matrix3, decimalPlaces = Infinity): Matrix3 => {\n    return mSub(matrix1, matrix2, decimalPlaces) as Matrix3;\n};\n\n// --------------- MUL SCALAR ----------------------\n\nexport const mMulScalar = (m: Matrix, scalar: number, decimalPlaces = Infinity): Matrix => {\n    const matrix: Matrix = [];\n\n    for(const v of m){\n        matrix.push(vMulScalar(v, scalar, decimalPlaces));\n    }\n\n    return matrix;\n};\n\nexport const m2MulScalar = (m2: Matrix2, scalar: number, decimalPlaces = Infinity): Matrix2 => {\n    return mMulScalar(m2, scalar, decimalPlaces) as Matrix2;\n};\n\nexport const m3MulScalar = (m3: Matrix3, scalar: number, decimalPlaces = Infinity): Matrix3 => {\n    return mMulScalar(m3, scalar, decimalPlaces) as Matrix3;\n};\n\n// --------------- DIVIDE SCALAR ----------------------\n\nexport const mDivideScalar = (m: Matrix, scalar: number, decimalPlaces = Infinity): Matrix => {\n    if(scalar === 0){\n        throw new Error('Division by zero error.');\n    }\n\n    const matrix: Matrix = [];\n\n    for(const v of m){\n        matrix.push(vDivideScalar(v, scalar, decimalPlaces));\n    }\n\n    return matrix;\n};\n\nexport const m2DivideScalar = (m2: Matrix2, scalar: number, decimalPlaces = Infinity): Matrix2 => {\n    return mDivideScalar(m2, scalar, decimalPlaces) as Matrix2;\n};\n\nexport const m3DivideScalar = (m3: Matrix3, scalar: number, decimalPlaces = Infinity): Matrix3 => {\n    return mDivideScalar(m3, scalar, decimalPlaces) as Matrix3;\n};\n\n\n// --------------- TRANSPOSE ----------------------\n\nexport const mTranspose = (m: Matrix): Matrix => {\n\n    const vectorsCount = m.length;\n    if(vectorsCount <= 0) return m;\n\n    const vectorLength = m[0].length;\n    if(vectorLength <= 0) return m;\n\n    const matrix: Matrix = [];\n    for(let i=0; i<vectorLength; i++){\n        matrix.push([]);\n    }\n\n    for(let i=0; i<vectorsCount; i++){\n        for(let j=0; j<vectorLength; j++){\n            matrix[j].push(m[i][j]);\n        }\n    }\n\n    return matrix;\n};\n\nexport const m2Transpose = (m2: Matrix2): Matrix => {\n    return mTranspose(m2);\n};\n\nexport const m3Transpose = (m3: Matrix3): Matrix => {\n    return mTranspose(m3);\n};\n\n// ----------------- RESET ----------------------\n\nexport const mReset = (m: Matrix, defaultValue = 0): Matrix => {\n\n    if(m.length <= 0) return [];\n\n    const res: Matrix = [];\n\n    for(let i=0; i<m.length; i++){\n        const size = m[i].length;\n\n        const vector: Vector = [];\n        for(let j=0; j<size; j++){\n            vector.push(defaultValue);\n        }\n\n        res.push(vector);\n    }\n\n    return res;\n};\n\nexport const m2Reset = (m2: Matrix2, defaultValue = 0): Matrix2 => {\n    return mReset(m2, defaultValue) as Matrix2;\n};\n\nexport const m3Reset = (m3: Matrix3, defaultValue = 0): Matrix3 => {\n    return mReset(m3, defaultValue) as Matrix3;\n};\n\n// --------------- MATRIX INIT HELPERS -----------------\n\nexport const m2x2 = (defaultValue = 0): Matrix2 => {\n    return [\n        [defaultValue, defaultValue],\n        [defaultValue, defaultValue],\n    ];\n};\n\nexport const m3x3 = (defaultValue = 0): Matrix3 => {\n    return [\n        [defaultValue, defaultValue, defaultValue],\n        [defaultValue, defaultValue, defaultValue],\n        [defaultValue, defaultValue, defaultValue],\n    ];\n};\n\nexport const m4x4 = (defaultValue = 0): Matrix4 => {\n    return [\n        [defaultValue, defaultValue, defaultValue, defaultValue],\n        [defaultValue, defaultValue, defaultValue, defaultValue],\n        [defaultValue, defaultValue, defaultValue, defaultValue],\n        [defaultValue, defaultValue, defaultValue, defaultValue],\n    ];\n};\n\nexport const mNxM = (N: number, M: number, defaultValue = 0): Matrix => {\n    if(N <= 0 || M <= 0){\n        throw new Error('M and N must be positive numbers.');\n    }\n\n    const matrix: Matrix = [];\n\n    for(let i=0; i<N; i++){\n        matrix.push(vN(M, defaultValue));\n    }\n\n    return matrix;\n};\n\nexport const identity2 = (): Matrix2 => {\n    return [\n        [1, 0],\n        [0, 1],\n    ];\n};\n\nexport const identity3 = (): Matrix3 => {\n    return [\n        [1, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1],\n    ];\n};\n\nexport const identity4 = (): Matrix4 => {\n    return [\n        [1, 0, 0, 0],\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\n/**\n * Identity Matrix (I).\n * M x I = I x M = M for any matrix M.\n * Identity Matrix is a special case of scale matrix.\n */\nexport const identityN = (N: number): Matrix => {\n    if(N < 0){\n        throw new Error('N must be a non-negative number.');\n    }\n\n    if(N === 0) return [];\n\n    const matrix: Matrix = [];\n\n    for(let i=0; i<N; i++){\n        const vector: Vector = [];\n        for(let j=0; j<N; j++){\n            vector.push(i === j ? 1 : 0);\n        }\n        matrix.push(vector);\n    }\n\n    return matrix;\n};\n\n// -------------- MATRIX MANIPULATION HELPERS ------------\n\nexport const mDeepCopy = (m: Matrix): Matrix => {\n    const matrix: Matrix = [];\n\n    for(let i=0; i<m.length; i++){\n        const v = m[i];\n        const vector: Vector = [];\n        for(let j=0; j<v.length; j++){\n            vector.push(v[j]);\n        }\n        matrix.push(vector);\n    }\n\n    return matrix;\n};\n\nexport const m2DeepCopy = (m2: Matrix2): Matrix2 => {\n    return mDeepCopy(m2) as Matrix2;\n};\n\nexport const m3DeepCopy = (m3: Matrix3): Matrix3 => {\n    return mDeepCopy(m3) as Matrix3;\n};\n\n// -------------- APPEND / PREPEND ROW OR COLUMN ---------------\n\nexport const mAppendCol = (m: Matrix, col: Vector): Matrix  => {\n    if(m.length <= 0) return [];\n\n    const copy = mDeepCopy(m);\n    for(let i=0; i<copy.length; i++){\n        copy[i].push(col[i]);\n    }\n\n    return copy;\n};\n\nexport const mPrependCol = (m: Matrix, col: Vector): Matrix  => {\n    if(m.length <= 0) return [];\n\n    const copy = mDeepCopy(m);\n    for(let i=0; i<copy.length; i++){\n        copy[i].unshift(col[i]);\n    }\n\n    return copy;\n};\n\nexport const mAppendRow = (m: Matrix, row: Vector) : Matrix => {\n    const copy = mDeepCopy(m);\n    copy.push(row);\n    return copy;\n};\n\nexport const m2AppendRow = (m2: Matrix2, row: Vector2) : Matrix2 => {\n    const copy = m2DeepCopy(m2);\n    copy.push(row);\n    return copy;\n};\n\nexport const m3AppendRow = (m3: Matrix3, row: Vector3) : Matrix3 => {\n    const copy = m3DeepCopy(m3);\n    copy.push(row);\n    return copy;\n};\n\nexport const mPrependRow = (m: Matrix, row: Vector) : Matrix => {\n    const copy = mDeepCopy(m);\n    copy.unshift(row);\n    return copy;\n};\n\nexport const m2PrependRow = (m2: Matrix2, row: Vector2) : Matrix2 => {\n    const copy = m2DeepCopy(m2);\n    copy.unshift(row);\n    return copy;\n};\n\nexport const m3PrependRow = (m3: Matrix3, row: Vector3) : Matrix3 => {\n    const copy = m3DeepCopy(m3);\n    copy.unshift(row);\n    return copy;\n};\n\n// ------------ DELETE ROW OR COLUMN ----------------------------\n\nexport const mDelLastRow = (m: Matrix): Matrix => {\n    if(m.length <= 0) return [];\n\n    const copy = mDeepCopy(m);\n    copy.pop();\n    return copy;\n};\n\nexport const mDelFirstRow = (m: Matrix): Matrix => {\n    if(m.length <= 0) return [];\n\n    const copy = mDeepCopy(m);\n    copy.shift();\n    return copy;\n};\n\nexport const mDelLastColumn = (m: Matrix): Matrix => {\n    if(m.length <= 0) return [];\n\n    const copy = mDeepCopy(m);\n    for(let i=0; i<copy.length; i++){\n        copy[i].pop();\n    }\n\n    return copy;\n};\n\nexport const mDelFirstColumn = (m: Matrix): Matrix => {\n    if(m.length <= 0) return [];\n\n    const copy = mDeepCopy(m);\n    for(let i=0; i<copy.length; i++){\n        copy[i].shift();\n    }\n\n    return copy;\n};\n\n// ----------- GET COLUMN ---------------------------\n\nexport const mGetFirstColumn = (m: Matrix) : Vector => {\n    if(m.length <= 0) return [];\n\n    const vector: Vector = [];\n    for(let i=0; i<m.length; i++){\n        vector.push(m[i][0]);\n    }\n    return vector;\n};\n\nexport const mGetLastColumn = (m: Matrix) : Vector => {\n    if(m.length <= 0) return [];\n\n    const size = m[0].length;\n\n    const vector: Vector = [];\n    for(let i=0; i<m.length; i++){\n        vector.push(m[i][size - 1]);\n    }\n    return vector;\n};\n\nexport const mGetColumn = (m: Matrix, colIndex: number) : Vector => {\n    if(m.length <= 0) return [];\n\n    const vector: Vector = [];\n    for(let i=0; i<m.length; i++){\n        vector.push(m[i][colIndex]);\n    }\n    return vector;\n};\n\n// --------------- MULTIPLICATION ------------------------\n\n/**\n * Matrix Multiplication.\n * - Matrix multiplication is not commutative: M1 x M2 !== M2 x M1\n * - Matrix multiplication is associative: A x (B x C) = (A x B) x C.\n * - A x (B + C) = A x B + A x C\n */\nexport const mMul = (matrix1: Matrix, matrix2: Matrix, decimalPlaces = Infinity): Matrix => {\n\n    const matrix: Matrix = [];\n    for(let i=0; i<matrix1.length; i++){\n        matrix.push([]);\n    }\n\n    const transposed = mTranspose(matrix2);\n\n    if(matrix.length !== transposed.length){\n        throw new Error('The number of columns in the 1st matrix must be equal to the number of rows in the 2nd matrix.');\n    }\n\n    for(let i=0; i<matrix1.length; i++){\n        const vector1 = matrix1[i];\n\n        for(let j=0; j<transposed.length; j++){\n            const vector2 = transposed[j];\n            const product = vDotProduct(vector1, vector2, decimalPlaces);\n            matrix[i].push(product);\n        }\n    }\n\n    return matrix;\n};\n\nexport const mMulVector = (matrix: Matrix, vector: Vector, decimalPlaces = Infinity): Vector => {\n\n    if(matrix.length < 0) return [];\n\n    if(matrix[0].length !== vector.length){\n        throw new Error('The number of columns in the matrix must be equal to the length of the vector.');\n    }\n\n    const res: Vector = [];\n\n    for(let i=0; i<matrix.length; i++){\n        res[i] = vDotProduct(matrix[i], vector, decimalPlaces);\n    }\n\n    return res;\n};\n\n// --------------- EQUALITY -----------------------------\n\nexport const mEqual = (matrix1: Matrix, matrix2: Matrix): boolean => {\n    if(matrix1.length !== matrix2.length) return false;\n\n    for(let i=0; i<matrix1.length; i++){\n        if(!vEqual(matrix1[i], matrix2[i])) return false;\n    }\n\n    return true;\n};\n\n// ------------------- Determinant ---------------\n\n/**\n * Returns a matrix without provided row / col.\n * If we received a matrix M (mxm) ===> returns matrix N (m-1 x m-1)\n * The matrix must be square.\n */\nconst mMinorHelper = (m: Matrix, row: number, col: number) => {\n    const size = m.length;\n\n    if(size <= 0){\n        throw new Error('The matrix should not be empty.');\n    }\n\n    if(size !== m[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    const matrix: Matrix = [];\n\n    for(let i=0; i<size; i++){\n        if(i === row) continue;\n\n        const vector: Vector = [];\n\n        for(let j=0; j<size; j++){\n            if(j === col) continue;\n            vector.push(m[i][j]);\n        }\n\n        matrix.push(vector);\n    }\n\n    return matrix;\n};\n\n/**\n * Calculate matrix minor.\n */\nexport const mMinor = (m: Matrix, row: number, col: number) => {\n    const size = m.length;\n\n    if(size <= 0){\n        throw new Error('The matrix should not be empty.');\n    }\n\n    if(size !== m[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    // prepare the matrix without provided row and column\n    const matrix = mMinorHelper(m, row, col);\n\n    // calculate the matrix determinant\n    return mDeterminant(matrix);\n};\n\n/**\n * Calculate determinant for NxN matrix.\n * Matrix should be square.\n */\nexport const mDeterminant = (matrix: Matrix): number => {\n    const size = matrix.length;\n    if(size === 0) return 1;\n\n    if(size !== matrix[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    if(size === 1) return matrix[0][0];\n    if(size === 2) return m2Determinant(matrix as Matrix2);\n\n    let d = 0;\n\n    for(let i=0; i<size; i++){\n        const minor = mMinor(matrix, 0, i);\n\n        let param = matrix[0][i];\n        if(i % 2 !== 0){\n            param = -param;\n        }\n\n        d += minor * param;\n    }\n\n    return d;\n};\n\n/**\n * Calculate determinant for 2x2 matrix.\n * Matrix should be square.\n */\nexport const m2Determinant = (m2: Matrix2): number => {\n    if(m2.length !== m2[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    return m2[0][0] * m2[1][1] - m2[1][0] * m2[0][1];\n};\n\n/**\n * Calculate determinant for 3x3 matrix.\n * Matrix should be square.\n */\nexport const m3Determinant = (m3: Matrix3): number => {\n    if(m3.length !== m3[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    return mDeterminant(m3);\n};\n\n// ------------------ INVERSE -----------------------\n\nexport const m2Adjugate = (m2: Matrix2): Matrix2|null => {\n    if(m2.length !== m2[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    return [\n      [m2[1][1], -m2[0][1]],\n      [-m2[1][0], m2[0][0]],\n    ];\n};\n\nexport const m3Adjugate = (m3: Matrix3) : Matrix3|null => {\n    return mAdjugate(m3) as (Matrix3|null);\n};\n\n/**\n * Adjugate is a transpose of a cofactor matrix\n */\nexport const mAdjugate = (m: Matrix): Matrix|null => {\n\n    const size = m.length;\n    if(size <= 0) return null;\n\n    if(size !== m[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    if(size === 1) return m;\n\n    if(size === 2) return m2Adjugate(m as Matrix2);\n\n    // build a cofactor matrix ----------------\n    const cofactors: Matrix = [];\n\n    for(let i=0; i<size; i++){\n        const vector: Vector = [];\n        for(let j=0; j<size; j++){\n            const minor = mMinor(m, i, j);\n            const sign = Math.pow(-1, i + j)\n            vector.push(sign * minor);\n        }\n        cofactors.push(vector);\n    }\n\n    // find an Adjugate - a transpose of a cofactor matrix\n    return mTranspose(cofactors);\n};\n\n/**\n * Singular Matrix = a square matrix that does not have a matrix inverse.\n * A matrix is singular iff its determinant is 0.\n */\nexport const isSingularMatrix = (m: Matrix) => {\n    if(m.length > 0 && m.length !== m[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    const d = mDeterminant(m);\n    return d === 0;\n};\n\n/**\n * Square matrix A (nxn) is invertible is there is another square matrix B (nxn) so AxB = BxA = I\n * For A (2x2) matrix, the inverse is:\n * (1 / (determinant(A))) * adj(A)\n */\nexport const m2Inverse = (m2: Matrix2, decimalPlaces = Infinity): (Matrix2 | null) => {\n    if(m2.length > 0 && m2.length !== m2[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    const d = m2Determinant(m2);\n    if(d === 0) return null;\n\n    const adj = m2Adjugate(m2);\n    if(adj === null) return null;\n\n    return m2DivideScalar(adj, d, decimalPlaces);\n};\n\nexport const m3Inverse = (m3: Matrix3, decimalPlaces = Infinity): (Matrix3 | null) => {\n    return mInverse(m3, decimalPlaces) as (Matrix3|null);\n};\n\nexport const mInverse = (m: Matrix, decimalPlaces = Infinity): (Matrix | null) => {\n    const size = m.length;\n\n    if(size > 0 && size !== m[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    // find a determinant ----------------------\n    const d = mDeterminant(m);\n\n    // find an Adjugate - a transpose of a cofactor matrix\n    const adj = mAdjugate(m);\n    if(adj === null) return null;\n\n    return mDivideScalar(adj, d, decimalPlaces);\n};", "import { Matrix2, Matrix3, Matrix4, Matrix, Vector2, Vector3, Vector4 } from '../../types';\nimport { v2Normalize, v3MulScalar, v3Normalize } from './vector';\nimport { mMulVector, mMul } from './matrix';\nimport { setDecimalPlaces } from '../format';\n\n/*\nAny 2D affine transformation can be decomposed\ninto a rotation, followed by a scaling, followed by a\nshearing, and followed by a translation.\n---------------------------------------------------------\nAffine matrix = translation x shearing x scaling x rotation\n */\n\n// ----------------- CSS -------------------------------------\n\n/**\n * Matrix 2D in non-homogeneous coordinates to CSS matrix() function\n * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix\n */\nexport const m2ToCSS = (m: Matrix2) : string => {\n    const a = m[0][0];\n    const b = m[1][0];\n    const c = m[0][1];\n    const d = m[1][1];\n\n    return `matrix(${ a }, ${ b }, ${ c }, ${ d }, 0, 0)`;\n};\n\n/**\n * Matrix 2D in homogeneous coordinates to CSS matrix() function\n * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix\n */\nexport const m2hToCSS = (m: Matrix3) : string => {\n    const a = m[0][0];\n    const b = m[1][0];\n    const c = m[0][1];\n    const d = m[1][1];\n    const tx = m[0][2];\n    const ty = m[1][2];\n\n    return `matrix(${ a }, ${ b }, ${ c }, ${ d }, ${ tx }, ${ ty })`;\n};\n\n/**\n * Matrix 2D in homogeneous coordinates to CSS matrix3d() function\n * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix3d\n */\nexport const m2hToCSS3d = (m: Matrix3) : string => {\n    const a = m[0][0];\n    const b = m[1][0];\n    const c = m[0][1];\n    const d = m[1][1];\n    const tx = m[0][2];\n    const ty = m[1][2];\n\n    return `matrix3d(${ a }, ${ b }, 0, 0, ${ c }, ${ d }, 0, 0, 0, 0, 1, 0, ${ tx }, ${ ty }, 0, 1)`;\n};\n\n/**\n * Matrix 3D in homogeneous coordinates to CSS matrix3d() function\n * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix3d\n */\nexport const m3hToCSS3d = (m: Matrix4) : string => {\n\n    return `matrix3d(\n        ${ m[0][0] }, ${ m[0][1] }, ${ m[0][2] }, ${ m[0][3] },\n        ${ m[1][0] }, ${ m[1][1] }, ${ m[1][2] }, ${ m[1][3] },\n        ${ m[2][0] }, ${ m[2][1] }, ${ m[2][2] }, ${ m[2][3] },\n        ${ m[3][0] }, ${ m[3][1] }, ${ m[3][2] }, ${ m[3][3] }\n    )`;\n};\n\n// ---------------- TRANSLATION MATRICES ----------------------\n\nexport const m2Translation = (position: Vector2, decimalPlaces = Infinity): Matrix2 => {\n\n    return [\n        [1, 0],\n        [0, 1],\n        [setDecimalPlaces(position[0], decimalPlaces), setDecimalPlaces(position[1], decimalPlaces)],\n    ];\n};\n\nexport const m3Translation = (position: Vector3, decimalPlaces = Infinity): Matrix3 => {\n\n    return [\n        [1, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1],\n        [\n            setDecimalPlaces(position[0], decimalPlaces),\n            setDecimalPlaces(position[1], decimalPlaces),\n            setDecimalPlaces(position[2], decimalPlaces)\n        ],\n    ];\n};\n\n/**\n * 2D Translation matrix in homogeneous coordinates.\n */\nexport const m2TranslationH = (position: Vector3, decimalPlaces = Infinity): Matrix3 => {\n\n    return [\n        [1, 0, setDecimalPlaces(position[0], decimalPlaces)],\n        [0, 1, setDecimalPlaces(position[1], decimalPlaces)],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * 3D Translation matrix in homogeneous coordinates.\n */\nexport const m3TranslationH = (position: Vector4, decimalPlaces = Infinity): Matrix4 => {\n\n    return [\n        [1, 0, 0, setDecimalPlaces(position[0], decimalPlaces)],\n        [0, 1, 0, setDecimalPlaces(position[1], decimalPlaces)],\n        [0, 0, 1, setDecimalPlaces(position[2], decimalPlaces)],\n        [0, 0, 0, 1],\n    ];\n};\n\n// ---------------- ROTATION MATRICES -------------------------\n\n/**\n * Rotation of an angle about the origin.\n */\nexport const m2Rotation = (angleRad: number, isClockwise = true, decimalPlaces = Infinity): Matrix2 => {\n    const cos = setDecimalPlaces(Math.cos(angleRad), decimalPlaces);\n    const sin = setDecimalPlaces(Math.sin(angleRad), decimalPlaces);\n\n    return isClockwise ? [\n        [cos, -sin],\n        [sin, cos],\n    ] :\n    [\n        [cos, sin],\n        [-sin, cos],\n    ];\n};\n\n/**\n * Rotation of an angle about the origin in homogeneous coordinates (clockwise).\n */\nexport const m2RotationH = (angleRad: number, isClockwise = true, decimalPlaces = Infinity): Matrix3 => {\n    const cos = setDecimalPlaces(Math.cos(angleRad), decimalPlaces);\n    const sin = setDecimalPlaces(Math.sin(angleRad), decimalPlaces);\n\n    return isClockwise ? [\n        [cos, -sin, 0],\n        [sin, cos, 0],\n        [0, 0, 1],\n    ]:\n    [\n        [cos, sin, 0],\n        [-sin, cos, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Rotation of an angle \"angleRad\" around the given point (transformOrigin) in homogeneous coordinates (clockwise).\n * result_vector = TranslationMatrix(x, y) * RotationMatrix() * TranslationMatrix(-x, -y) * position_vector\n */\nexport const m2RotationAroundPointH = (\n    angleRad: number,\n    transformOrigin: Vector3,\n    isClockwise = true,\n    decimalPlaces = Infinity): Matrix3 => {\n\n    const translation = m2TranslationH(transformOrigin, decimalPlaces);\n    const rotation = m2RotationH(angleRad, isClockwise, decimalPlaces);\n    const translationBack = m2TranslationH(v3MulScalar(transformOrigin, -1), decimalPlaces);\n    const temp1 = mMul(translation, rotation);\n    return mMul(temp1, translationBack) as Matrix3;\n};\n\nexport const m2RotateAroundPointH = (\n    angleRad: number,\n    transformOrigin: Vector3,\n    position: Vector3,\n    isClockwise = true,\n    decimalPlaces = Infinity): Vector3 => {\n\n    const mat3h = m2RotationAroundPointH(angleRad, transformOrigin, isClockwise, decimalPlaces);\n    return mMulVector(mat3h, position) as Vector3;\n};\n\n/**\n * Rotate vector around the origin by angle \"angleRad\" (clockwise).\n */\nexport const v2Rotate = (angleRad: number, vector: Vector2, isClockwise = true, decimalPlaces = Infinity): Vector2 => {\n    const unitVector = v2Normalize(vector);\n    return mMulVector(m2Rotation(angleRad, isClockwise, decimalPlaces), unitVector) as Vector2;\n};\n\n/**\n * Rotate vector around the origin by angle \"angleRad\" (clockwise).\n */\nexport const v2RotateH = (angleRad: number, vector: Vector3, isClockwise = true, decimalPlaces = Infinity): Vector3 => {\n    const unitVector = v3Normalize(vector);\n    return mMulVector(m2RotationH(angleRad, isClockwise, decimalPlaces), unitVector) as Vector3;\n};\n\n/**\n * Rotation around the X axis (clockwise).\n */\nexport const m3RotationX = (angleRad: number, isClockwise = true, decimalPlaces = Infinity): Matrix3 => {\n    const cos = setDecimalPlaces(Math.cos(angleRad), decimalPlaces);\n    const sin = setDecimalPlaces(Math.sin(angleRad), decimalPlaces);\n\n    return isClockwise ? [\n        [1, 0, 0],\n        [0, cos, -sin],\n        [0, sin, cos],\n    ] :\n    [\n        [1, 0, 0],\n        [0, cos, sin],\n        [0, -sin, cos],\n    ];\n};\n\n/**\n * Rotation around the X axis (clockwise) - in homogeneous coordinates\n */\nexport const m3RotationXH = (angleRad: number, isClockwise = true, decimalPlaces = Infinity): Matrix4 => {\n    const cos = setDecimalPlaces(Math.cos(angleRad), decimalPlaces);\n    const sin = setDecimalPlaces(Math.sin(angleRad), decimalPlaces);\n\n    return isClockwise ? [\n            [1, 0, 0, 0],\n            [0, cos, -sin, 0],\n            [0, sin, cos, 0],\n            [0, 0, 0, 1],\n        ] :\n        [\n            [1, 0, 0, 0],\n            [0, cos, sin, 0],\n            [0, -sin, cos, 0],\n            [0, 0, 0, 1],\n        ];\n};\n\nexport const v3RotateX = (angleRad: number, vector: Vector3, isClockwise = true, decimalPlaces = Infinity): Vector3 => {\n    const unitVector = v3Normalize(vector);\n    return mMulVector(m3RotationX(angleRad, isClockwise, decimalPlaces), unitVector) as Vector3;\n};\n\n/**\n * Rotation around the Y axis (clockwise).\n */\nexport const m3RotationY = (angleRad: number, isClockwise = true, decimalPlaces = Infinity): Matrix3 => {\n    const cos = setDecimalPlaces(Math.cos(angleRad), decimalPlaces);\n    const sin = setDecimalPlaces(Math.sin(angleRad), decimalPlaces);\n\n    return isClockwise ? [\n        [cos, 0, sin],\n        [0, 1, 0],\n        [-sin, 0, cos],\n    ] :\n    [\n        [cos, 0, -sin],\n        [0, 1, 0],\n        [sin, 0, cos],\n    ];\n};\n\n/**\n * Rotation around the Y axis (clockwise) - in homogeneous coordinates\n */\nexport const m3RotationYH = (angleRad: number, isClockwise = true, decimalPlaces = Infinity): Matrix4 => {\n    const cos = setDecimalPlaces(Math.cos(angleRad), decimalPlaces);\n    const sin = setDecimalPlaces(Math.sin(angleRad), decimalPlaces);\n\n    return isClockwise ? [\n            [cos, 0, sin, 0],\n            [0, 1, 0, 0],\n            [-sin, 0, cos, 0],\n            [0, 0, 0, 1],\n        ] :\n        [\n            [cos, 0, -sin, 0],\n            [0, 1, 0, 0],\n            [sin, 0, cos, 0],\n            [0, 0, 0, 1],\n        ];\n};\n\nexport const v3RotateY = (angleRad: number, vector: Vector3, isClockwise = true, decimalPlaces = Infinity): Vector3 => {\n    const unitVector = v3Normalize(vector);\n    return mMulVector(m3RotationY(angleRad, isClockwise, decimalPlaces), unitVector) as Vector3;\n};\n\n/**\n * Rotation around the Z axis (clockwise).\n */\nexport const m3RotationZ = (angleRad: number, isClockwise = true, decimalPlaces = Infinity): Matrix3 => {\n\n    const cos = setDecimalPlaces(Math.cos(angleRad), decimalPlaces);\n    const sin = setDecimalPlaces(Math.sin(angleRad), decimalPlaces);\n\n    return isClockwise ? [\n        [cos, -sin, 0],\n        [sin, cos, 0],\n        [0, 0, 1],\n    ] : [\n        [cos, sin, 0],\n        [-sin, cos, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Rotation around the Z axis (clockwise)- in homogeneous coordinates\n */\nexport const m3RotationZH = (angleRad: number, isClockwise = true, decimalPlaces = Infinity): Matrix4 => {\n\n    const cos = setDecimalPlaces(Math.cos(angleRad), decimalPlaces);\n    const sin = setDecimalPlaces(Math.sin(angleRad), decimalPlaces);\n\n    return isClockwise ? [\n        [cos, -sin, 0, 0],\n        [sin, cos, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n    ] : [\n        [cos, sin, 0, 0],\n        [-sin, cos, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\nexport const v3RotateZ = (angleRad: number, vector: Vector3, isClockwise = true, decimalPlaces = Infinity): Vector3 => {\n    const unitVector = v3Normalize(vector);\n    return mMulVector(m3RotationZ(angleRad, isClockwise, decimalPlaces), unitVector) as Vector3;\n};\n\n// ---------------- SCALE MATRICES -------------\n\n/**\n * Get matrix for arbitrary scaling pivot point.\n * result_vector = TranslationMatrix(x, y) * ScaleMatrix() * TranslationMatrix(-x, -y) * scale_vector\n */\nexport const m2ScaleAtPointHMatrix = (\n    scaleVector: Vector3,\n    transformOrigin: Vector3,\n    decimalPlaces = Infinity): Matrix3 => {\n\n    const translation = m2TranslationH(transformOrigin, decimalPlaces);\n    const rotation = m2ScaleH(scaleVector);\n    const translationBack = m2TranslationH(v3MulScalar(transformOrigin, -1), decimalPlaces);\n    const temp1 = mMul(translation, rotation);\n    return mMul(temp1, translationBack) as Matrix3;\n};\n\nexport const m2ScaleAtPointH = (\n    scaleVector: Vector3,\n    transformOrigin: Vector3,\n    point: Vector3,\n    decimalPlaces = Infinity): Vector3 => {\n\n    const mat3h = m2ScaleAtPointHMatrix(scaleVector, transformOrigin, decimalPlaces);\n    return mMulVector(mat3h, point) as Vector3;\n};\n\nexport const m2Scale = (scaleVector: Vector2): Matrix2 => {\n    return [\n        [scaleVector[0], 0],\n        [0, scaleVector[1]],\n    ];\n};\n\nexport const v2Scale = (scaleVector: Vector2, vector: Vector2): Vector2 => {\n    return mMulVector(m2Scale(scaleVector), vector) as Vector2;\n};\n\n/**\n * homogeneous coordinates\n */\nexport const m2ScaleH = (scaleVector: Vector3): Matrix3 => {\n    return [\n        [scaleVector[0], 0, 0],\n        [0, scaleVector[1], 0],\n        [0, 0, 1],\n    ];\n};\n\nexport const m3Scale = (scaleVector: Vector3): Matrix3 => {\n    return [\n        [scaleVector[0], 0, 0],\n        [0, scaleVector[1], 0],\n        [0, 0, scaleVector[2]],\n    ];\n};\n\nexport const m3ScaleH = (scaleVector: Vector4): Matrix4 => {\n    return [\n        [scaleVector[0], 0, 0, 0],\n        [0, scaleVector[1], 0, 0],\n        [0, 0, scaleVector[2], 0],\n        [0, 0, 0, 1]\n    ];\n};\n\nexport const v3Scale = (scaleVector: Vector3, vector: Vector3): Vector3 => {\n    return mMulVector(m3Scale(scaleVector), vector) as Vector3;\n};\n\n/**\n * Stretch, parallel to the x-axis.\n */\nexport const m2ScaleX = (scale: number): Matrix2 => {\n    return [\n        [scale, 0],\n        [0, 1],\n    ];\n};\n\n/**\n * Stretch, parallel to the x-axis - homogeneous coordinates\n */\nexport const m2ScaleXH = (scale: number): Matrix3 => {\n    return [\n        [scale, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Stretch in x-direction\n */\nexport const m3ScaleX = (scale: number): Matrix3 => {\n    return [\n        [scale, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Stretch in x-direction\n */\nexport const m3ScaleXH = (scale: number): Matrix4 => {\n    return [\n        [scale, 0, 0, 0],\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\n/**\n * Stretch in y-direction\n */\nexport const m3ScaleY = (scale: number): Matrix3 => {\n    return [\n        [1, 0, 0],\n        [0, scale, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Stretch in y-direction\n */\nexport const m3ScaleYH = (scale: number): Matrix => {\n    return [\n        [1, 0, 0, 0],\n        [0, scale, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\n/**\n * Stretch in z-direction\n */\nexport const m3ScaleZ = (scale: number): Matrix3 => {\n    return [\n        [1, 0, 0],\n        [0, 1, 0],\n        [0, 0, scale],\n    ];\n};\n\n/**\n * Stretch in z-direction\n */\nexport const m3ScaleZH = (scale: number): Matrix4 => {\n    return [\n        [1, 0, 0, 0],\n        [0, 1, 0, 0],\n        [0, 0, scale, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\n/**\n * Stretch, parallel to the y-axis.\n */\nexport const m2ScaleY = (scale: number): Matrix2 => {\n    return [\n        [1, 0],\n        [0, scale],\n    ];\n};\n\n/**\n * Stretch, parallel to the y-axis - homogeneous coordinates\n */\nexport const m2ScaleYH = (scale: number): Matrix3 => {\n    return [\n        [1, 0, 0],\n        [0, scale, 0],\n        [0, 0, 1],\n    ];\n};\n\n// ---------------- REFLECTION MATRICES -------------------------\n\n/**\n * Reflection about the origin.\n */\nexport const m2ReflectionOrigin = (): Matrix2 => {\n\n    return [\n        [-1, 0],\n        [0, -1],\n    ];\n};\n\n/**\n * Reflection about the origin.\n */\nexport const m2ReflectionOriginH = (): Matrix3 => {\n\n    return [\n        [-1, 0, 0],\n        [0, -1, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Reflection about the origin in non-homogeneous coordinates\n */\nexport const m3ReflectionOrigin = (): Matrix3 => {\n\n    return [\n        [-1, 0, 0],\n        [0, -1, 0],\n        [0, 0, -1],\n    ];\n};\n\n/**\n * Reflection about the origin in homogeneous coordinates\n */\nexport const m3ReflectionOriginH = (): Matrix4 => {\n\n    return [\n        [-1, 0, 0, 0],\n        [0, -1, 0, 0],\n        [0, 0, -1, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\n/**\n * Reflection about y=-x\n */\nexport const m2ReflectionYmX = (): Matrix2 => {\n\n    return [\n        [0, -1],\n        [-1, 0],\n    ];\n};\n\n/**\n * Reflection in the x-axis.\n */\nexport const m2ReflectionX = (): Matrix2 => {\n\n    return [\n        [1, 0],\n        [0, -1],\n    ];\n};\n\n/**\n * Reflection in the x-axis.\n */\nexport const m2ReflectionXH = (): Matrix3 => {\n\n    return [\n        [1, 0, 0],\n        [0, -1, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Reflection in the y-axis.\n */\nexport const m2ReflectionY = (): Matrix2 => {\n\n    return [\n        [-1, 0],\n        [0, 1],\n    ];\n};\n\nexport const m2ReflectionYH = (): Matrix3 => {\n\n    return [\n        [-1, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Reflection relative to YZ plane in non-homogeneous coordinates\n */\nexport const m3ReflectionYZ = (): Matrix3 => {\n\n    return [\n        [-1, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Reflection relative to YZ plane in homogeneous coordinates\n */\nexport const m3ReflectionYZH = (): Matrix4 => {\n\n    return [\n        [-1, 0, 0, 0],\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\n/**\n * Reflection relative to XZ plane in non-homogeneous coordinates\n */\nexport const m3ReflectionXZ = (): Matrix3 => {\n\n    return [\n        [1, 0, 0],\n        [0, -1, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Reflection relative to XZ plane in homogeneous coordinates\n */\nexport const m3ReflectionXZH = (): Matrix4 => {\n\n    return [\n        [1, 0, 0, 0],\n        [0, -1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\n/**\n * Reflection relative to XY plane in non-homogeneous coordinates\n */\nexport const m3ReflectionXY = (): Matrix3 => {\n\n    return [\n        [1, 0, 0],\n        [0, 1, 0],\n        [0, 0, -1],\n    ];\n};\n\n/**\n * Reflection relative to XY plane in homogeneous coordinates\n */\nexport const m3ReflectionXYH = (): Matrix4 => {\n\n    return [\n        [1, 0, 0, 0],\n        [0, 1, 0, 0],\n        [0, 0, -1, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\n// ---------------- SHEARING MATRICES -------------------------\n\n\n/**\n * Shearing in y-axis, with x-axis fixed with (0,1) moving to (factor, 1)\n */\nexport const m2ShearingY = (factor: number): Matrix2 => {\n\n    return [\n        [1, factor],\n        [0, 1],\n    ];\n};\n\n/**\n * Shearing in x-axis, with y-axis fixed with (1,0) moving to (1, factor)\n */\nexport const m2ShearingX = (factor: number): Matrix2 => {\n\n    return [\n        [1, 0],\n        [factor, 1],\n    ];\n};", "import { setDecimalPlaces } from './format';\n\n/**\n * Returns a random number in the [min,max] range.\n */\nexport const getRandom = (min: number, max: number, decimalPlaces = Infinity): number => {\n    return setDecimalPlaces(Math.random() * (max - min) + min, decimalPlaces);\n};\n\n/**\n * Returns a random integer number in the [min,max] range.\n */\nexport const getRandomInt = (min: number, max: number): number => {\n    return Math.floor(Math.random() * (max - min + 1) + min);\n};\n\nexport const getRandomBoolean = () => Math.random() < 0.5;\n\n/* eslint-disable  @typescript-eslint/no-explicit-any */\nexport const getRandomItemFromArray = (array: any[]) => {\n    const randomIndex = getRandomInt(0, array.length - 1);\n    return array[randomIndex];\n};", "export const mod = (n: number, m: number) => {\n    return ((n % m) + m) % m;\n};\n\n/**\n * Convert range [a, b] to [c, d].\n * f(x) = (d - c) * (x - a) / (b - a) + c\n */\nexport const convertRange = (x: number, a: number, b: number, c: number, d: number) => {\n    return (d - c) * (x - a) / (b - a) + c;\n};\n\n/**\n * Check if 2 ranges [a,b] and [c,d] overlap.\n */\nexport const doRangesOverlap = (a: number, b: number, c: number, d: number) => {\n    return Math.max(a, c) <= Math.min(b, d) ;\n};\n\n// eslint-disable-next-line\nexport const isNumber = (value: any) => {\n    return !isNaN(parseFloat(value)) && isFinite(value);\n};\n", "export const stringToNumber = (value: string|undefined|null|number, defaultNumber: number) => {\n    if(value === undefined || value === null) return defaultNumber;\n    const res = Number(value) ?? defaultNumber;\n    return isNaN(res) ? defaultNumber : res;\n};", "import { setDecimalPlaces } from './format';\nimport { Vector2, Vector3 } from '../types';\n\n/**\n * u(x) and v(x) are functions ---------->\n *\n * dx(u + v) = dx(u) + dx(v)\n * dx(u - v) = dx(u) - dx(v)\n * dx(u * v) = dx(u) * v + u * dx(v)\n * dx(u / v) = (dx(u) * v - u * dx(v)) / (v ^ 2), when v(x) != 0\n */\n\n// ------------------ Derivatives of Polynomial ---------------------------\n\n/**\n * y = 3x+2\n * dxPolynomial(10, [[3, 1], [2, 0]])\n */\nexport const dxPolynomial = (x: number, polynomial: number[][], decimalPlaces = Infinity) => {\n    let res = 0;\n\n    for(const part of polynomial){\n        if(part.length !== 2) return NaN;\n\n        const coeff = part[0];\n        const power = part[1];\n        res += coeff * power * Math.pow(x, power - 1);\n    }\n\n    return setDecimalPlaces(res, decimalPlaces);\n}\n\n// ---------------------- Bezier Curves ---------------------------\n\n/**\n * Derivative of Bezier Curve is another Bezier Curve.\n * t must min in range [0, 1]\n */\nexport const dxV2QuadraticBezierCurve = (\n    t: number,\n    startControlPoint: Vector2,\n    centerControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2 => {\n\n    // The derivative: P1 * (2t-2) + (2*P3-4*P2) * t + 2 * P2\n\n    const temp1 = -2 * (1 - t); // Math.pow(1 - t, 2)\n    const temp2 = 2 - 4 * t; // (1 - t) * 2 * t\n    const temp3 = 2 * t; //t * t;\n\n    return [\n        setDecimalPlaces(temp1 * startControlPoint[0] + temp2 * centerControlPoint[0] + temp3 * endControlPoint[0], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[1] + temp2 * centerControlPoint[1] + temp3 * endControlPoint[1], decimalPlaces),\n    ];\n};\n\nexport const dxV3QuadraticBezierCurve = (\n    t: number,\n    startControlPoint: Vector3,\n    centerControlPoint: Vector3,\n    endControlPoint: Vector3,\n    decimalPlaces = Infinity\n) : Vector3 => {\n\n    const temp1 = -2 * (1 - t); // Math.pow(1 - t, 2)\n    const temp2 = 2 - 4 * t; // (1 - t) * 2 * t\n    const temp3 = 2 * t; //t * t;\n\n    return [\n        setDecimalPlaces(temp1 * startControlPoint[0] + temp2 * centerControlPoint[0] + temp3 * endControlPoint[0], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[1] + temp2 * centerControlPoint[1] + temp3 * endControlPoint[1], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[2] + temp2 * centerControlPoint[2] + temp3 * endControlPoint[2], decimalPlaces),\n    ];\n};\n\nexport const dxV2CubicBezierCurve = (\n    t: number,\n    startControlPoint: Vector2,\n    center1ControlPoint: Vector2,\n    center2ControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2 => {\n\n    const temp1 = -3 * Math.pow(1 - t, 2); //Math.pow(1 - t, 3);\n    const temp2 = 3 * (t - 1) * (3 * t - 1); //Math.pow(1 - t, 2) * 3 * t;\n    const temp3 = 6 * t - 9 * t * t; // (1 - t) * 3 * t * t;\n    const temp4 = 3 * t * t; //t * t * t;\n\n    return [\n        setDecimalPlaces(temp1 * startControlPoint[0] + temp2 * center1ControlPoint[0] + temp3 * center2ControlPoint[0] + temp4 * endControlPoint[0], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[1] + temp2 * center1ControlPoint[1] + temp3 * center2ControlPoint[1] + temp4 * endControlPoint[1], decimalPlaces),\n    ];\n};\n\nexport const dxV3CubicBezierCurve = (\n    t: number,\n    startControlPoint: Vector3,\n    center1ControlPoint: Vector3,\n    center2ControlPoint: Vector3,\n    endControlPoint: Vector3,\n    decimalPlaces = Infinity\n) : Vector3 => {\n\n    const temp1 = -3 * Math.pow(1 - t, 2); //Math.pow(1 - t, 3);\n    const temp2 = 3 * (t - 1) * (3 * t - 1); //Math.pow(1 - t, 2) * 3 * t;\n    const temp3 = 6 * t - 9 * t * t; // (1 - t) * 3 * t * t;\n    const temp4 = 3 * t * t; //t * t * t;\n\n    return [\n        setDecimalPlaces(temp1 * startControlPoint[0] + temp2 * center1ControlPoint[0] + temp3 * center2ControlPoint[0] + temp4 * endControlPoint[0], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[1] + temp2 * center1ControlPoint[1] + temp3 * center2ControlPoint[1] + temp4 * endControlPoint[1], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[2] + temp2 * center1ControlPoint[2] + temp3 * center2ControlPoint[2] + temp4 * endControlPoint[2], decimalPlaces),\n    ];\n};\n\n\n// ----------------- Derivatives of trigonometry functions ---------------------------\n\nexport const dxSin = (x: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(Math.cos(x), decimalPlaces);\n};\n\nexport const dxCos = (x: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(-Math.sin(x), decimalPlaces);\n};\n\nexport const dxTan = (x: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(1 / (Math.cos(x) ** 2), decimalPlaces);\n};\n\n/**\n * x != Math.PI * n, where n is an integer\n */\nexport const dxCot = (x: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(-1 / (Math.sin(x) ** 2), decimalPlaces);\n};\n\n/**\n * -1 < x < 1\n */\nexport const dxArcSin = (x: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(1 / (Math.sqrt(1 - x ** 2)), decimalPlaces);\n};\n\n/**\n * -1 < x < 1\n */\nexport const dxArcCos = (x: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(-1 / (Math.sqrt(1 - x ** 2)), decimalPlaces);\n};\n\nexport const dxArcTan = (x: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(1 / (1 + x ** 2), decimalPlaces);\n};\n\nexport const dxArcCot = (x: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(-1 / (1 + x ** 2), decimalPlaces);\n};\n", "import { Matrix, Matrix2, Matrix3, Vector, Vector2, Vector3 } from '../../types';\nimport { m2Inverse, m3Inverse, mInverse, mMulVector, mDelLastColumn, mGetLastColumn } from '../linear-algebra/matrix';\nimport { setDecimalPlaces } from '../format';\n\n/**\n * Linear equation\n * ax + b = c\n * x = (c - b) / a; a != 0\n */\nexport const linearEquation = (equation: Vector3, decimalPlaces = Infinity) : number => {\n    const a = equation[0];\n    const b = equation[1];\n    const c = equation[2];\n\n    const diff = c - b;\n\n    if(a === 0 && diff === 0) return Infinity; // any number is a solution\n    if(a === 0) return NaN; // no solution\n\n    return setDecimalPlaces(diff / a, decimalPlaces);\n};\n\n/**\n * System of 2 linear equations.\n * [x, y] = inverse(Matrix of equation parameters) x (vector of equation results)\n * ---------------\n * 3x + 2y = 7\n * -6x + 6y = 6\n */\nexport const linearEquationSystem2 = (equation1: Vector3, equation2: Vector3, decimalPlaces = Infinity) : Vector2 | null => {\n    const equationParams: Matrix2 = [\n        [equation1[0], equation1[1]],\n        [equation2[0], equation2[1]],\n    ];\n\n    const inversed = m2Inverse(equationParams);\n    if(inversed === null) return null; // no results\n\n    const equationResults: Vector2 = [\n        equation1[2],\n        equation2[2]\n    ];\n\n    return mMulVector(inversed, equationResults, decimalPlaces) as Vector2;\n};\n\n/**\n * System of 3 linear equations.\n * ---------------------------------------\n * 3x + 2y + 5z = 7\n * -6x + 6y + 6z = 6\n * 2x + 7y - z = 4\n */\nexport const linearEquationSystem3 = (\n    equation1: Vector,\n    equation2: Vector,\n    equation3: Vector,\n    decimalPlaces = Infinity) : Vector3 | null => {\n    const equationParams: Matrix3 = [\n        [equation1[0], equation1[1], equation1[2]],\n        [equation2[0], equation2[1], equation2[2]],\n        [equation3[0], equation3[1], equation3[2]],\n    ];\n\n    const inversed = m3Inverse(equationParams);\n    if(inversed === null) return null; // no results\n\n    const equationResults: Vector3 = [\n        equation1[3],\n        equation2[3],\n        equation3[3]\n    ];\n\n    return mMulVector(inversed, equationResults, decimalPlaces) as Vector3;\n};\n\n/**\n * System of N linear equations.\n */\nexport const linearEquationSystemN = (equations: Matrix, decimalPlaces = Infinity) : Vector | null => {\n    if(equations.length <= 0) return null;\n\n    const equationParams = mDelLastColumn(equations);\n\n    const inversed = mInverse(equationParams);\n    if(inversed === null) return null; // no results\n\n    // the last column of the equations matrix\n    const equationResults = mGetLastColumn(equations);\n\n    return mMulVector(inversed, equationResults, decimalPlaces) as Vector;\n};", "import { Vector } from '../../types';\nimport { setDecimalPlaces } from '../format';\nimport { linearEquation } from './linear-equations';\nimport { isNumber } from '../other';\n\n/**\n * Quadratic Equation.\n * ax^2 + bx + c = d\n */\nexport const quadraticEquation = (equation: Vector, decimalPlaces = Infinity) : Vector => {\n    const a = equation[0];\n    const b = equation[1];\n    const c = equation[2];\n    const d = equation[3];\n\n    if(a === 0){\n        // it's a linear equation -------------------------------------------\n        const res = linearEquation([b, c, d], decimalPlaces);\n        if(isNumber(res)) return [res];\n        return [];\n    }\n\n    const diff = c - d;\n\n    const discriminant = b * b - (4 * a * diff);\n\n    if(discriminant < 0){\n        return []; // no results\n    }\n\n    if(discriminant === 0){\n        return [ setDecimalPlaces(-b / (2 * a), decimalPlaces) ]; // 1 result\n    }\n\n    // if(determinant > 0) ---> 2 results\n    const t1 = 2 * a;\n    const t2 = Math.sqrt(discriminant);\n\n    return [\n        setDecimalPlaces((-b + t2) / t1, decimalPlaces),\n        setDecimalPlaces((-b - t2) / t1, decimalPlaces),\n    ];\n};", "import { IBBox, Vector, Vector2, Vector3 } from '../../types';\nimport { setDecimalPlaces } from '../format';\nimport {\n    dxV2CubicBezierCurve,\n    dxV2QuadraticBezierCurve,\n    dxV3CubicBezierCurve,\n    dxV3QuadraticBezierCurve\n} from '../derivative';\nimport { v2Normalize, v3Normalize } from '../linear-algebra/vector';\nimport { linearEquation } from '../equations/linear-equations';\nimport { quadraticEquation } from '../equations/quadratic-equations';\nimport { isNumber } from '../other';\n\n/**\n * B\u00E9zier Curves\n * quadratic: y = P1 * (1-t)\u00B2 + P2 * 2 * (1-t)t + P3 * t\u00B2\n * t in range [0, 1]\n */\n\n// -------------------- GET POINT ON CURVE --------------------------\n\n/**\n * Get a point on a quadratic B\u00E9zier curve as a function of time.\n */\nexport const v2QuadraticBezierCurve = (\n    t: number,\n    startControlPoint: Vector2,\n    centerControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2 => {\n\n    const temp1 = Math.pow(1 - t, 2);\n    const temp2 = (1 - t) * 2 * t;\n    const temp3 = t * t;\n\n    return [\n        setDecimalPlaces(temp1 * startControlPoint[0] + temp2 * centerControlPoint[0] + temp3 * endControlPoint[0], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[1] + temp2 * centerControlPoint[1] + temp3 * endControlPoint[1], decimalPlaces),\n    ];\n};\n\nexport const v3QuadraticBezierCurve = (\n    t: number,\n    startControlPoint: Vector3,\n    centerControlPoint: Vector3,\n    endControlPoint: Vector3,\n    decimalPlaces = Infinity\n) : Vector3 => {\n\n    const temp1 = Math.pow(1 - t, 2);\n    const temp2 = (1 - t) * 2 * t;\n    const temp3 = t * t;\n\n    return [\n        setDecimalPlaces(temp1 * startControlPoint[0] + temp2 * centerControlPoint[0] + temp3 * endControlPoint[0], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[1] + temp2 * centerControlPoint[1] + temp3 * endControlPoint[1], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[2] + temp2 * centerControlPoint[2] + temp3 * endControlPoint[2], decimalPlaces),\n    ];\n};\n\n/**\n * Get a point on a cubic B\u00E9zier curve as a function of time.\n */\nexport const v2CubicBezierCurve = (\n    t: number,\n    startControlPoint: Vector2,\n    center1ControlPoint: Vector2,\n    center2ControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2 => {\n\n    const temp1 = Math.pow(1 - t, 3);\n    const temp2 = Math.pow(1 - t, 2) * 3 * t;\n    const temp3 = (1 - t) * 3 * t * t;\n    const temp4 = t * t * t;\n\n    return [\n        setDecimalPlaces(temp1 * startControlPoint[0] + temp2 * center1ControlPoint[0] + temp3 * center2ControlPoint[0] + temp4 * endControlPoint[0], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[1] + temp2 * center1ControlPoint[1] + temp3 * center2ControlPoint[1] + temp4 * endControlPoint[1], decimalPlaces),\n    ];\n};\n\nexport const v3CubicBezierCurve = (\n    t: number,\n    startControlPoint: Vector3,\n    center1ControlPoint: Vector3,\n    center2ControlPoint: Vector3,\n    endControlPoint: Vector3,\n    decimalPlaces = Infinity\n) : Vector3 => {\n\n    const temp1 = Math.pow(1 - t, 3);\n    const temp2 = Math.pow(1 - t, 2) * 3 * t;\n    const temp3 = (1 - t) * 3 * t * t;\n    const temp4 = t * t * t;\n\n    return [\n        setDecimalPlaces(temp1 * startControlPoint[0] + temp2 * center1ControlPoint[0] + temp3 * center2ControlPoint[0] + temp4 * endControlPoint[0], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[1] + temp2 * center1ControlPoint[1] + temp3 * center2ControlPoint[1] + temp4 * endControlPoint[1], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[2] + temp2 * center1ControlPoint[2] + temp3 * center2ControlPoint[2] + temp4 * endControlPoint[2], decimalPlaces),\n    ];\n};\n\n// -------------------- TANGENT --------------------------\n\n/**\n * Tangent indicates the direction of travel at specific points along the B\u00E9zier curve,\n * and is literally just the first derivative of our curve.\n */\nexport const v2QuadraticBezierCurveTangent = (\n    t: number,\n    startControlPoint: Vector2,\n    centerControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2 => {\n    const dxVector = dxV2QuadraticBezierCurve(t, startControlPoint, centerControlPoint, endControlPoint);\n    return v2Normalize(dxVector, decimalPlaces);\n};\n\nexport const v3QuadraticBezierCurveTangent = (\n    t: number,\n    startControlPoint: Vector3,\n    centerControlPoint: Vector3,\n    endControlPoint: Vector3,\n    decimalPlaces = Infinity\n) : Vector3 => {\n    const dxVector = dxV3QuadraticBezierCurve(t, startControlPoint, centerControlPoint, endControlPoint);\n    return v3Normalize(dxVector, decimalPlaces);\n};\n\nexport const v2CubicBezierCurveTangent = (\n    t: number,\n    startControlPoint: Vector2,\n    center1ControlPoint: Vector2,\n    center2ControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2 => {\n    const dxVector = dxV2CubicBezierCurve(t, startControlPoint, center1ControlPoint, center2ControlPoint, endControlPoint);\n    return v2Normalize(dxVector, decimalPlaces);\n};\n\nexport const v3CubicBezierCurveTangent = (\n    t: number,\n    startControlPoint: Vector3,\n    center1ControlPoint: Vector3,\n    center2ControlPoint: Vector3,\n    endControlPoint: Vector3,\n    decimalPlaces = Infinity\n) : Vector3 => {\n    const dxVector = dxV3CubicBezierCurve(t, startControlPoint, center1ControlPoint, center2ControlPoint, endControlPoint);\n    return v3Normalize(dxVector, decimalPlaces);\n};\n\n// -------------------- NORMAL --------------------------\n\n/**\n * Normal is a vector that runs at a right angle to the direction of the curve, and is typically of length 1.\n * To find it, we take the normalised tangent vector, and then rotate it by a 90 degrees.\n */\nexport const v2QuadraticBezierCurveNormal = (\n    t: number,\n    startControlPoint: Vector2,\n    centerControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2 => {\n\n    const tangent = v2QuadraticBezierCurveTangent(t, startControlPoint, centerControlPoint, endControlPoint, decimalPlaces);\n    return [-tangent[1], tangent[0]];\n};\n\nexport const v2CubicBezierCurveNormal = (\n    t: number,\n    startControlPoint: Vector2,\n    center1ControlPoint: Vector2,\n    center2ControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2 => {\n\n    const tangent = v2CubicBezierCurveTangent(t, startControlPoint, center1ControlPoint, center2ControlPoint, endControlPoint, decimalPlaces);\n    return [-tangent[1], tangent[0]];\n};\n\n// -------------------- EXTREMA --------------------------\n\n/**\n * Find maxima and minima by solving the equation B'(t) = 0\n * Returns result in [0, 1] range.\n */\nexport const v2QuadraticBezierCurveExtrema = (\n    startControlPoint: Vector2,\n    centerControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector => {\n\n   /*\n    (-2 * (1 - t)) * startControlPoint[0] + (2 - 4 * t) * centerControlPoint[0] + (2 * t) * endControlPoint[0]\n    2 * t * startControlPoint[0] - 4 * t * centerControlPoint[0] + 2 * t * endControlPoint[0] - 2 * startControlPoint[0] + 2 * centerControlPoint[0]\n    t * (2  * startControlPoint[0] - 4 * centerControlPoint[0] + 2 * endControlPoint[0]) + (- 2 * startControlPoint[0] + 2 * centerControlPoint[0])\n    */\n\n    const a1 = 2  * startControlPoint[0] - 4 * centerControlPoint[0] + 2 * endControlPoint[0];\n    const b1 = -2 * startControlPoint[0] + 2 * centerControlPoint[0];\n    const equation1: Vector3 = [a1, b1, 0];\n    const res1 = linearEquation(equation1, decimalPlaces);\n\n    const a2 = 2  * startControlPoint[1] - 4 * centerControlPoint[1] + 2 * endControlPoint[1];\n    const b2 = -2 * startControlPoint[1] + 2 * centerControlPoint[1];\n    const equation2: Vector3 = [a2, b2, 0];\n    const res2 = linearEquation(equation2, decimalPlaces);\n\n    const res: Vector = [];\n\n    if(isNumber(res1)){\n        res.push(res1);\n    }\n\n    if(isNumber(res2)){\n        res.push(res2);\n    }\n\n    return res;\n};\n\n/**\n * Find maxima and minima by solving the equation B'(t) = 0\n * Returns result in [0, 1] range.\n */\nexport const v2CubicBezierCurveExtrema = (\n    startControlPoint: Vector2,\n    center1ControlPoint: Vector2,\n    center2ControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2|null => {\n\n    const a1 = -3  * startControlPoint[0] + 9 * center1ControlPoint[0] - 9 * center2ControlPoint[0] + 3 * endControlPoint[0];\n    const b1 = 6  * startControlPoint[0] - 12 * center1ControlPoint[0] + 6 * center2ControlPoint[0];\n    const c1 = -3  * startControlPoint[0] + 3 * center1ControlPoint[0];\n    const equation1: Vector = [a1, b1, c1, 0];\n\n    const a2 = -3  * startControlPoint[1] + 9 * center1ControlPoint[1] - 9 * center2ControlPoint[1] + 3 * endControlPoint[1];\n    const b2 = 6  * startControlPoint[1] - 12 * center1ControlPoint[1] + 6 * center2ControlPoint[1];\n    const c2 = -3  * startControlPoint[1] + 3 * center1ControlPoint[1];\n    const equation2: Vector = [a2, b2, c2, 0];\n\n    // Any value between 0 and 1 is a root that matters for B\u00E9zier curves, anything below or above that is irrelevant (because B\u00E9zier curves are only defined over the interval [0,1]).\n    const res1 = quadraticEquation(equation1, decimalPlaces).filter(num => num >= 0 && num <= 1);\n    const res2 = quadraticEquation(equation2, decimalPlaces).filter(num => num >= 0 && num <= 1);\n\n    const res = [...res1, ...res2];\n    if(res.length === 2){\n        return [...res1, ...res2] as Vector2;\n    }\n\n    return null;\n};\n\n// -------------------- BOUNDING BOX --------------------------\n\nexport const v2QuadraticBezierBBox = (\n    startControlPoint: Vector2,\n    centerControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : IBBox => {\n\n    const extrema = v2QuadraticBezierCurveExtrema(startControlPoint, centerControlPoint, endControlPoint);\n\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n\n    for(const percent of extrema){\n        const point = v2QuadraticBezierCurve(percent, startControlPoint, centerControlPoint, endControlPoint);\n\n        const x = point[0];\n        const y = point[1];\n\n        minX = Math.min(minX, x);\n        maxX = Math.max(maxX, x);\n\n        minY = Math.min(minY, y);\n        maxY = Math.max(maxY, y);\n    }\n\n    minX = setDecimalPlaces(Math.min(minX, startControlPoint[0], endControlPoint[0]), decimalPlaces);\n    maxX = setDecimalPlaces(Math.max(maxX, startControlPoint[0], endControlPoint[0]), decimalPlaces);\n    minY = setDecimalPlaces(Math.min(minY, startControlPoint[1], endControlPoint[1]), decimalPlaces);\n    maxY = setDecimalPlaces(Math.max(maxY, startControlPoint[1], endControlPoint[1]), decimalPlaces);\n\n    return {\n        x: minX,\n        y: minY,\n        w: Math.abs(maxX - minX),\n        h: Math.abs(maxY - minY),\n        x2: maxX,\n        y2: maxY,\n    }\n};\n\nexport const v2CubicBezierBBox = (\n    startControlPoint: Vector2,\n    center1ControlPoint: Vector2,\n    center2ControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : IBBox => {\n\n    const extrema = v2CubicBezierCurveExtrema(startControlPoint, center1ControlPoint, center2ControlPoint, endControlPoint) || [];\n\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n\n    for(const percent of extrema){\n        const point = v2CubicBezierCurve(percent, startControlPoint, center1ControlPoint, center2ControlPoint, endControlPoint);\n\n        const x = point[0];\n        const y = point[1];\n\n        minX = Math.min(minX, x ?? Infinity);\n        maxX = Math.max(maxX, x ?? -Infinity);\n\n        minY = Math.min(minY, y ?? Infinity);\n        maxY = Math.max(maxY, y ?? -Infinity);\n    }\n\n    minX = setDecimalPlaces(Math.min(minX, startControlPoint[0], endControlPoint[0]), decimalPlaces);\n    maxX = setDecimalPlaces(Math.max(maxX, startControlPoint[0], endControlPoint[0]), decimalPlaces);\n    minY = setDecimalPlaces(Math.min(minY, startControlPoint[1], endControlPoint[1]), decimalPlaces);\n    maxY = setDecimalPlaces(Math.max(maxY, startControlPoint[1], endControlPoint[1]), decimalPlaces);\n\n    return {\n        x: minX,\n        y: minY,\n        w: Math.abs(maxX - minX),\n        h: Math.abs(maxY - minY),\n        x2: maxX,\n        y2: maxY,\n    }\n};\n\n\n", "import { Vector2 } from '../types';\nimport { v2Sub } from './linear-algebra/vector';\nimport { getV2Angle } from './angle';\nimport { convertRange } from './other';\n\n/**\n * Circle Equation\n * x^2 + y^2 = radius^2\n * ----------------------\n * Circle Parametric Equation\n * x(t) = radius * cos(t)\n * y(t) = radius * sin(t)\n * t is the parameter = angle\n */\nexport const circleMovement = (center: Vector2, angle: number, radius: number): Vector2 => {\n    angle = angle % Math.PI * 2;\n\n    return [\n        center[0] + Math.cos(angle) * radius,\n        center[1] + Math.sin(angle) * radius\n    ];\n};\n\n/**\n * Circle Movement After Mouse.\n * Mouse Positions:\n * - pageX/Y coordinates are relative to the top left corner of the whole rendered page (including parts hidden by scrolling),\n * - screenX and screenY: Relative to the top left of the physical screen/monitor, this reference point only moves if you increase or decrease the number of monitors or the monitor resolution.\n * - clientX/Y coordinates are relative to the top left corner of the visible part of the page, \"seen\" through browser window.\n * - offsetX and offsetY are relative to the parent container,\n */\nexport const circleMovementAfterMouse = (\n    mouse: Vector2,\n    center: Vector2,\n    radius: number\n): Vector2 => {\n\n    const vector = v2Sub(mouse, center);\n\n    let angle = getV2Angle(vector);\n\n    // convert the angle from the range [0, Math.PI*2] to the range [0, Math.PI]\n    angle = convertRange(angle, 0, Math.PI*2, 0, Math.PI);\n\n    return circleMovement(center, angle, radius);\n};\n\n/**\n * Ellipse Equation\n * (x - centerX)^2 / (radius1^2) + (y - centerY)^2 / (radius2^2) = 1\n * -----------------------------------------------------------------\n * Ellipse Parametric Equation\n * x(t) = radius1 * cos(t)\n * y(t) = radius2 * sin(t)\n * t is the parameter = angle\n */\nexport const ellipseMovement = (center: Vector2, angle: number, radius1: number, radius2: number): Vector2 => {\n    angle = angle % Math.PI * 2;\n\n    return [\n        center[0] + Math.cos(angle) * radius1,\n        center[1] + Math.sin(angle) * radius2\n    ];\n};\n\n/**\n * Sine Wave Equation (Sinusoid)\n * -----------------------------\n * const y = amplitude * Math.sin(2 * Math.PI * frequency * x + phase);\n * amplitude = the peak deviation of the function from zero\n * frequency = number of cycles\n * phase = specifies (in radians) where in its cycle the oscillation is at t = 0.\n * think of it as \"shifting\" the starting point of the function to the right (positive p) or left (negative)\n */\nexport const sineWaveMovement = (x: number, amplitude: number, frequency: number, phase: number) : Vector2 => {\n    /*\n    example values:\n    const amplitude = 50;\n    const frequency = 0.005;\n    const phase = 0;\n    x: [0, 1000]\n     */\n    const y = amplitude * Math.sin(2 * Math.PI * frequency * x + phase);\n\n    return [x, y];\n};\n\n/**\n * Lissajous curve (Lissajous figure or Bowditch curve)\n * Parametric equation #1\n * f(t) = A * sin(k * t + m)\n * f(t) = B * sin(n * t)\n * 0 <= m <= PI/2\n * k, n >= 1\n * -----------------------\n * Parametric equation #2\n * f(t) = A * cos(k * t - m)\n * f(t) = B * cos(n * t - p)\n * -----------------------------\n * Shapes:\n * k = 1, n = 1, m = 0, p = 0 ---> line\n * A = B,  k = 1, n = 1, m = PI/2, p = PI/2 ----> circle\n * A != B, k = 1, n = 1, m = PI/2, p = PI/2 ----> ellipse\n * k = 2, n = 2, m = PI/2, p = PI/2 ----> section of a parabola\n */\nexport const lissajousCurve = (\n    width: number,\n    height: number,\n    t: number,\n    k: number,\n    n: number,\n    m: number,\n    p: number\n) :Vector2 => {\n    return [\n        width * Math.cos(k * t - m),\n        height * Math.cos(n * t - p),\n    ];\n};\n", "import { getRandom } from './random';\nimport { HSLColor, RGBColor } from '../types';\nimport { mod } from './other';\nimport { setDecimalPlaces } from './format';\n\n// ------------------------ RANDOM COLOR -------------------------------------\n\nexport const getRandomRGBColor = () : RGBColor => {\n    const hslColor = getRandomHSLColor();\n    return hslToRgb(hslColor);\n};\n\nexport const getRandomHexColor = () : string => {\n    const hslColor = getRandomHSLColor();\n    return hslToHex(hslColor);\n};\n\nexport const getRandomHSLColor = () : HSLColor => {\n    const h = getRandom(1, 360);\n    const s = getRandom(0, 100);\n    const l = getRandom(0, 100);\n    return [h, s, l];\n};\n\n/**\n * generate random color with the given hue\n */\nexport const getRandomHSLColorWithHue = (h: number) : HSLColor => {\n    const s = getRandom(0, 100);\n    const l = getRandom(0, 100);\n    return [h, s, l];\n};\n\n/**\n * generate random color with the given saturation\n */\nexport const getRandomHSLColorWithSaturation = (s: number) : HSLColor => {\n    const h = getRandom(1, 360);\n    const l = getRandom(0, 100);\n    return [h, s, l];\n};\n\n/**\n * generate random color with the given lightness\n */\nexport const getRandomHSLColorWithLightness = (l: number) : HSLColor => {\n    const h = getRandom(1, 360);\n    const s = getRandom(0, 100);\n    return [h, s, l];\n};\n\nexport const getRandomGrayscaleHSLColor = () : HSLColor => {\n    const l = getRandom(0, 100);\n    return [0, 0, l];\n};\n\nexport const getRandomHSLColorWithinRanges = (\n    hueStart = 1, hueEnd = 360,\n    saturationStart = 0, saturationEnd = 100,\n    lightStart = 0, lightEnd = 100\n) : HSLColor => {\n    const h = getRandom(hueStart, hueEnd);\n    const s = getRandom(saturationStart, saturationEnd);\n    const l = getRandom(lightStart, lightEnd);\n    return [h, s, l];\n};\n\n// ----------------------- CONVERT COLORS --------------------------------------\n\n/**\n * helper: convert hue value to %\n * @param {number} h\n * @return {number} [0, 100] %\n */\nconst convertHueToPercent = (h : number) : number => {\n\n    // the hue value needs to be multiplied by 60 to convert it to degrees\n    h *= 60;\n\n    // if hue becomes negative, you need to add 360 to, because a circle has 360 degrees\n    if(h < 0){\n        h += 360;\n    }\n\n    // convert huw to %\n    return h * 100 / 360;\n};\n\n/**\n * get hue from RGB\n * @param {number} r [0, 255]\n * @param {number} g [0, 255]\n * @param {number} b [0, 255]\n * @param {number|undefined=} min - min number of [r, g, b]\n * @param {number|undefined=} max - max number of [r, g, b]\n * @return {number} [0, 100] % - we use here % instead of [0, 359] degrees\n */\nconst getHue = (r : number, g : number, b : number, min : number | undefined = undefined, max : number | undefined = undefined) : number => {\n\n    // find the minimum and maximum values of r, g, and b if they are not provided\n    min = (min === undefined) ? Math.min(r, g, b) : min;\n    max = (min === undefined) ? Math.max(r, g, b) : max;\n\n    // if the min and max value are the same -> no hue, as it's gray\n    if(min === max) return 0;\n\n    // if red is max\n    if(max === r){\n        return convertHueToPercent((g - b) / (max - min));\n    }\n\n    // if green is max\n    if(max === g){\n        return convertHueToPercent(2.0 + (b - r) / (max - min));\n    }\n\n    // if blue is max\n    if(max === b){\n        return convertHueToPercent(4.0 + (r - g) / (max - min));\n    }\n\n    return 0;\n};\n\n/**\n * get luminance from RGB\n * @param {number} r [0, 255]\n * @param {number} g [0, 255]\n * @param {number} b [0, 255]\n * @param {number|undefined=} min - min number of [r, g, b]\n * @param {number|undefined=} max - max number of [r, g, b]\n * @return {number} [0, 100] %\n */\nconst getLuminance = (\n    r : number,\n    g : number,\n    b : number,\n    min : number | undefined = undefined,\n    max : number | undefined = undefined) : number => {\n\n    // find the minimum and maximum values of r, g, and b if they are not provided\n    min = (min === undefined) ? Math.min(r, g, b) : min;\n    max = (min === undefined) ? Math.max(r, g, b) : max;\n\n    // calculate the luminance value\n    // @ts-ignore\n    const l = (min + max) / 2; // [0, 1]\n\n    // return l value in %\n    return l * 100;\n};\n\n/**\n * get saturation from RGB\n * @param {number} r [0, 255]\n * @param {number} g [0, 255]\n * @param {number} b [0, 255]\n * @param {number|undefined=} min - min number of [r, g, b]\n * @param {number|undefined=} max - max number of [r, g, b]\n * @param {number|undefined=} l - luminance in [0, 100] %\n * @return {number} [0, 100] %\n */\nconst getSaturation = (\n    r : number,\n    g : number,\n    b : number,\n    min : number | undefined = undefined,\n    max : number | undefined = undefined,\n    l : number | undefined = undefined) : number => {\n\n    // find the minimum and maximum values of r, g, and b if they are not provided\n    min = (min === undefined) ? Math.min(r, g, b) : min;\n    max = (min === undefined) ? Math.max(r, g, b) : max;\n\n    // if the min and max value are the same -> no saturation, as it's gray\n    if(min === max) return 0;\n\n    // calculate luminance if it's not provided\n    l = (l === undefined) ? getLuminance(r, g, b) : l;\n\n    // check the level of luminance\n    const s = (l <= 50) ?\n        // @ts-ignore\n        ((max - min) / (max + min)) : // this formula is used when luminance <= 50%\n        // @ts-ignore\n        (max - min) / (2.0 - max - min);  // this formula is used when luminance > 50%\n\n    // return saturation in %\n    return s * 100;\n};\n\nexport const rgbToHsl = (rgb: RGBColor, decimalPlaces = Infinity): HSLColor => {\n\n    // convert rgb values to the range [0, 1]\n    const r = rgb[0] / 255;\n    const g = rgb[1] / 255;\n    const b = rgb[2] / 255;\n\n    // find the minimum and maximum values of r, g, and b\n    const min = Math.min(r, g, b);\n    const max = Math.max(r, g, b);\n\n    // calculate the luminance value in %\n    const l = getLuminance(r, g, b, min, max);\n\n    // calculate the saturation in %\n    const s = getSaturation(r, g, b, min, max, l);\n\n    // calculate the hue in % (not in degrees!)\n    const h = getHue(r, g, b, min, max);\n\n    if(h > 360 || s > 100 || l > 100){\n        return [0, 0, 100];\n    }\n\n    if(h < 0 || s < 0 || l < 0){\n        return [0, 0, 0];\n    }\n\n    return [\n        setDecimalPlaces(h, decimalPlaces),\n        setDecimalPlaces(s, decimalPlaces),\n        setDecimalPlaces(l, decimalPlaces),\n    ];\n};\n\n/**\n * helper: HSL to RGB\n */\nconst hslToRgbHelper = (helper1 : number, helper2 : number, colorHelper : number) : number => {\n\n    // all values need to be between 0 and 1\n    // if you get a negative value you need to add 1 to it\n    if(colorHelper < 0) colorHelper += 1;\n\n    // if you get a value above 1 you need to subtract 1 from it.\n    if(colorHelper > 1) colorHelper -= 1;\n\n    if(colorHelper * 6 < 1) return helper2 + (helper1 - helper2) * 6 * colorHelper;\n\n    if(colorHelper * 2 < 1) return helper1;\n\n    if(colorHelper * 3 < 2){\n        return helper2 + (helper1 - helper2) * (0.666 - colorHelper) * 6;\n    }\n    else{\n        return helper2;\n    }\n};\n\nexport const hslToRgb = (hsl: HSLColor, decimalPlaces = Infinity): RGBColor => {\n\n    // convert all values to [0, 1] from %\n    const h = hsl[0] / 100;\n    const s = hsl[1] / 100;\n    const l = hsl[2] / 100;\n\n    // if there is no saturation -> it\u2019s grey\n    if(s === 0){\n        // convert the luminance from [0, 1] to [0, 255]\n        const gray = l * 255;\n        return [gray, gray, gray];\n    }\n\n    // check the level of luminance\n    const helper1 = (l < 0.5) ?\n        (l * (1.0 + s)) :\n        (l + s - l * s);\n\n    const helper2 = 2 * l - helper1;\n\n    const rHelper = h + 0.333;\n    const gHelper = h;\n    const bHelper = h - 0.333;\n\n    let r = hslToRgbHelper(helper1, helper2, rHelper);\n    let g = hslToRgbHelper(helper1, helper2, gHelper);\n    let b = hslToRgbHelper(helper1, helper2, bHelper);\n\n    // convert rgb to [0, 255]\n    r *= 255;\n    g *= 255;\n    b *= 255;\n\n    if(r > 255 || g > 255 || b > 255){\n        return [255, 255, 255];\n    }\n\n    if(r < 0 || g < 0 || b < 0){\n        return [0, 0, 0];\n    }\n\n    return [\n        setDecimalPlaces(r, decimalPlaces),\n        setDecimalPlaces(g, decimalPlaces),\n        setDecimalPlaces(b, decimalPlaces),\n    ];\n};\n\n/**\n * HSL to hex\n * hslToHex(360, 100, 50)  // [360, 100, 5] ==> \"#ff0000\" (red)\n */\nexport const hslToHex = (hsl: HSLColor) => {\n\n    if(hsl[0] > 360 || hsl[1] > 100 || hsl[2] > 100){\n        return '#ffffff';\n    }\n\n    if(hsl[0] < 0 || hsl[1] < 0 || hsl[2] < 0){\n        return '#000000';\n    }\n\n    const h = hsl[0] / 360;\n    const s = hsl[1] / 100;\n    const l = hsl[2] / 100;\n\n    let r, g, b;\n    if (s === 0) {\n        r = g = b = l; // achromatic\n    } else {\n        const hue2rgb = (p: number, q: number, t: number) => {\n            if (t < 0) t += 1;\n            if (t > 1) t -= 1;\n            if (t < 1 / 6) return p + (q - p) * 6 * t;\n            if (t < 1 / 2) return q;\n            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n            return p;\n        };\n        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n        const p = 2 * l - q;\n        r = hue2rgb(p, q, h + 1 / 3);\n        g = hue2rgb(p, q, h);\n        b = hue2rgb(p, q, h - 1 / 3);\n    }\n    const toHex = (x: number) => {\n        const hex = Math.round(x * 255).toString(16);\n        return hex.length === 1 ? '0' + hex : hex;\n    };\n\n    return `#${toHex(r)}${toHex(g)}${toHex(b)}`;\n};\n\n// ----------------------- GET SHIFTED COLORS --------------------------------------\n\nexport const getShiftedHue = (color: HSLColor, shift = 180) : HSLColor => {\n    let hue = color[0];\n    hue += shift;\n\n    if (hue > 360 || hue < 0) {\n        hue = mod(hue, 360);\n    }\n\n    return [hue, color[1], color[2]];\n};\n\nexport const getShiftedLightness = (color: HSLColor, shift = 10) : HSLColor => {\n    let lightness = color[2];\n    lightness += shift;\n\n    if (lightness > 100 || lightness < 0) {\n        lightness = mod(lightness, 100);\n    }\n\n    return [color[0], color[1], lightness];\n};\n\nexport const getShiftedSaturation = (color: HSLColor, shift = 10) : HSLColor => {\n    let saturation = color[1];\n    saturation += shift;\n\n    if (saturation > 100) {\n        saturation -= 100;\n    }\n\n    if(saturation < 0){\n        saturation += 100;\n    }\n\n    return [color[0], saturation, color[2]];\n};\n", "/**\n * guid like '932ade5e-c515-4807-ac01-73b20ab3fb66'\n */\nexport const guid = () => {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g,  (c) => {\n        const r = Math.random() * 16 | 0;\n        return (c == 'x' ? r : r & 0x3 | 0x8).toString(16);\n    });\n};\n\n/**\n * id like 'df4unio1opulby2uqh4'\n */\nexport const newId = () => {\n  return Math.random().toString(36).substring(2) + (new Date()).getTime().toString(36);\n};\n", "import { setDecimalPlaces } from './format';\n\n/**\n * get the side of a square inscribed in a circle\n */\nexport const getSquareInCircleSide = (radius: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(radius * 2 / Math.sqrt(2), decimalPlaces);\n};\n", "import { EPathDataCommand, IPathDataScanResult } from './interfaces';\n\nconst NUMBER_REGEX = /^[+-]?(?=\\.\\d|\\d)(?:0|[1-9]\\d*)?(?:\\.\\d+)?(?:(?<=\\d)(?:[eE][+-]?\\d+))?/;\n\n/**\n * Path Data Scanner.\n */\nexport const scan = (pathData?: string) : IPathDataScanResult => {\n\n    const result: IPathDataScanResult = {\n        tokens: [],\n        errors: [],\n    };\n\n    if(!pathData || pathData.trim() === '') return result;\n\n    let current = 0;\n    let line = 0;\n    let col = 0;\n\n    const isEnd = () => {\n        return current >= pathData.length;\n    };\n\n    const addKeywordToken = (tokenType: EPathDataCommand) => {\n        result.tokens.push({\n            tokenType,\n            line,\n            col,\n        });\n    };\n\n    const addNumberToken = (num: number|string) => {\n        result.tokens.push({\n            tokenType: 'num',\n            value: num,\n            line,\n            col,\n        });\n    };\n\n    const addError = (msg: string) => {\n        result.errors.push({\n            line,\n            col,\n            msg,\n        });\n    };\n\n    const matchNumber = () : boolean => {\n        if(isEnd()) return false;\n        return NUMBER_REGEX.test(pathData.substring(current));\n    };\n\n    /**\n     * Scan a single token.\n     */\n    const scanToken = () => {\n        const char = pathData[current];\n\n        // Path data can contain newline characters and\n        // thus can be broken up into multiple lines to improve readability.\n        // If a newline character ---> update line and col params.\n        if(char.charAt(0) === '\\n' || char.charAt(0) === '\\r'){\n            current++;\n            col = 0;\n            line++;\n            return;\n        }\n\n        // Superfluous white space and separators such as commas can be eliminated.\n        // \"M 100 100 L 200 200\" contains unnecessary spaces and could be expressed more compactly as \"M100 100L200 200\".\n        if(/\\s/.test(char) || char === ','){\n            current++;\n            col++;\n            return;\n        }\n\n        // try to match a number\n        if(matchNumber()){\n            const matchRes = pathData.substring(current).match(NUMBER_REGEX);\n\n            if(matchRes && matchRes.length > 0){\n                const num = matchRes[0];\n                addNumberToken(num);\n\n                current += num.length;\n                col += num.length;\n                return;\n            }\n        }\n\n        switch(char){\n            case 'M': addKeywordToken(EPathDataCommand.MoveToAbs); break;\n            case 'm': addKeywordToken(EPathDataCommand.MoveToRel); break;\n            case 'Z': addKeywordToken(EPathDataCommand.ClosePathAbs); break;\n            case 'z': addKeywordToken(EPathDataCommand.ClosePathRel); break;\n            case 'L': addKeywordToken(EPathDataCommand.LineToAbs); break;\n            case 'l': addKeywordToken(EPathDataCommand.LineToRel); break;\n            case 'H': addKeywordToken(EPathDataCommand.LineToHorizontalAbs); break;\n            case 'h': addKeywordToken(EPathDataCommand.LineToHorizontalRel); break;\n            case 'V': addKeywordToken(EPathDataCommand.LineToVerticalAbs); break;\n            case 'v': addKeywordToken(EPathDataCommand.LineToVerticalRel); break;\n            case 'C': addKeywordToken(EPathDataCommand.CubicCurveToAbs); break;\n            case 'c': addKeywordToken(EPathDataCommand.CubicCurveToRel); break;\n            case 'S': addKeywordToken(EPathDataCommand.CubicCurveToSmoothAbs); break;\n            case 's': addKeywordToken(EPathDataCommand.CubicCurveToSmoothRel); break;\n            case 'Q': addKeywordToken(EPathDataCommand.QuadraticCurveToAbs); break;\n            case 'q': addKeywordToken(EPathDataCommand.QuadraticCurveToRel); break;\n            case 'T': addKeywordToken(EPathDataCommand.QuadraticCurveToSmoothAbs); break;\n            case 't': addKeywordToken(EPathDataCommand.QuadraticCurveToSmoothRel); break;\n            case 'A': addKeywordToken(EPathDataCommand.ArcAbs); break;\n            case 'a': addKeywordToken(EPathDataCommand.ArcRel); break;\n\n            default: {\n                addError(`Unexpected character ${ char }`);\n                break;\n            }\n        }\n\n        current++;\n        col++;\n    };\n\n    /**\n     * The loop.\n     */\n    while(!isEnd()){\n        scanToken();\n    }\n\n    return result;\n};", "import { EPathDataCommand, IPathData, IPathDataScanResult, IPathDataToken } from './interfaces';\n\n/**\n * All path data instructions are expressed as one character (e.g., a moveto is expressed as an M).\n * Relative versions of all commands are available (uppercase means absolute coordinates, lowercase means relative coordinates).\n * https://www.w3.org/TR/SVG11/paths.html#PathData\n */\nexport const parse = (scanResult: IPathDataScanResult) : IPathData => {\n\n    const pathData: IPathData = {\n        commands: [],\n        errors: scanResult.errors || [],\n    };\n\n    if(scanResult.errors.length > 0 ||\n        scanResult.tokens.length === 0) return pathData;\n\n    const { tokens, errors } = scanResult;\n\n    const error = (token: IPathDataToken, msg: string) => {\n        errors.push({\n            line: token?.line,\n            col: token?.col,\n            msg,\n        });\n    };\n\n    // https://www.w3.org/TR/SVG11/paths.html#PathDataMovetoCommands\n    // A path data segment (if there is one) must begin with a \"moveto\" command.\n    if(tokens[0].tokenType !== EPathDataCommand.MoveToAbs &&\n        tokens[0].tokenType !== EPathDataCommand.MoveToRel) {\n        error(tokens[0], `A path data segment must begin with a 'moveto' command 'M' or 'm'.`);\n        return pathData;\n    }\n\n    let current = 0;\n\n    const isEnd = () => {\n        return current >= tokens.length;\n    };\n\n    const areArcFlagsValid = (tokenType: string): boolean => {\n\n        // we are checking only 'A/a' type\n        if(!tokenType || tokenType.toLowerCase() !== 'a') return true;\n\n        // 4th and 5th param should be 0 or 1\n        const val4 = (tokens[current + 4]?.value || '').toString();\n        const val5 = (tokens[current + 5]?.value || '').toString();\n\n        return (val4 === '0' || val4 === '1') && (val5 === '0' || val5 === '1');\n    };\n\n    /**\n     * https://www.w3.org/TR/SVG11/paths.html#PathData\n     */\n    const parseCommand = (paramsCount: number, nextParamsTokenType: EPathDataCommand, isRelative: boolean) => {\n\n        const tokenType = tokens[current].tokenType;\n        const params: number[] = [];\n\n        if(paramsCount > 0){\n\n            // Validate the parameters count, and add them to the params list.\n            for(let i= 1; i <= paramsCount; i++){\n                if(!tokens[current + i] || tokens[current + i].tokenType !== 'num'){\n                    error(tokens[current], `Expected number(s) after command ${ tokenType }.`);\n                    current += paramsCount;\n                    return;\n                }\n\n                params.push(Number(tokens[current + i].value));\n            }\n        }\n\n        // validate arc flags ------\n        if(!areArcFlagsValid(tokenType)){\n            error(tokens[current], `Arc flags must be 0 or 1.`);\n            current += paramsCount + 1;\n            return;\n        }\n\n        // validate arc flags ------\n        if(!areArcFlagsValid(tokenType)){\n            error(tokens[current], `Arc flags must be 0 or 1.`);\n            current += paramsCount + 1;\n            return;\n        }\n\n        pathData.commands.push({\n            command: tokens[current].tokenType as EPathDataCommand,\n            params,\n        });\n\n        current += paramsCount + 1;\n\n        if(paramsCount <= 0) return;\n\n        // If the command is followed by multiple sets of coordinates, the subsequent pairs are treated as implicit commands.\n        const nextTokens: IPathDataToken[] = [];\n\n        // Add all 'next params' to the list.\n        while(tokens[current]?.tokenType === 'num'){\n            nextTokens.push(tokens[current]);\n            current++;\n        }\n\n        // Validate next params count.\n        if(nextTokens.length % paramsCount !== 0){\n            error(nextTokens[nextTokens.length - 1], `Expected a number.`);\n            return;\n        }\n\n        const nextCommand = (isRelative ? nextParamsTokenType.toLowerCase() : nextParamsTokenType.toUpperCase()) as EPathDataCommand;\n\n        // Add them to the commands list.\n        for(let i= 0; i < nextTokens.length; i += paramsCount){\n            const nextParams: number[] = [];\n            for(let j = 0; j < paramsCount; j++){\n                nextParams.push(Number(nextTokens[i + j].value));\n            }\n            pathData.commands.push({\n                command: nextCommand,\n                params: nextParams,\n            });\n        }\n    };\n\n    const parseNext = () => {\n        const token = tokens[current];\n\n        const isRelative = token.tokenType.toLowerCase() === token.tokenType;\n\n        switch (token.tokenType){\n            case EPathDataCommand.MoveToAbs:\n            case EPathDataCommand.MoveToRel:\n            case EPathDataCommand.LineToAbs:\n            case EPathDataCommand.LineToRel:{\n                parseCommand(2, EPathDataCommand.LineToAbs, isRelative);\n                break;\n            }\n\n            case EPathDataCommand.ClosePathAbs:\n            case EPathDataCommand.ClosePathRel:{\n                parseCommand(0, EPathDataCommand.LineToAbs, isRelative);\n                break;\n            }\n\n            case EPathDataCommand.LineToHorizontalAbs:\n            case EPathDataCommand.LineToHorizontalRel:\n            case EPathDataCommand.LineToVerticalAbs:\n            case EPathDataCommand.LineToVerticalRel:{\n                parseCommand(1, token.tokenType, isRelative);\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToAbs:\n            case EPathDataCommand.CubicCurveToRel:{\n                parseCommand(6, token.tokenType, isRelative);\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToSmoothAbs:\n            case EPathDataCommand.CubicCurveToSmoothRel:\n            case EPathDataCommand.QuadraticCurveToAbs:\n            case EPathDataCommand.QuadraticCurveToRel:{\n                parseCommand(4, token.tokenType, isRelative);\n                break;\n            }\n\n            case EPathDataCommand.QuadraticCurveToSmoothAbs:\n            case EPathDataCommand.QuadraticCurveToSmoothRel:{\n                parseCommand(2, token.tokenType, isRelative);\n                break;\n            }\n\n            case EPathDataCommand.ArcAbs:\n            case EPathDataCommand.ArcRel:{\n                parseCommand(7, token.tokenType, isRelative);\n                break;\n            }\n\n            default: {\n                error(tokens[current], `Wrong path command.`);\n                current++;\n                break;\n            }\n        }\n    };\n\n    // A path data segment (if there is one) must begin with a \"moveto\" command.\n    parseCommand(2, EPathDataCommand.LineToAbs, tokens[0].tokenType === EPathDataCommand.MoveToRel);\n\n    /**\n     * The loop.\n     */\n    while(!isEnd()){\n        parseNext();\n    }\n\n    return pathData;\n};", "import { EPathDataCommand, IPathData } from './interfaces';\nimport { setDecimalPlaces } from 'mz-math';\n\nconst numberToString = (num: number, decimalPlaces = 2) : string => {\n\n    if(Number.isInteger(num)) return num.toString();\n\n    const _num = setDecimalPlaces(num, decimalPlaces).toString();\n    const parts = _num.split('.');\n    const intPart = parts[0];\n    const decimalPart = parts[1];\n\n    if(intPart === '0') return `.${ decimalPart }`;\n    if(intPart === '-0') return `-.${ decimalPart }`;\n\n    return _num;\n};\n\nconst combineParams = (params: number[], decimalPlaces: number) => {\n    if(!params || params.length <= 0) return '';\n\n    let combined = numberToString(params[0], decimalPlaces);\n\n    for(let i= 1; i<params.length; i++){\n        const param = params[i];\n        const str = numberToString(param, decimalPlaces);\n        if(param < 0){\n            combined +=  str;\n        }\n        else{\n            combined += ` ${ str }`;\n        }\n    }\n\n    return combined;\n};\n\nexport const pathDataMinify = (pathData: IPathData, decimalPlaces = 2) : string => {\n\n    let d = '';\n    let lastCommand: EPathDataCommand|null = null;\n\n    for(const item of pathData.commands){\n\n        // handle cases like 'L80 0' ----> 'H80', 'L0 80' ----> 'V80'\n        if(item.command === EPathDataCommand.LineToAbs){\n            if(item.params[0] === 0){\n                d += `V${ numberToString(item.params[1], decimalPlaces) }`;\n                lastCommand = EPathDataCommand.LineToVerticalAbs;\n                continue;\n            }\n\n            if(item.params[1] === 0){\n                d += `H${ numberToString(item.params[0], decimalPlaces) }`;\n                lastCommand = EPathDataCommand.LineToHorizontalAbs;\n                continue;\n            }\n        }\n\n        // handle cases like 'l80 0' ----> 'h80' & 'l0 80' ----> 'v80'\n        if(item.command === EPathDataCommand.LineToRel){\n            if(item.params[0] === 0){\n                d += `v${ numberToString(item.params[1], decimalPlaces) }`;\n                lastCommand = EPathDataCommand.LineToVerticalRel;\n                continue;\n            }\n\n            if(item.params[1] === 0){\n                d += `h${ numberToString(item.params[0], decimalPlaces) }`;\n                lastCommand = EPathDataCommand.LineToHorizontalRel;\n                continue;\n            }\n        }\n\n        // handle cases like 'c0 0 10 0 10 10' ---> 's10 0 10 10'\n        if(item.command === EPathDataCommand.CubicCurveToRel &&\n            lastCommand?.toLowerCase() !== EPathDataCommand.CubicCurveToAbs.toLowerCase() &&\n            lastCommand?.toLowerCase() !== EPathDataCommand.CubicCurveToSmoothAbs.toLowerCase()){\n            if(item.params[0] === 0 && item.params[1] === 0){\n\n                const params = combineParams([\n                    item.params[2],\n                    item.params[3],\n                    item.params[4],\n                    item.params[5],\n                ], decimalPlaces);\n\n                d += `s${ params }`;\n                lastCommand = EPathDataCommand.CubicCurveToSmoothRel;\n                continue;\n            }\n        }\n\n        const canSkipCommand =\n            (lastCommand === item.command) ||\n            (lastCommand === EPathDataCommand.MoveToAbs && item.command === EPathDataCommand.LineToAbs) ||\n            (lastCommand === EPathDataCommand.MoveToRel && item.command === EPathDataCommand.LineToRel);\n\n        if(canSkipCommand){\n            if(item.params.length > 0 && item.params[0] >= 0){\n                d += ' ';\n            }\n        }\n        else{\n            d += item.command;\n        }\n\n        d += combineParams(item.params, decimalPlaces);\n\n        lastCommand = item.command;\n    }\n\n    return d.trim();\n};\n", "import { EPathDataCommand, IPathData } from './interfaces';\nimport { setDecimalPlaces } from 'mz-math';\nimport { pathDataMinify } from './minify';\n\nexport const pathDataToRelative = (pathData: IPathData): IPathData => {\n\n    const { commands } = pathData;\n\n    if(commands.length <= 0) return pathData;\n\n    // current (x, y) pair\n    let x = commands[0].params[0];\n    let y = commands[0].params[1];\n\n    // the latest 'M' coordinates\n    let mx = x;\n    let my = y;\n\n    // Make first M to be absolute\n    commands[0].command = EPathDataCommand.MoveToAbs;\n\n    for(let i = 1; i<commands.length; i++){\n        const item = commands[i];\n\n        switch (item.command) {\n            case EPathDataCommand.MoveToAbs:{\n                commands[i].params[0] -= x;\n                commands[i].params[1] -= y;\n\n                mx = commands[i].params[0];\n                my = commands[i].params[1];\n                break;\n            }\n\n            case EPathDataCommand.ClosePathAbs:\n            case EPathDataCommand.ClosePathRel:{\n                x = mx;\n                y = my;\n                break;\n            }\n\n            case EPathDataCommand.LineToAbs:\n            case EPathDataCommand.QuadraticCurveToSmoothAbs:{\n                const savedX = commands[i].params[0];\n                const savedY = commands[i].params[1];\n\n                commands[i].params[0] -= x;\n                commands[i].params[1] -= y;\n\n                x = savedX;\n                y = savedY;\n                break;\n            }\n\n            case EPathDataCommand.MoveToRel:\n            case EPathDataCommand.LineToRel:{\n                x += commands[i].params[0];\n                y += commands[i].params[1];\n                break;\n            }\n\n            case EPathDataCommand.LineToHorizontalAbs:{\n                const savedX = commands[i].params[0];\n                commands[i].params[0] -= x;\n                x = savedX;\n                break;\n            }\n\n            case EPathDataCommand.LineToHorizontalRel:{\n                x += commands[i].params[0];\n                break;\n            }\n\n            case EPathDataCommand.LineToVerticalAbs:{\n                const savedY = commands[i].params[0];\n                commands[i].params[0] -= y;\n                y = savedY;\n                break;\n            }\n\n            case EPathDataCommand.LineToVerticalRel:{\n                y += commands[i].params[0];\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToAbs:{\n                const savedX = commands[i].params[4];\n                const savedY = commands[i].params[5];\n\n                // x1 y1 - control point at the beginning of the curve\n                commands[i].params[0] -= x;\n                commands[i].params[1] -= y;\n\n                // x2 y2 - control point at the end of the curve\n                commands[i].params[2] -= x;\n                commands[i].params[3] -= y;\n\n                // At the end of the command, the new current point becomes the final (x,y) coordinate pair used in the poly-b\u00E9zier.\n                commands[i].params[4] -= x;\n                commands[i].params[5] -= y;\n\n                x = savedX;\n                y = savedY;\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToRel:{\n                x += commands[i].params[4];\n                y += commands[i].params[5];\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToSmoothAbs:\n            case EPathDataCommand.QuadraticCurveToAbs:{\n                const savedX = commands[i].params[2];\n                const savedY = commands[i].params[3];\n\n                commands[i].params[0] -= x;\n                commands[i].params[1] -= y;\n\n                commands[i].params[2] -= x;\n                commands[i].params[3] -= y;\n\n                x = savedX;\n                y = savedY;\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToSmoothRel:\n            case EPathDataCommand.QuadraticCurveToRel:{\n                x += commands[i].params[2];\n                y += commands[i].params[3];\n                break;\n            }\n\n            case EPathDataCommand.ArcAbs:{\n                // (rx ry x-axis-rotation large-arc-flag sweep-flag x y)+\n                const savedX = commands[i].params[5];\n                const savedY = commands[i].params[6];\n\n                // x y\n                commands[i].params[5] -= x;\n                commands[i].params[6] -= y;\n\n                x = savedX;\n                y = savedY;\n                break;\n            }\n\n            case EPathDataCommand.ArcRel:{\n                x += commands[i].params[5];\n                y += commands[i].params[6];\n                break;\n            }\n        }\n\n        // make the command lowercase\n        commands[i].command = commands[i].command.toLowerCase() as EPathDataCommand;\n    }\n\n    return pathData;\n};\n\nexport const pathDataToAbsolute = (pathData: IPathData): IPathData => {\n\n    const { commands } = pathData;\n\n    if(commands.length <= 0) return pathData;\n\n    // current (x, y) pair\n    let x = commands[0].params[0];\n    let y = commands[0].params[1];\n\n    // the latest 'M' coordinates\n    let mx = x;\n    let my = y;\n\n    // Make first M to be absolute\n    commands[0].command = EPathDataCommand.MoveToAbs;\n\n    for(let i = 1; i<commands.length; i++){\n        const item = commands[i]\n\n        switch (item.command) {\n            case EPathDataCommand.MoveToRel:{\n                commands[i].params[0] += x;\n                commands[i].params[1] += y;\n\n                mx = commands[i].params[0];\n                my = commands[i].params[1];\n                break;\n            }\n\n            case EPathDataCommand.ClosePathAbs:\n            case EPathDataCommand.ClosePathRel:{\n                x = mx;\n                y = my;\n                break;\n            }\n\n            case EPathDataCommand.LineToRel:\n            case EPathDataCommand.QuadraticCurveToSmoothRel:{\n                const savedX = commands[i].params[0];\n                const savedY = commands[i].params[1];\n\n                commands[i].params[0] += x;\n                commands[i].params[1] += y;\n\n                x += savedX;\n                y += savedY;\n                break;\n            }\n\n            case EPathDataCommand.MoveToAbs:\n            case EPathDataCommand.LineToAbs:{\n                x = commands[i].params[0];\n                y = commands[i].params[1];\n                break;\n            }\n\n            case EPathDataCommand.LineToHorizontalRel:{\n                const savedX = commands[i].params[0];\n                commands[i].params[0] += x;\n                x += savedX;\n                break;\n            }\n\n            case EPathDataCommand.LineToHorizontalAbs:{\n                x = commands[i].params[0];\n                break;\n            }\n\n            case EPathDataCommand.LineToVerticalRel:{\n                const savedY = commands[i].params[0];\n                commands[i].params[0] += y;\n                y += savedY;\n                break;\n            }\n\n            case EPathDataCommand.LineToVerticalAbs:{\n                y = commands[i].params[0];\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToRel:{\n                const savedX = commands[i].params[4];\n                const savedY = commands[i].params[5];\n\n                // x1 y1 - control point at the beginning of the curve\n                commands[i].params[0] += x;\n                commands[i].params[1] += y;\n\n                // x2 y2 - control point at the end of the curve\n                commands[i].params[2] += x;\n                commands[i].params[3] += y;\n\n                // At the end of the command, the new current point becomes the final (x,y) coordinate pair used in the poly-b\u00E9zier.\n                commands[i].params[4] += x;\n                commands[i].params[5] += y;\n\n                x += savedX;\n                y += savedY;\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToAbs:{\n                x = commands[i].params[4];\n                y = commands[i].params[5];\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToSmoothRel:\n            case EPathDataCommand.QuadraticCurveToRel:{\n                const savedX = commands[i].params[2];\n                const savedY = commands[i].params[3];\n\n                commands[i].params[0] += x;\n                commands[i].params[1] += y;\n\n                commands[i].params[2] += x;\n                commands[i].params[3] += y;\n\n                x += savedX;\n                y += savedY;\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToSmoothAbs:\n            case EPathDataCommand.QuadraticCurveToAbs:{\n                x = commands[i].params[2];\n                y = commands[i].params[3];\n                break;\n            }\n\n            case EPathDataCommand.ArcRel:{\n                // (rx ry x-axis-rotation large-arc-flag sweep-flag x y)+\n                const savedX = commands[i].params[5];\n                const savedY = commands[i].params[6];\n\n                // x y\n                commands[i].params[5] += x;\n                commands[i].params[6] += y;\n\n                x += savedX;\n                y += savedY;\n                break;\n            }\n\n            case EPathDataCommand.ArcAbs:{\n                x = commands[i].params[5];\n                y = commands[i].params[6];\n                break;\n            }\n        }\n\n        // make the command uppercase\n        commands[i].command = commands[i].command.toUpperCase() as EPathDataCommand;\n    }\n\n    return pathData;\n};\n\nexport const pathDataToString = (pathData: IPathData, minify?: boolean, decimalPlaces = 2) : string => {\n    if(!pathData || pathData.commands.length <= 0) return '';\n\n    let d = '';\n\n    if(minify){\n        return pathDataMinify(pathData, decimalPlaces);\n    }\n\n    for(const item of pathData.commands){\n        d += item.command;\n        if(item.params.length > 0){\n            d += ` ${ item.params.map(param => Number.isInteger(param) ? param : setDecimalPlaces(param, decimalPlaces)).join(' ')} `\n        }\n        else{\n            d += ' ';\n        }\n    }\n\n    return d.trim();\n};\n\nexport const maximizeAbsolutePath = (pathData: IPathData): IPathData => {\n\n    const { commands } = pathData;\n\n    if(commands.length <= 0) return pathData;\n\n    // Make first M to be absolute\n    commands[0].command = EPathDataCommand.MoveToAbs;\n\n    for(let i = 1; i<commands.length; i++){\n        const item = commands[i];\n\n        switch (item.command) {\n\n            case EPathDataCommand.LineToHorizontalAbs:{\n                // prev should be line abs\n                const prev = commands[i - 1];\n                if(!prev) continue;\n\n                commands[i].command = EPathDataCommand.LineToAbs;\n\n                // update y to be the same as in previous command\n                commands[i].params[1] = prev.params[1];\n                break;\n            }\n\n            case EPathDataCommand.LineToVerticalAbs:{\n                // prev should be line abs\n                const prev = commands[i - 1];\n                if(!prev) continue;\n\n                commands[i].command = EPathDataCommand.LineToAbs;\n                const y = commands[i].params[0];\n\n                // update x to be the same as in previous command\n                commands[i].params[0] = prev.params[0];\n                commands[i].params.push(y);\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToSmoothAbs:{\n                // prev should be Cubic B\u00E9zier Curve Abs (C)\n                const prev = commands[i - 1];\n                if(!prev) continue;\n\n                // Structure for CubicCurveToAbs (C): x1,y1, x2,y2, x,y\n                commands[i].command = EPathDataCommand.CubicCurveToAbs;\n\n                // For S: (x2 y2 x y)\n                // The first control point is assumed to be the reflection\n                // of the second control point on the previous command\n                // relative to the current point.\n                // (If there is no previous command or if the previous command was not an C, c, S or s,\n                // assume the first control point is coincident with the current point.)\n                commands[i].params.unshift(prev.params[3]); // prev y2\n                commands[i].params.unshift(prev.params[2]); // prev x2\n                break;\n            }\n\n            case EPathDataCommand.QuadraticCurveToSmoothAbs:{\n                // prev should be Quadratic B\u00E9zier Curve Abs (Q)\n\n                const prev = commands[i - 1];\n                if(!prev) continue;\n\n                // Structure for CubicCurveToAbs (Q): x1 y1 x y\n                commands[i].command = EPathDataCommand.QuadraticCurveToAbs;\n\n                // For T: (x y)\n                // The control point is assumed to be the reflection of the control point on the previous command relative to the current point.\n                // (If there is no previous command or if the previous command was not a Q, q, T or t,\n                // assume the control point is coincident with the current point.)\n                commands[i].params.unshift(prev.params[1]); // prev y2\n                commands[i].params.unshift(prev.params[0]); // prev x2\n                break;\n            }\n        }\n    }\n\n    return pathData;\n};", "import { IPathData } from './interfaces';\nimport { scan } from './scanner';\nimport { parse } from './parser';\nimport { pathDataToAbsolute, pathDataToRelative, pathDataToString } from './convert';\nimport { pathDataMinify } from './minify';\n\nexport const isPathValid = (d?: string): boolean => {\n    const parsed = parsePath(d);\n    return parsed.errors.length <= 0;\n};\n\n/**\n * https://www.w3.org/TR/SVG11/paths.html#PathData\n * \u2018d\u2019 attribute contains the moveto, line, curve (both cubic and quadratic B\u00E9ziers), arc and closepath instructions.\n */\nexport const parsePath = (d?: string): IPathData => {\n    const scanResult = scan(d);\n    return parse(scanResult);\n};\n\n/**\n * Converts all path commands to relative.\n */\nexport const pathToRel = (d?: string, beautify = false, decimalPlaces = 2): string|undefined => {\n    if(!d) return d;\n\n    const parsed = parsePath(d);\n    if(parsed.errors.length > 0) return d;\n\n    return pathDataToString(pathDataToRelative(parsed), !beautify, decimalPlaces);\n};\n\n/**\n * Converts all path commands to absolute.\n */\nexport const pathToAbs = (d?: string, beautify = false, decimalPlaces = 2): string|undefined => {\n    if(!d) return d;\n\n    const parsed = parsePath(d);\n    if(parsed.errors.length > 0) return d;\n\n    return pathDataToString(pathDataToAbsolute(parsed), !beautify, decimalPlaces);\n};\n\nexport const minifyPath = (d?: string, decimalPlaces = 2): string|undefined => {\n    if(!d) return d;\n\n    const parsed = parsePath(d);\n    if(parsed.errors.length > 0) return d;\n\n    return pathDataMinify(parsed, decimalPlaces);\n};\n\nexport const beautifyPath = (d?: string, decimalPlaces = 2): string|undefined => {\n    if(!d) return d;\n\n    const parsed = parsePath(d);\n    if(parsed.errors.length > 0) return d;\n\n    return pathDataToString(parsed, false, decimalPlaces);\n};\n", "import { createPath } from './primitive-shapes';\nimport { DEFAULT_DECIMAL_PLACES } from '../core';\nimport { setDecimalPlaces } from 'mz-math';\nimport { IPrimitiveShapeProps } from '../../interfaces';\nimport { pathToRel } from '../path';\n\nexport interface ICreateStarProps extends IPrimitiveShapeProps{\n    raysNumber: number;\n    centerX: number;\n    centerY: number;\n    outerRadius: number;\n    innerRadius: number;\n    decimalPlaces?: number;\n    pathLength?: string|number;\n    type?: number;\n}\n\nexport const createStar = (props: ICreateStarProps) : SVGPathElement => {\n\n    switch (props.type){\n        case 2: {\n            return createStar2(props);\n        }\n        case 3: {\n            return createStar3(props);\n        }\n    }\n\n    return createStar1(props);\n};\n\nexport const createStar1 = (props: ICreateStarProps) : SVGPathElement => {\n\n    const {\n        centerX, centerY,\n        outerRadius, innerRadius,\n    } = props;\n\n    const MIN_RAYS_NUMBER = 3;\n    const dots: [number, number][] = [];\n\n    const raysNumber = Math.max(MIN_RAYS_NUMBER, Number(props.raysNumber) || MIN_RAYS_NUMBER);\n    const decimalPlaces = (props.decimalPlaces === null || props.decimalPlaces === undefined) ? DEFAULT_DECIMAL_PLACES : props.decimalPlaces;\n\n    const angleDiff = 2 * Math.PI / raysNumber;\n    const halfAngle = angleDiff / 2;\n\n    for(let i= 0, angle= 1.5 * Math.PI; i<raysNumber; i++, angle += angleDiff){\n        // outer circle\n        dots.push([\n            setDecimalPlaces(centerX + Math.cos(angle) * outerRadius, decimalPlaces),\n            setDecimalPlaces(centerY + Math.sin(angle) * outerRadius, decimalPlaces),\n        ]);\n\n        // inner circle\n        dots.push([\n            setDecimalPlaces(centerX + Math.cos(angle + halfAngle) * innerRadius, decimalPlaces),\n            setDecimalPlaces(centerY + Math.sin(angle + halfAngle) * innerRadius, decimalPlaces),\n        ]);\n    }\n\n    let d = `M ${ dots[0][0] } ${ dots[0][1] } `;\n    d += dots.map(dot => `L ${ dot[0] } ${ dot[1] }`).join(' ');\n    d += 'Z';\n    d = pathToRel(d) || d;\n\n    const pathProps = {\n        ...props,\n        d,\n    };\n\n    return createPath(pathProps);\n};\n\nexport const createStar2 = (props: ICreateStarProps) : SVGPathElement => {\n\n    const {\n        centerX, centerY,\n        outerRadius, innerRadius,\n    } = props;\n\n    const MIN_RAYS_NUMBER = 3;\n    const dots: [number, number][] = [];\n\n    const raysNumber = Math.max(MIN_RAYS_NUMBER, Number(props.raysNumber) || MIN_RAYS_NUMBER);\n    const decimalPlaces = (props.decimalPlaces === null || props.decimalPlaces === undefined) ? DEFAULT_DECIMAL_PLACES : props.decimalPlaces;\n\n    const angleDiff = 2 * Math.PI / raysNumber;\n    const halfAngle = angleDiff / 2;\n\n    for(let i= 0, angle= 1.5 * Math.PI; i<=raysNumber; i++, angle += angleDiff){\n\n        // inner circle\n        dots.push([\n            setDecimalPlaces(centerX + Math.cos(angle) * innerRadius, decimalPlaces),\n            setDecimalPlaces(centerY + Math.sin(angle) * innerRadius, decimalPlaces),\n        ]);\n\n        // outer circle\n        dots.push([\n            setDecimalPlaces(centerX + Math.cos(angle + halfAngle) * outerRadius, decimalPlaces),\n            setDecimalPlaces(centerY + Math.sin(angle + halfAngle) * outerRadius, decimalPlaces),\n        ]);\n    }\n\n    let d = `M ${ dots[0][0] } ${ dots[0][1] } `;\n\n    for(let i = 0; i < dots.length; i += 2){\n        const dot1 = dots[i];\n        const dot2 = dots[i + 1];\n        d += `S${ dot1[0] } ${ dot1[1] } ${ dot2[0] } ${ dot2[1] }`;\n    }\n\n    d += 'Z';\n    d = pathToRel(d) || d;\n\n    const pathProps = {\n        ...props,\n        d,\n    };\n\n    return createPath(pathProps);\n};\n\nexport const createStar3 = (props: ICreateStarProps) : SVGPathElement => {\n\n    const {\n        centerX, centerY,\n        outerRadius, innerRadius,\n    } = props;\n\n    const MIN_RAYS_NUMBER = 3;\n    const dots: [number, number][] = [];\n\n    const raysNumber = Math.max(MIN_RAYS_NUMBER, Number(props.raysNumber) || MIN_RAYS_NUMBER);\n    const decimalPlaces = (props.decimalPlaces === null || props.decimalPlaces === undefined) ? DEFAULT_DECIMAL_PLACES : props.decimalPlaces;\n\n    const angleDiff = 2 * Math.PI / raysNumber;\n    const halfAngle = angleDiff / 2;\n\n    for(let i= 0, angle= 1.5 * Math.PI; i<=raysNumber; i++, angle += angleDiff){\n\n        // inner circle\n        dots.push([\n            setDecimalPlaces(centerX + Math.cos(angle) * innerRadius, decimalPlaces),\n            setDecimalPlaces(centerY + Math.sin(angle) * innerRadius, decimalPlaces),\n        ]);\n\n        // outer circle\n        dots.push([\n            setDecimalPlaces(centerX + Math.cos(angle + halfAngle) * outerRadius, decimalPlaces),\n            setDecimalPlaces(centerY + Math.sin(angle + halfAngle) * outerRadius, decimalPlaces),\n        ]);\n    }\n\n    let d = `M ${ dots[0][0] } ${ dots[0][1] } `;\n\n    for(let i = 0; i < dots.length; i += 2){\n        const dot1 = dots[i];\n        const dot2 = dots[i + 1];\n        d += `S${ dot1[0] } ${ dot1[1] } ${ dot2[0] } ${ dot2[1] } L ${ dot2[0] } ${ dot2[1] }`;\n    }\n\n    d += 'Z';\n    d = pathToRel(d) || d;\n\n    const pathProps = {\n        ...props,\n        d,\n    };\n\n    return createPath(pathProps);\n};", "import { createPath } from './primitive-shapes';\nimport { DEFAULT_DECIMAL_PLACES } from '../core';\nimport { setDecimalPlaces } from 'mz-math';\nimport { IPrimitiveShapeProps } from '../../interfaces';\nimport { pathToRel } from '../path';\nimport { mod } from 'mz-math';\n\nexport interface ICreateFlowerProps extends IPrimitiveShapeProps{\n    petalsNumber: number;\n    centerX: number;\n    centerY: number;\n    outerRadius: number;\n    innerRadius: number;\n    decimalPlaces?: number;\n    pathLength?: string|number;\n}\n\nexport const createFlower = (props: ICreateFlowerProps) : SVGPathElement => {\n\n    const {\n        centerX, centerY,\n        outerRadius, innerRadius,\n    } = props;\n\n    const MIN_PETALS_NUMBER = 3;\n    const dots: [number, number][] = [];\n\n    const petalsNumber = Math.max(MIN_PETALS_NUMBER, Number(props.petalsNumber) || MIN_PETALS_NUMBER);\n    const decimalPlaces = (props.decimalPlaces === null || props.decimalPlaces === undefined) ? DEFAULT_DECIMAL_PLACES : props.decimalPlaces;\n\n    const angleDiff = 2 * Math.PI / petalsNumber;\n\n    for(let i= 0, angle= 1.5 * Math.PI; i<petalsNumber; i++, angle += angleDiff){\n\n        // inner circle\n        dots.push([\n            setDecimalPlaces(centerX + Math.cos(angle) * innerRadius, decimalPlaces),\n            setDecimalPlaces(centerY + Math.sin(angle) * innerRadius, decimalPlaces),\n        ]);\n\n        // outer circle\n        dots.push([\n            setDecimalPlaces(centerX + Math.cos(angle) * outerRadius, decimalPlaces),\n            setDecimalPlaces(centerY + Math.sin(angle) * outerRadius, decimalPlaces),\n        ]);\n    }\n\n    let d = `M ${ dots[0][0] } ${ dots[0][1] } `;\n\n    for(let i= 0; i < dots.length; i += 2){\n        const outerDot = dots[mod(i + 1, dots.length)];\n        const innerDot2 = dots[mod(i + 2, dots.length)];\n        const outerDot2 = dots[mod(i + 3, dots.length)];\n\n        d += `C ${ outerDot[0] } ${ outerDot[1] } ${ outerDot2[0] } ${ outerDot2[1] } ${ innerDot2[0] } ${ innerDot2[1] } `;\n    }\n\n    d += 'Z';\n    d = pathToRel(d) || d;\n\n    const pathProps = {\n        ...props,\n        d,\n    };\n\n    return createPath(pathProps);\n};", "import { createPath } from './primitive-shapes';\nimport { IPrimitiveShapeProps } from '../../interfaces';\n\nexport const getRectPathD = (props: {\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    rx?: number,\n    ry?: number,\n}) => {\n    const {\n        x, y,\n        width, height,\n        rx: _rx,\n        ry: _ry,\n    } = props;\n\n    const rx = _rx || 0;\n    const ry = _ry || 0;\n\n    if (rx || ry){\n\n        const w = width - 2 * rx;\n        const h = height - 2 * ry;\n\n        return `M${ x + rx } ${ y }h${ w }s${ rx } 0 ${ rx } ${ ry }v${ h }s0 ${ ry } ${ -rx } ${ ry }h${ -w }s${ -rx } 0 ${ -rx } ${ -ry }v${ -h }s0 ${ -ry } ${ rx } ${ -ry }z`;\n    }\n\n    return `M${ x } ${ y }h${ width }v${ height }h${ -width }z`;\n};\n\nexport interface ICreateRectPathProps extends IPrimitiveShapeProps{\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n    rx?: number;\n    ry?: number;\n}\n\nexport const createRectPath = (props: ICreateRectPathProps) : SVGPathElement => {\n\n    const pathProps = {\n        ...props,\n        d: getRectPathD({\n            x: props.x,\n            y: props.y,\n            width: props.width,\n            height: props.height,\n            rx: props.rx,\n            ry: props.ry,\n        }),\n    };\n\n    return createPath(pathProps);\n};", "import { createSVGFromString, getSVGAsString } from './core';\n\nconst MISSING_SVG_ERR = 'Either an SVG element or an SVG string must be provided.';\n\nconst formatExt = (ext?: string) : string => {\n    if(!ext || !ext.trim()) return 'svg';\n\n    return ext.trim().toLowerCase();\n};\n\n/**\n * Download file in browser environment.\n */\nexport const download = (props: {\n    $svg?: SVGSVGElement,\n    svgString?: string;\n    outfileName?: string;\n    ext?: string; // svg, png, jpg, jpeg\n}) => {\n    return new Promise<{\n        isError: boolean;\n        msg?: string;\n    }>((resolve, reject) => {\n        if(!props.$svg && !props.svgString){\n            reject({\n                isError: true,\n                msg: MISSING_SVG_ERR,\n            });\n            return;\n        }\n\n        const _svgString = props.$svg ? getSVGAsString(props.$svg) : props.svgString;\n        const svgString = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>${ _svgString }`;\n\n        const formattedExt = formatExt(props.ext);\n        const formattedFileName = `${ props.outfileName || 'out'}.${ formattedExt }`;\n\n        if(formattedExt === 'svg'){\n\n            const blob = new Blob([svgString], {type : 'text/plain'});\n            const url = URL.createObjectURL(blob);\n\n            const link = document.createElement('a');\n            link.href = url;\n            link.title = '';\n            link.download = formattedFileName;\n            link.click();\n\n            URL.revokeObjectURL(url);\n            resolve({\n                isError: false,\n            });\n        }\n        else{\n            const $svg = props.$svg || createSVGFromString({\n                svg: props.svgString || '',\n            });\n\n            const $canvas = document.createElement('canvas');\n            $canvas.width = $svg.width.baseVal.value;\n            $canvas.height = $svg.height.baseVal.value;\n\n            const ctx = $canvas.getContext('2d');\n            if(!ctx){\n                reject({\n                    isError: true,\n                });\n                return;\n            }\n\n            const data = (new XMLSerializer()).serializeToString($svg);\n            const blob = new Blob([data], {type: 'image/svg+xml;charset=utf-8'});\n            const url = URL.createObjectURL(blob);\n\n            const $img = new Image();\n            $img.onload = () => {\n                ctx.clearRect(0, 0, $canvas.width, $canvas.height);\n                ctx.drawImage($img, 0, 0);\n\n                URL.revokeObjectURL(url);\n\n                $canvas.toBlob(cBlob => {\n\n                    if(!cBlob){\n                        resolve({\n                            isError: true,\n                        });\n                        return;\n                    }\n\n                    const cUrl = URL.createObjectURL(cBlob);\n                    const link = document.createElement('a');\n                    link.href = cUrl;\n                    link.title = '';\n                    link.download = formattedFileName;\n                    link.click();\n\n                    URL.revokeObjectURL(cUrl);\n\n                    resolve({\n                        isError: false,\n                    });\n                });\n            };\n\n            $img.onerror = () => {\n                resolve({\n                    isError: true,\n                });\n            };\n\n            $img.src = url;\n        }\n    });\n};", "import { getCommonAttributes, setAttributes, SVG_NAMESPACE } from './core';\nimport { IPrimitiveShapeProps } from '../interfaces';\n\nexport interface ICreateGroupProps extends IPrimitiveShapeProps{\n    x?: number|string;\n    y?: number|string;\n    width?: number|string;\n    height?: number|string;\n}\n\nexport const createGroup = (props?: ICreateGroupProps) : SVGGElement => {\n    const doc = props?.document || window.document;\n    const $g = doc.createElementNS(SVG_NAMESPACE, 'g');\n\n    setAttributes($g, [\n        ...getCommonAttributes(props),\n    ]);\n\n    return $g;\n};\n\nexport const createDefs = (props?: {\n    document?: Document;\n    id?: string;\n    classes?: string;\n}) : SVGDefsElement => {\n    const doc = props?.document || window.document;\n    const $defs = doc.createElementNS(SVG_NAMESPACE, 'defs');\n\n    setAttributes($defs, [\n        ['id', props?.id],\n        ['class', props?.classes],\n    ]);\n\n    return $defs;\n};\n\nexport interface ICreateUseProps extends IPrimitiveShapeProps{\n    href?: string;\n    x?: number|string;\n    y?: number|string;\n    width?: number|string;\n    height?: number|string;\n}\n\nexport const createUse = (props?: ICreateUseProps) : SVGUseElement => {\n\n    const doc = props?.document || window.document;\n    const $use = doc.createElementNS(SVG_NAMESPACE, 'use');\n\n    setAttributes($use, [\n        ['href', props?.href],\n        ['x', props?.x],\n        ['y', props?.y],\n        ['width', props?.width],\n        ['height', props?.height],\n        ...getCommonAttributes(props),\n    ]);\n\n    return $use;\n};\n\nexport interface ICreatePatternProps extends IPrimitiveShapeProps{\n    x?: string|number;\n    y?: string|number;\n    width?: string|number;\n    height?: string|number;\n\n    href?: string;\n    patternContentUnits?: string|number;\n    patternTransform?: string;\n    patternUnits?: string;\n    preserveAspectRatio?: string;\n    viewBox?: string;\n}\n\nexport const createPattern = (props?: ICreatePatternProps) : SVGPatternElement => {\n    const doc = props?.document || window.document;\n    const $pattern = doc.createElementNS(SVG_NAMESPACE, 'pattern');\n\n    setAttributes($pattern, [\n        ['x', props?.x],\n        ['y', props?.y],\n        ['width', props?.width],\n        ['height', props?.height],\n\n        ['href', props?.href],\n        ['patternContentUnits', props?.patternContentUnits],\n        ['patternTransform', props?.patternTransform],\n        ['patternUnits', props?.patternUnits],\n        ['preserveAspectRatio', props?.preserveAspectRatio],\n        ['viewBox', props?.viewBox],\n\n        ...getCommonAttributes(props),\n    ]);\n\n    return $pattern;\n};\n\nexport interface ICreateClipPathProps extends IPrimitiveShapeProps{\n    clipPathUnits?: string;\n}\n\nexport const createClipPath = (props?: ICreateClipPathProps) : SVGClipPathElement => {\n\n    const doc = props?.document || window.document;\n    const $clipPath = doc.createElementNS(SVG_NAMESPACE, 'clipPath');\n\n    setAttributes($clipPath, [\n        ['clipPathUnits', props?.clipPathUnits],\n        ...getCommonAttributes(props),\n    ]);\n\n    return $clipPath;\n};\n\nexport interface ICreateMaskProps extends IPrimitiveShapeProps{\n    x?: number|string;\n    y?: number|string;\n    width?: number|string;\n    height?: number|string;\n    maskContentUnits?: string;\n    maskUnits?: string;\n}\n\nexport const createMask = (props?: ICreateMaskProps) : SVGMaskElement => {\n\n    const doc = props?.document || window.document;\n    const $mask = doc.createElementNS(SVG_NAMESPACE, 'mask');\n\n    setAttributes($mask, [\n        ['x', props?.x],\n        ['y', props?.y],\n        ['width', props?.width],\n        ['height', props?.height],\n        ['maskContentUnits', props?.maskContentUnits],\n        ['maskUnits', props?.maskUnits],\n        ...getCommonAttributes(props),\n    ]);\n\n    return $mask;\n};\n\nexport interface ICreateSymbolProps extends IPrimitiveShapeProps{\n    x?: number|string;\n    y?: number|string;\n    width?: number|string;\n    height?: number|string;\n    preserveAspectRatio?: string;\n    refX?: number|string;\n    refY?: number|string;\n    viewBox?: string;\n}\n\nexport const createSymbol = (props?: ICreateSymbolProps) : SVGSymbolElement => {\n\n    const doc = props?.document || window.document;\n    const $symbol = doc.createElementNS(SVG_NAMESPACE, 'symbol');\n\n    setAttributes($symbol, [\n        ['x', props?.x],\n        ['y', props?.y],\n        ['width', props?.width],\n        ['height', props?.height],\n\n        ['preserveAspectRatio', props?.preserveAspectRatio],\n        ['refX', props?.refX],\n        ['refY', props?.refY],\n        ['viewBox', props?.viewBox],\n\n        ...getCommonAttributes(props),\n    ]);\n\n    return $symbol;\n};", "export const appendOnce = ($parent: SVGSVGElement|SVGElement, $el: SVGElement) => {\n    const tagName = $el.tagName.toLowerCase().trim();\n    if($parent.querySelector(tagName)) return;\n\n    $parent.append($el);\n};\n\nexport const prependOnce = ($parent: SVGSVGElement|SVGElement, $el: SVGElement) => {\n    const tagName = $el.tagName.toLowerCase().trim();\n    if($parent.querySelector(tagName)) return;\n\n    $parent.prepend($el);\n};", "import { parsePath } from './index';\nimport { maximizeAbsolutePath, pathDataToAbsolute } from './convert';\nimport { EPathDataCommand } from './interfaces';\nimport {\n    degreesToRadians,\n    Matrix2, mMulVector,\n    setDecimalPlaces,\n    v2CubicBezierBBox, v2MulScalar,\n    v2QuadraticBezierBBox, v2Sum,\n    Vector2\n} from 'mz-math';\n\nexport interface IBBox {\n    x: number;\n    y: number;\n    w: number;\n    h: number;\n    x2: number;\n    y2: number;\n}\n\n/**\n * https://www.w3.org/TR/SVG11/implnote.html#ArcConversionEndpointToCenter\n */\nexport const getSVGArcCenter = (\n    startX: number,\n    startY: number,\n    rx: number,\n    ry: number,\n    angleRad: number,\n    largeArcFlag: number,\n    sweepFlag: number,\n    endX: number,\n    endY: number\n) : Vector2 | null => {\n    // rx ry x-axis-rotation large-arc-flag sweep-flag x y\n\n    // F.6.5: Step 1 ---------------------------------------\n    const cos = Math.cos(angleRad);\n    const sin = Math.sin(angleRad);\n\n    const rotationMatrix: Matrix2 = [\n        [cos, -sin],\n        [sin, cos],\n    ];\n    const posVector1: Vector2 = [\n        (startX - endX) / 2,\n        (startY - endY) / 2,\n    ];\n\n    // Compute (x1\u2032, y1\u2032)\n    const posVector2 = mMulVector(rotationMatrix, posVector1);\n\n    // F.6.5: Step 2 ---------------------------------------\n    const rx2 = rx ** 2;\n    const ry2 = ry ** 2;\n    const posx2 = posVector2[0] ** 2;\n    const posy2 = posVector2[1] ** 2;\n\n    const t1 = rx2 * ry2 - rx2 * posy2 - ry2 * posx2;\n    const t2 = rx2 * posy2 + ry2 * posx2;\n    if(t2 === 0) return null;\n\n    const t3 = t1 / t2;\n    if(t3 < 0) return null;\n\n    let t4 = Math.sqrt(t3);\n\n    const posVector3: Vector2 = [\n        rx * posVector2[1] / ry,\n        -ry *  posVector2[0] / rx,\n    ];\n\n    if(largeArcFlag === sweepFlag){\n        t4 = -t4;\n    }\n\n    const centerVector1: Vector2 = v2MulScalar(posVector3, t4);\n\n    // F.6.5: Step 3 ---------------------------------------\n    const rotationMatrix2: Matrix2 = [\n        [cos, sin],\n        [-sin, cos],\n    ];\n\n    const centerVector2: Vector2 = mMulVector(rotationMatrix2, centerVector1) as Vector2;\n    const posVector4: Vector2 = [\n        (startX + endX) / 2,\n        (startY + endY) / 2,\n    ];\n\n    return v2Sum(centerVector2, posVector4);\n};\n\nconst getAngle = (bx: number, by: number): number => {\n    const PI2 = 2 * Math.PI;\n    const t1 = by > 0 ? 1 : -1;\n    return ((PI2 + t1 * Math.acos(bx / Math.sqrt(bx * bx + by * by))) % PI2);\n};\n\nconst formatBBox = (xmin: number, xmax: number, ymin: number, ymax: number) : IBBox => {\n    return {\n        x: xmin,\n        y: ymin,\n        w: Math.abs(ymax - ymin),\n        h: Math.abs(xmax - xmin),\n        x2: xmax,\n        y2: ymax,\n    };\n};\n\nconst getArcBoundingBox = (\n    x1: number, y1: number,\n    rx: number, ry: number,\n    angleRad: number, largeArc: boolean,\n    sweep: boolean,\n    x2: number, y2: number\n) : IBBox => {\n\n    let xmin, xmax, ymin, ymax;\n\n    /*const center = getSVGArcCenter(\n        x1,\n        y1,\n        rx,\n        ry,\n        angleRad,\nlargeArc ? 1 : 0,\nsweep ? 1 : 0,\n        x2,\n        y2\n    );\n    if(!center) return formatBBox(0, 0, 0, 0);\n\n    const cx = center[0];\n    const cy = center[1];\n    */\n\n    if (rx < 0) {\n        rx *= -1;\n    }\n\n    if (ry < 0) {\n        ry *= -1;\n    }\n\n    if (rx === 0 || ry === 0) {\n        xmin = x1 < x2 ? x1 : x2;\n        xmax = x1 > x2 ? x1 : x2;\n        ymin = y1 < y2 ? y1 : y2;\n        ymax = y1 > y2 ? y1 : y2;\n\n        return formatBBox(xmin, xmax, ymin, ymax);\n    }\n\n    const x1prime: number = Math.cos(angleRad) * (x1 - x2) / 2 + Math.sin(angleRad) * (y1 - y2) / 2;\n    const y1prime: number = -Math.sin(angleRad) * (x1 - x2) / 2 + Math.cos(angleRad) * (y1 - y2) / 2;\n\n    let radicant: number = (rx * rx * ry * ry - rx * rx * y1prime * y1prime - ry * ry * x1prime * x1prime);\n    radicant /= (rx * rx * y1prime * y1prime + ry * ry * x1prime * x1prime);\n\n    let cxPrime = 0;\n    let cyPrime = 0;\n\n    if (radicant < 0) {\n        const ratio: number = rx / ry;\n        radicant = y1prime * y1prime + x1prime * x1prime / (ratio * ratio);\n        if (radicant < 0) {\n            xmin = (x1 < x2 ? x1 : x2);\n            xmax = (x1 > x2 ? x1 : x2);\n            ymin = (y1 < y2 ? y1 : y2);\n            ymax = (y1 > y2 ? y1 : y2);\n\n            return formatBBox(xmin, xmax, ymin, ymax);\n        }\n        ry = Math.sqrt(radicant);\n        rx = ratio * ry;\n    }\n    else {\n        const factor = (largeArc == sweep ? -1 : 1) * Math.sqrt(radicant);\n        cxPrime = factor * rx * y1prime / ry;\n        cyPrime = -factor * ry * x1prime / rx;\n    }\n\n    const cx = cxPrime * Math.cos(angleRad) - cyPrime * Math.sin(angleRad) + (x1 + x2) / 2;\n    const cy = cxPrime * Math.sin(angleRad) + cyPrime * Math.cos(angleRad) + (y1 + y2) / 2;\n\n\n\n    let txMin: number, txMax: number, tyMin: number, tyMax: number;\n\n    if (angleRad === 0 || angleRad === Math.PI) {\n        xmin = cx - rx;\n        txMin = getAngle(-rx, 0);\n        xmax = cx + rx;\n        txMax = getAngle(rx, 0);\n        ymin = cy - ry;\n        tyMin = getAngle(0, -ry);\n        ymax = cy + ry;\n        tyMax = getAngle(0, ry);\n    }\n    else if (angleRad === Math.PI / 2 || angleRad === 3.0 * Math.PI / 2) {\n        xmin = cx - ry;\n        txMin = getAngle(-ry, 0);\n        xmax = cx + ry;\n        txMax = getAngle(ry, 0);\n        ymin = cy - rx;\n        tyMin = getAngle(0, -rx);\n        ymax = cy + rx;\n        tyMax = getAngle(0, rx);\n    }\n    else {\n        txMin = -Math.atan(ry * Math.tan(angleRad) / rx);\n        txMax = Math.PI - Math.atan(ry * Math.tan(angleRad) / rx);\n\n        xmin = cx + rx * Math.cos(txMax) * Math.cos(angleRad) - ry * Math.sin(txMin) * Math.sin(angleRad);\n        xmax = cx + rx * Math.cos(txMax) * Math.cos(angleRad) - ry * Math.sin(txMax) * Math.sin(angleRad);\n\n        // swap ------------------------\n        if (xmin > xmax) {\n            [xmin, xmax] = [xmax, xmin];\n            [txMin, txMax] = [txMax, txMin];\n        }\n\n        let tmpY = cy + rx * Math.cos(txMin) * Math.sin(angleRad) + ry * Math.sin(txMin) * Math.cos(angleRad);\n        txMin = getAngle(xmin - cx, tmpY - cy);\n        tmpY = cy + rx * Math.cos(txMax) * Math.sin(angleRad) + ry * Math.sin(txMax) * Math.cos(angleRad);\n        txMax = getAngle(xmax - cx, tmpY - cy);\n\n        tyMin = Math.atan(ry / (Math.tan(angleRad) * rx));\n        tyMax = Math.atan(ry / (Math.tan(angleRad) * rx)) + Math.PI;\n        ymin = cy + rx * Math.cos(tyMin) * Math.sin(angleRad) + ry * Math.sin(tyMin) * Math.cos(angleRad);\n        ymax = cy + rx * Math.cos(tyMax) * Math.sin(angleRad) + ry * Math.sin(tyMax) * Math.cos(angleRad);\n\n        // swap ------------------------\n        if (ymin > ymax) {\n            [ymin, ymax] = [ymax, ymin];\n            [tyMin, tyMax] = [tyMax, tyMin];\n        }\n\n        let tmpX = cx + rx * Math.cos(tyMin) * Math.cos(angleRad) - ry * Math.sin(tyMin) * Math.sin(angleRad);\n        tyMin = getAngle(tmpX - cx, ymin - cy);\n        tmpX = cx + rx * Math.cos(tyMax) * Math.cos(angleRad) - ry * Math.sin(tyMax) * Math.sin(angleRad);\n        tyMax = getAngle(tmpX - cx, ymax - cy);\n    }\n\n    let angle1 = getAngle(x1 - cx, y1 - cy);\n    let angle2 = getAngle(x2 - cx, y2 - cy);\n\n    if (!sweep){\n        [angle1, angle2] = [angle2, angle1];\n    }\n\n    let otherArc = false;\n\n    if (angle1 > angle2) {\n        // swap ------------------------\n        [angle1, angle2] = [angle2, angle1];\n        otherArc = true;\n    }\n\n    if ((!otherArc && (angle1 > txMin || angle2 < txMin)) || (otherArc && !(angle1 > txMin || angle2 < txMin))) {\n        xmin = Math.min(x1, x2);\n    }\n\n    if ((!otherArc && (angle1 > txMax || angle2 < txMax)) || (otherArc && !(angle1 > txMax || angle2 < txMax))) {\n        xmax = Math.max(x1, x2);\n    }\n\n    if ((!otherArc && (angle1 > tyMin || angle2 < tyMin)) || (otherArc && !(angle1 > tyMin || angle2 < tyMin))) {\n        ymin = Math.min(y1, y2);\n    }\n\n    if ((!otherArc && (angle1 > tyMax || angle2 < tyMax)) || (otherArc && !(angle1 > tyMax || angle2 < tyMax))) {\n        ymax = Math.max(y1, y2);\n    }\n\n    return formatBBox(xmin, xmax, ymin, ymax);\n}\n\n/**\n * Determine the coordinates of the smallest rectangle in which the path fits.\n */\nexport const getPathBBox = (d?: string, decimalPlaces = 2) : IBBox|null => {\n    if(!d || d.trim() === '') return null;\n\n    const parsed = parsePath(d);\n    if(parsed.errors.length > 0) return null;\n\n    const abs = pathDataToAbsolute(parsed);\n    if(!abs || abs.commands.length <= 0) return null;\n\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n\n    const max = maximizeAbsolutePath(abs);\n\n    // current (x, y) pair\n    let x = max.commands[0].params[0];\n    let y = max.commands[0].params[1];\n\n    // the latest 'M' coordinates\n    let mx = x;\n    let my = y;\n\n    for(const item of max.commands) {\n\n        switch (item.command){\n            case EPathDataCommand.MoveToAbs: {\n                minX = Math.min(minX, item.params[0]);\n                minY = Math.min(minY, item.params[1]);\n\n                maxX = Math.max(maxX, item.params[0]);\n                maxY = Math.max(maxY, item.params[1]);\n\n                mx = item.params[0];\n                my = item.params[1];\n                break;\n            }\n\n            case EPathDataCommand.ClosePathAbs:{\n                x = mx;\n                y = my;\n                break;\n            }\n\n            case EPathDataCommand.LineToAbs:{\n                minX = Math.min(minX, item.params[0]);\n                minY = Math.min(minY, item.params[1]);\n\n                maxX = Math.max(maxX, item.params[0]);\n                maxY = Math.max(maxY, item.params[1]);\n\n                x = item.params[0];\n                y = item.params[1];\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToAbs:{\n                const startControlPoint: Vector2 = [x, y];\n                const centerControlPoint1: Vector2 = [item.params[0], item.params[1]];\n                const centerControlPoint2: Vector2 = [item.params[2], item.params[3]];\n                const endControlPoint: Vector2 = [item.params[4], item.params[5]];\n                const bbox = v2CubicBezierBBox(startControlPoint, centerControlPoint1, centerControlPoint2, endControlPoint);\n\n                minX = Math.min(minX, bbox.x);\n                minY = Math.min(minY, bbox.y);\n\n                maxX = Math.max(maxX, bbox.x2);\n                maxY = Math.max(maxY, bbox.y2);\n\n                x = item.params[4];\n                y = item.params[5];\n                break;\n            }\n\n            case EPathDataCommand.QuadraticCurveToAbs:{\n                const startControlPoint: Vector2 = [x, y];\n                const centerControlPoint: Vector2 = [item.params[0], item.params[1]];\n                const endControlPoint: Vector2 = [item.params[2], item.params[3]];\n\n                const bbox = v2QuadraticBezierBBox(startControlPoint, centerControlPoint, endControlPoint);\n\n                minX = Math.min(minX, bbox.x);\n                minY = Math.min(minY, bbox.y);\n\n                maxX = Math.max(maxX, bbox.x2);\n                maxY = Math.max(maxY, bbox.y2);\n\n                x = item.params[2];\n                y = item.params[3];\n\n                break;\n            }\n\n            case EPathDataCommand.ArcAbs:{\n                // rx ry x-axis-rotation large-arc-flag sweep-flag x y\n                const rx = item.params[0];\n                const ry = item.params[1];\n                const angleDeg = item.params[2];\n                const largeArcFlag = item.params[3];\n                const sweepFlag = item.params[4];\n                const endX = item.params[5];\n                const endY = item.params[6];\n\n                //const arcCenter = getSVGArcCenter(x, y, rx, ry, angleDeg, largeArcFlag, sweepFlag, endX, endY);\n                //console.log('arcCenter', arcCenter)\n\n                const bbox = getArcBoundingBox(x, y, rx, ry, degreesToRadians(angleDeg), largeArcFlag === 1, sweepFlag === 1, endX, endY);\n\n                minX = Math.min(minX, bbox?.x ?? 0);\n                minY = Math.min(minY, bbox?.y ?? 0);\n\n                maxX = Math.max(maxX, bbox?.x2 ?? 0);\n                maxY = Math.max(maxY, bbox?.y2 ?? 0);\n\n                x = item.params[5];\n                y = item.params[6];\n                break;\n            }\n        }\n    }\n\n    return {\n        x: setDecimalPlaces(minX, decimalPlaces),\n        y: setDecimalPlaces(minY, decimalPlaces),\n        w: setDecimalPlaces(Math.abs(maxX - minX), decimalPlaces),\n        h: setDecimalPlaces(Math.abs(maxY - minY), decimalPlaces),\n        x2: setDecimalPlaces(maxX, decimalPlaces),\n        y2: setDecimalPlaces(maxY, decimalPlaces),\n    };\n};", "import { parsePath } from './index';\nimport { maximizeAbsolutePath, pathDataToAbsolute, pathDataToRelative, pathDataToString } from './convert';\nimport { Vector3, m2RotateAroundPointH, degreesToRadians, Vector2, m2ScaleAtPointH } from 'mz-math';\nimport { EPathDataCommand } from './interfaces';\nimport { getPathBBox } from './bbox';\n\n// ---------------------- TRANSLATE ----------------------\n\nexport const translatePath = (d: string, x: number, y: number, decimalPlaces = 2) => {\n    if(!d) return d;\n\n    const parsed = parsePath(d);\n    if(parsed.errors.length > 0) return d;\n\n    const relative = pathDataToRelative(parsed);\n    if(!relative || relative.commands.length <= 0) return d;\n\n    const mCommand = relative.commands[0];\n    mCommand.params[0] = x;\n    mCommand.params[1] = y;\n\n    return pathDataToString(relative, true, decimalPlaces);\n};\n\n// ---------------------- ROTATE -------------------------\n\nconst rotateDot = (point: Vector2, transformOrigin: Vector2, angleRad: number, decimalPlaces = 2) => {\n    return m2RotateAroundPointH(\n        angleRad,\n        [transformOrigin[0], transformOrigin[1], 1],\n        [point[0], point[1], 1],\n        true,\n        decimalPlaces\n    );\n};\n\nexport const rotatePathAroundPoint = (d: string, transformOrigin: Vector2, angleDegrees: number, decimalPlaces = 2) => {\n    if(!d) return d;\n\n    const parsed = parsePath(d);\n    if(parsed.errors.length > 0) return d;\n\n    const abs = pathDataToAbsolute(parsed);\n    if(!abs || abs.commands.length <= 0) return d;\n\n    const angleRad = degreesToRadians(angleDegrees, decimalPlaces);\n\n    const max = maximizeAbsolutePath(abs);\n    for(const item of max.commands){\n\n        switch(item.command){\n\n            case EPathDataCommand.MoveToAbs:\n            case EPathDataCommand.LineToAbs:{\n                // 2 params (x, y)\n\n                // get the new position after rotation\n                const pos: Vector3 = rotateDot([item.params[0], item.params[1]], transformOrigin, angleRad, decimalPlaces);\n                item.params[0] = pos[0];\n                item.params[1] = pos[1];\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToAbs:{\n                // 6 parameters\n                const pos1: Vector3 = rotateDot([item.params[0], item.params[1]], transformOrigin, angleRad, decimalPlaces);\n                item.params[0] = pos1[0];\n                item.params[1] = pos1[1];\n\n                const pos2: Vector3 = rotateDot([item.params[2], item.params[3]], transformOrigin, angleRad, decimalPlaces);\n                item.params[2] = pos2[0];\n                item.params[3] = pos2[1];\n\n                const pos3: Vector3 = rotateDot([item.params[4], item.params[5]], transformOrigin, angleRad, decimalPlaces);\n                item.params[4] = pos3[0];\n                item.params[5] = pos3[1];\n                break;\n            }\n\n            case EPathDataCommand.QuadraticCurveToAbs:{\n                // 4 parameters\n                const pos1: Vector3 = rotateDot([item.params[0], item.params[1]], transformOrigin, angleRad, decimalPlaces);\n                item.params[0] = pos1[0];\n                item.params[1] = pos1[1];\n\n                const pos2: Vector3 = rotateDot([item.params[2], item.params[3]], transformOrigin, angleRad, decimalPlaces);\n                item.params[2] = pos2[0];\n                item.params[3] = pos2[1];\n                break;\n            }\n\n            case EPathDataCommand.ArcAbs:{\n                // rx ry x-axis-rotation large-arc-flag sweep-flag x y\n                /*const pos1: Vector3 = rotateDot(item.params[0], item.params[1], cx, cy, angleRad, decimalPlaces);\n                item.params[0] = pos1[0];\n                item.params[1] = pos1[1];*/\n\n                const pos2: Vector3 = rotateDot([item.params[5], item.params[6]], transformOrigin, angleRad, decimalPlaces);\n                item.params[5] = pos2[0];\n                item.params[6] = pos2[1];\n                break;\n            }\n        }\n    }\n\n    const rel = pathDataToRelative(abs);\n    return pathDataToString(rel, true, decimalPlaces);\n};\n\nexport const rotatePath = (d: string, angleDegrees: number, decimalPlaces = 2) => {\n\n    const bbox = getPathBBox(d);\n\n    const x = bbox?.x ?? 0;\n    const y = bbox?.y ?? 0;\n    const w = bbox?.w ?? 0;\n    const h = bbox?.h ?? 0;\n\n    const cx = x + w / 2;\n    const cy = y + h / 2;\n\n    return rotatePathAroundPoint(d, [cx, cy], angleDegrees, decimalPlaces);\n};\n\n// ---------------------- SCALE --------------------------\n\nconst scaleDot = (point: Vector2, scaleVector: Vector2, transformOrigin: Vector2, decimalPlaces = 2) => {\n    return m2ScaleAtPointH(\n        [scaleVector[0], scaleVector[1], 1],\n        [transformOrigin[0], transformOrigin[1], 1],\n        [point[0], point[1], 1],\n        decimalPlaces\n    );\n};\n\nexport const scalePathAroundPoint = (d: string, scaleVector: Vector2, transformOrigin: Vector2, decimalPlaces = 2) => {\n    if(!d) return d;\n\n    const parsed = parsePath(d);\n    if(parsed.errors.length > 0) return d;\n\n    const abs = pathDataToAbsolute(parsed);\n    if(!abs || abs.commands.length <= 0) return d;\n\n    const max = maximizeAbsolutePath(abs);\n    for(const item of max.commands){\n\n        switch(item.command){\n\n            case EPathDataCommand.MoveToAbs:\n            case EPathDataCommand.LineToAbs:{\n                // 2 params (x, y)\n\n                const pos: Vector3 = scaleDot(\n                    [item.params[0], item.params[1]],\n                    scaleVector,\n                    transformOrigin,\n                    decimalPlaces\n                );\n\n                item.params[0] = pos[0];\n                item.params[1] = pos[1];\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToAbs:{\n                // 6 parameters\n                const pos1: Vector3 = scaleDot(\n                    [item.params[0], item.params[1]],\n                    scaleVector,\n                    transformOrigin,\n                    decimalPlaces\n                );\n                item.params[0] = pos1[0];\n                item.params[1] = pos1[1];\n\n                const pos2: Vector3 = scaleDot(\n                    [item.params[2], item.params[3]],\n                    scaleVector,\n                    transformOrigin,\n                    decimalPlaces\n                );\n                item.params[2] = pos2[0];\n                item.params[3] = pos2[1];\n\n                const pos3: Vector3 = scaleDot(\n                    [item.params[4], item.params[5]],\n                    scaleVector,\n                    transformOrigin,\n                    decimalPlaces\n                );\n                item.params[4] = pos3[0];\n                item.params[5] = pos3[1];\n                break;\n            }\n\n            case EPathDataCommand.QuadraticCurveToAbs:{\n                // 4 parameters\n                const pos1: Vector3 = scaleDot(\n                    [item.params[0], item.params[1]],\n                    scaleVector,\n                    transformOrigin,\n                    decimalPlaces\n                );\n                item.params[0] = pos1[0];\n                item.params[1] = pos1[1];\n\n                const pos2: Vector3 = scaleDot(\n                    [item.params[2], item.params[3]],\n                    scaleVector,\n                    transformOrigin,\n                    decimalPlaces\n                );\n                item.params[2] = pos2[0];\n                item.params[3] = pos2[1];\n                break;\n            }\n\n            case EPathDataCommand.ArcAbs:{\n                // rx ry x-axis-rotation large-arc-flag sweep-flag x y\n                /*\n                const pos1: Vector3 = scaleDot(\n                    [item.params[0], item.params[1]],\n                    scaleVector,\n                    transformOrigin,\n                    decimalPlaces\n                );\n                item.params[0] = pos1[0];\n                item.params[1] = pos1[1];*/\n\n                const pos2: Vector3 = scaleDot(\n                    [item.params[5], item.params[6]],\n                    scaleVector,\n                    transformOrigin,\n                    decimalPlaces\n                );\n                item.params[5] = pos2[0];\n                item.params[6] = pos2[1];\n                break;\n            }\n        }\n    }\n\n    //const rel = pathDataToRelative(abs);\n    return pathDataToString(abs, false, decimalPlaces);\n};\n\nexport const scalePath = (d: string, scaleVector: Vector2, decimalPlaces = 2) => {\n\n    const bbox = getPathBBox(d);\n\n    const x = bbox?.x ?? 0;\n    const y = bbox?.y ?? 0;\n    const w = bbox?.w ?? 0;\n    const h = bbox?.h ?? 0;\n\n    const cx = x + w / 2;\n    const cy = y + h / 2;\n\n    return scalePathAroundPoint(d, scaleVector, [cx, cy], decimalPlaces);\n};", "import { setAttributes, SVG_NAMESPACE } from '../core';\n\nexport interface IAnimationProps{\n    document?: Document;\n\n    id?: string;\n    classes?: string;\n    style?: string;\n\n    // Animation timing attributes\n    begin?: string;\n    dur?: string;\n    end?: string;\n    min?: string;\n    max?: string;\n    restart?: string;\n    repeatCount?: number|string;\n    repeatDur?: string;\n    fill?: string;\n\n    // Animation value attributes\n    calcMode?: string;\n    values?: string;\n    keyTimes?: string;\n    keySplines?: string;\n    from?: number|string;\n    to?: number|string;\n    by?: number|string;\n\n    // Other Animation attributes\n    attributeName?: string;\n    additive?: string;\n    accumulate?: string;\n}\n\nexport const getCommonAnimationAttributes = (props?: IAnimationProps) : [string, string|number|undefined][] => {\n\n    if(!props) return [];\n\n    return [\n        ['id', props?.id],\n        ['class', props?.classes],\n        ['style', props?.style],\n\n        // Animation timing attributes\n        ['begin', props?.begin],\n        ['dur', props?.dur],\n        ['end', props?.end],\n        ['min', props?.min],\n        ['max', props?.max],\n        ['restart', props?.restart],\n        ['repeatCount', props?.repeatCount],\n        ['repeatDur', props?.repeatDur],\n        ['fill', props?.fill],\n\n        // Animation value attributes\n        ['calcMode', props?.calcMode],\n        ['values', props?.values],\n        ['keyTimes', props?.keyTimes],\n        ['keySplines', props?.keySplines],\n        ['from', props?.from],\n        ['to', props?.to],\n        ['by', props?.by],\n\n        // Other Animation attributes\n        ['attributeName', props?.attributeName],\n        ['additive', props?.additive],\n        ['accumulate', props?.accumulate],\n    ];\n};\n\n/**\n * Create <animate> element.\n */\nexport const createAnimate = (props?: IAnimationProps) : SVGAnimateElement => {\n\n    const doc = props?.document || window.document;\n\n    const $animate = doc.createElementNS(SVG_NAMESPACE, 'animate');\n\n    setAttributes($animate, [\n        ...getCommonAnimationAttributes(props),\n    ]);\n\n    return $animate;\n};\n\nexport interface ICreateAnimateMotionProps extends IAnimationProps{\n    keyPoints?: string;\n    path?: string|number;\n    rotate?: string|number;\n}\n\n/**\n * Create <animateMotion> element.\n */\nexport const createAnimateMotion = (props?: ICreateAnimateMotionProps) : SVGAnimateMotionElement => {\n\n    const doc = props?.document || window.document;\n\n    const $animateMotion = doc.createElementNS(SVG_NAMESPACE, 'animateMotion');\n\n    setAttributes($animateMotion, [\n        ['keyPoints', props?.keyPoints],\n        ['path', props?.path],\n        ['rotate', props?.rotate],\n        ...getCommonAnimationAttributes(props),\n    ]);\n\n    return $animateMotion;\n};\n\nexport interface ICreateAnimateTransformProps extends IAnimationProps{\n    type?: string;\n    attributeType?: string;\n}\n\n/**\n * Create <animateTransform> element.\n */\nexport const createAnimateTransform = (props?: ICreateAnimateTransformProps) : SVGAnimateTransformElement => {\n\n    const doc = props?.document || window.document;\n\n    const $animateTransform = doc.createElementNS(SVG_NAMESPACE, 'animateTransform');\n\n    setAttributes($animateTransform, [\n        ['type', props?.type],\n        ['attributeType', props?.attributeType],\n        ...getCommonAnimationAttributes(props),\n    ]);\n\n    return $animateTransform;\n};\n\nexport interface ICreateMPathProps{\n    document?: Document;\n\n    id?: string;\n    classes?: string;\n    xlinkHref?: string\n}\n\n/**\n * Create <mpath> element.\n */\nexport const createMPath = (props?: ICreateMPathProps) : SVGMPathElement => {\n\n    const doc = props?.document || window.document;\n\n    const $mpath = doc.createElementNS(SVG_NAMESPACE, 'mpath');\n\n    setAttributes($mpath, [\n        ['id', props?.id],\n        ['class', props?.classes],\n        ['xlink:href', props?.xlinkHref],\n    ]);\n\n    return $mpath;\n};", "// This file is autogenerated. It's used to publish ESM to npm.\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\n\n// https://github.com/bgrins/TinyColor\n// Brian Grinstead, MIT License\n\nvar trimLeft = /^\\s+/;\nvar trimRight = /\\s+$/;\nfunction tinycolor(color, opts) {\n  color = color ? color : \"\";\n  opts = opts || {};\n\n  // If input is already a tinycolor, return itself\n  if (color instanceof tinycolor) {\n    return color;\n  }\n  // If we are called as a function, call using new instead\n  if (!(this instanceof tinycolor)) {\n    return new tinycolor(color, opts);\n  }\n  var rgb = inputToRGB(color);\n  this._originalInput = color, this._r = rgb.r, this._g = rgb.g, this._b = rgb.b, this._a = rgb.a, this._roundA = Math.round(100 * this._a) / 100, this._format = opts.format || rgb.format;\n  this._gradientType = opts.gradientType;\n\n  // Don't let the range of [0,255] come back in [0,1].\n  // Potentially lose a little bit of precision here, but will fix issues where\n  // .5 gets interpreted as half of the total, instead of half of 1\n  // If it was supposed to be 128, this was already taken care of by `inputToRgb`\n  if (this._r < 1) this._r = Math.round(this._r);\n  if (this._g < 1) this._g = Math.round(this._g);\n  if (this._b < 1) this._b = Math.round(this._b);\n  this._ok = rgb.ok;\n}\ntinycolor.prototype = {\n  isDark: function isDark() {\n    return this.getBrightness() < 128;\n  },\n  isLight: function isLight() {\n    return !this.isDark();\n  },\n  isValid: function isValid() {\n    return this._ok;\n  },\n  getOriginalInput: function getOriginalInput() {\n    return this._originalInput;\n  },\n  getFormat: function getFormat() {\n    return this._format;\n  },\n  getAlpha: function getAlpha() {\n    return this._a;\n  },\n  getBrightness: function getBrightness() {\n    //http://www.w3.org/TR/AERT#color-contrast\n    var rgb = this.toRgb();\n    return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;\n  },\n  getLuminance: function getLuminance() {\n    //http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef\n    var rgb = this.toRgb();\n    var RsRGB, GsRGB, BsRGB, R, G, B;\n    RsRGB = rgb.r / 255;\n    GsRGB = rgb.g / 255;\n    BsRGB = rgb.b / 255;\n    if (RsRGB <= 0.03928) R = RsRGB / 12.92;else R = Math.pow((RsRGB + 0.055) / 1.055, 2.4);\n    if (GsRGB <= 0.03928) G = GsRGB / 12.92;else G = Math.pow((GsRGB + 0.055) / 1.055, 2.4);\n    if (BsRGB <= 0.03928) B = BsRGB / 12.92;else B = Math.pow((BsRGB + 0.055) / 1.055, 2.4);\n    return 0.2126 * R + 0.7152 * G + 0.0722 * B;\n  },\n  setAlpha: function setAlpha(value) {\n    this._a = boundAlpha(value);\n    this._roundA = Math.round(100 * this._a) / 100;\n    return this;\n  },\n  toHsv: function toHsv() {\n    var hsv = rgbToHsv(this._r, this._g, this._b);\n    return {\n      h: hsv.h * 360,\n      s: hsv.s,\n      v: hsv.v,\n      a: this._a\n    };\n  },\n  toHsvString: function toHsvString() {\n    var hsv = rgbToHsv(this._r, this._g, this._b);\n    var h = Math.round(hsv.h * 360),\n      s = Math.round(hsv.s * 100),\n      v = Math.round(hsv.v * 100);\n    return this._a == 1 ? \"hsv(\" + h + \", \" + s + \"%, \" + v + \"%)\" : \"hsva(\" + h + \", \" + s + \"%, \" + v + \"%, \" + this._roundA + \")\";\n  },\n  toHsl: function toHsl() {\n    var hsl = rgbToHsl(this._r, this._g, this._b);\n    return {\n      h: hsl.h * 360,\n      s: hsl.s,\n      l: hsl.l,\n      a: this._a\n    };\n  },\n  toHslString: function toHslString() {\n    var hsl = rgbToHsl(this._r, this._g, this._b);\n    var h = Math.round(hsl.h * 360),\n      s = Math.round(hsl.s * 100),\n      l = Math.round(hsl.l * 100);\n    return this._a == 1 ? \"hsl(\" + h + \", \" + s + \"%, \" + l + \"%)\" : \"hsla(\" + h + \", \" + s + \"%, \" + l + \"%, \" + this._roundA + \")\";\n  },\n  toHex: function toHex(allow3Char) {\n    return rgbToHex(this._r, this._g, this._b, allow3Char);\n  },\n  toHexString: function toHexString(allow3Char) {\n    return \"#\" + this.toHex(allow3Char);\n  },\n  toHex8: function toHex8(allow4Char) {\n    return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);\n  },\n  toHex8String: function toHex8String(allow4Char) {\n    return \"#\" + this.toHex8(allow4Char);\n  },\n  toRgb: function toRgb() {\n    return {\n      r: Math.round(this._r),\n      g: Math.round(this._g),\n      b: Math.round(this._b),\n      a: this._a\n    };\n  },\n  toRgbString: function toRgbString() {\n    return this._a == 1 ? \"rgb(\" + Math.round(this._r) + \", \" + Math.round(this._g) + \", \" + Math.round(this._b) + \")\" : \"rgba(\" + Math.round(this._r) + \", \" + Math.round(this._g) + \", \" + Math.round(this._b) + \", \" + this._roundA + \")\";\n  },\n  toPercentageRgb: function toPercentageRgb() {\n    return {\n      r: Math.round(bound01(this._r, 255) * 100) + \"%\",\n      g: Math.round(bound01(this._g, 255) * 100) + \"%\",\n      b: Math.round(bound01(this._b, 255) * 100) + \"%\",\n      a: this._a\n    };\n  },\n  toPercentageRgbString: function toPercentageRgbString() {\n    return this._a == 1 ? \"rgb(\" + Math.round(bound01(this._r, 255) * 100) + \"%, \" + Math.round(bound01(this._g, 255) * 100) + \"%, \" + Math.round(bound01(this._b, 255) * 100) + \"%)\" : \"rgba(\" + Math.round(bound01(this._r, 255) * 100) + \"%, \" + Math.round(bound01(this._g, 255) * 100) + \"%, \" + Math.round(bound01(this._b, 255) * 100) + \"%, \" + this._roundA + \")\";\n  },\n  toName: function toName() {\n    if (this._a === 0) {\n      return \"transparent\";\n    }\n    if (this._a < 1) {\n      return false;\n    }\n    return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;\n  },\n  toFilter: function toFilter(secondColor) {\n    var hex8String = \"#\" + rgbaToArgbHex(this._r, this._g, this._b, this._a);\n    var secondHex8String = hex8String;\n    var gradientType = this._gradientType ? \"GradientType = 1, \" : \"\";\n    if (secondColor) {\n      var s = tinycolor(secondColor);\n      secondHex8String = \"#\" + rgbaToArgbHex(s._r, s._g, s._b, s._a);\n    }\n    return \"progid:DXImageTransform.Microsoft.gradient(\" + gradientType + \"startColorstr=\" + hex8String + \",endColorstr=\" + secondHex8String + \")\";\n  },\n  toString: function toString(format) {\n    var formatSet = !!format;\n    format = format || this._format;\n    var formattedString = false;\n    var hasAlpha = this._a < 1 && this._a >= 0;\n    var needsAlphaFormat = !formatSet && hasAlpha && (format === \"hex\" || format === \"hex6\" || format === \"hex3\" || format === \"hex4\" || format === \"hex8\" || format === \"name\");\n    if (needsAlphaFormat) {\n      // Special case for \"transparent\", all other non-alpha formats\n      // will return rgba when there is transparency.\n      if (format === \"name\" && this._a === 0) {\n        return this.toName();\n      }\n      return this.toRgbString();\n    }\n    if (format === \"rgb\") {\n      formattedString = this.toRgbString();\n    }\n    if (format === \"prgb\") {\n      formattedString = this.toPercentageRgbString();\n    }\n    if (format === \"hex\" || format === \"hex6\") {\n      formattedString = this.toHexString();\n    }\n    if (format === \"hex3\") {\n      formattedString = this.toHexString(true);\n    }\n    if (format === \"hex4\") {\n      formattedString = this.toHex8String(true);\n    }\n    if (format === \"hex8\") {\n      formattedString = this.toHex8String();\n    }\n    if (format === \"name\") {\n      formattedString = this.toName();\n    }\n    if (format === \"hsl\") {\n      formattedString = this.toHslString();\n    }\n    if (format === \"hsv\") {\n      formattedString = this.toHsvString();\n    }\n    return formattedString || this.toHexString();\n  },\n  clone: function clone() {\n    return tinycolor(this.toString());\n  },\n  _applyModification: function _applyModification(fn, args) {\n    var color = fn.apply(null, [this].concat([].slice.call(args)));\n    this._r = color._r;\n    this._g = color._g;\n    this._b = color._b;\n    this.setAlpha(color._a);\n    return this;\n  },\n  lighten: function lighten() {\n    return this._applyModification(_lighten, arguments);\n  },\n  brighten: function brighten() {\n    return this._applyModification(_brighten, arguments);\n  },\n  darken: function darken() {\n    return this._applyModification(_darken, arguments);\n  },\n  desaturate: function desaturate() {\n    return this._applyModification(_desaturate, arguments);\n  },\n  saturate: function saturate() {\n    return this._applyModification(_saturate, arguments);\n  },\n  greyscale: function greyscale() {\n    return this._applyModification(_greyscale, arguments);\n  },\n  spin: function spin() {\n    return this._applyModification(_spin, arguments);\n  },\n  _applyCombination: function _applyCombination(fn, args) {\n    return fn.apply(null, [this].concat([].slice.call(args)));\n  },\n  analogous: function analogous() {\n    return this._applyCombination(_analogous, arguments);\n  },\n  complement: function complement() {\n    return this._applyCombination(_complement, arguments);\n  },\n  monochromatic: function monochromatic() {\n    return this._applyCombination(_monochromatic, arguments);\n  },\n  splitcomplement: function splitcomplement() {\n    return this._applyCombination(_splitcomplement, arguments);\n  },\n  // Disabled until https://github.com/bgrins/TinyColor/issues/254\n  // polyad: function (number) {\n  //   return this._applyCombination(polyad, [number]);\n  // },\n  triad: function triad() {\n    return this._applyCombination(polyad, [3]);\n  },\n  tetrad: function tetrad() {\n    return this._applyCombination(polyad, [4]);\n  }\n};\n\n// If input is an object, force 1 into \"1.0\" to handle ratios properly\n// String input requires \"1.0\" as input, so 1 will be treated as 1\ntinycolor.fromRatio = function (color, opts) {\n  if (_typeof(color) == \"object\") {\n    var newColor = {};\n    for (var i in color) {\n      if (color.hasOwnProperty(i)) {\n        if (i === \"a\") {\n          newColor[i] = color[i];\n        } else {\n          newColor[i] = convertToPercentage(color[i]);\n        }\n      }\n    }\n    color = newColor;\n  }\n  return tinycolor(color, opts);\n};\n\n// Given a string or object, convert that input to RGB\n// Possible string inputs:\n//\n//     \"red\"\n//     \"#f00\" or \"f00\"\n//     \"#ff0000\" or \"ff0000\"\n//     \"#ff000000\" or \"ff000000\"\n//     \"rgb 255 0 0\" or \"rgb (255, 0, 0)\"\n//     \"rgb 1.0 0 0\" or \"rgb (1, 0, 0)\"\n//     \"rgba (255, 0, 0, 1)\" or \"rgba 255, 0, 0, 1\"\n//     \"rgba (1.0, 0, 0, 1)\" or \"rgba 1.0, 0, 0, 1\"\n//     \"hsl(0, 100%, 50%)\" or \"hsl 0 100% 50%\"\n//     \"hsla(0, 100%, 50%, 1)\" or \"hsla 0 100% 50%, 1\"\n//     \"hsv(0, 100%, 100%)\" or \"hsv 0 100% 100%\"\n//\nfunction inputToRGB(color) {\n  var rgb = {\n    r: 0,\n    g: 0,\n    b: 0\n  };\n  var a = 1;\n  var s = null;\n  var v = null;\n  var l = null;\n  var ok = false;\n  var format = false;\n  if (typeof color == \"string\") {\n    color = stringInputToObject(color);\n  }\n  if (_typeof(color) == \"object\") {\n    if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {\n      rgb = rgbToRgb(color.r, color.g, color.b);\n      ok = true;\n      format = String(color.r).substr(-1) === \"%\" ? \"prgb\" : \"rgb\";\n    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {\n      s = convertToPercentage(color.s);\n      v = convertToPercentage(color.v);\n      rgb = hsvToRgb(color.h, s, v);\n      ok = true;\n      format = \"hsv\";\n    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {\n      s = convertToPercentage(color.s);\n      l = convertToPercentage(color.l);\n      rgb = hslToRgb(color.h, s, l);\n      ok = true;\n      format = \"hsl\";\n    }\n    if (color.hasOwnProperty(\"a\")) {\n      a = color.a;\n    }\n  }\n  a = boundAlpha(a);\n  return {\n    ok: ok,\n    format: color.format || format,\n    r: Math.min(255, Math.max(rgb.r, 0)),\n    g: Math.min(255, Math.max(rgb.g, 0)),\n    b: Math.min(255, Math.max(rgb.b, 0)),\n    a: a\n  };\n}\n\n// Conversion Functions\n// --------------------\n\n// `rgbToHsl`, `rgbToHsv`, `hslToRgb`, `hsvToRgb` modified from:\n// <http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript>\n\n// `rgbToRgb`\n// Handle bounds / percentage checking to conform to CSS color spec\n// <http://www.w3.org/TR/css3-color/>\n// *Assumes:* r, g, b in [0, 255] or [0, 1]\n// *Returns:* { r, g, b } in [0, 255]\nfunction rgbToRgb(r, g, b) {\n  return {\n    r: bound01(r, 255) * 255,\n    g: bound01(g, 255) * 255,\n    b: bound01(b, 255) * 255\n  };\n}\n\n// `rgbToHsl`\n// Converts an RGB color value to HSL.\n// *Assumes:* r, g, and b are contained in [0, 255] or [0, 1]\n// *Returns:* { h, s, l } in [0,1]\nfunction rgbToHsl(r, g, b) {\n  r = bound01(r, 255);\n  g = bound01(g, 255);\n  b = bound01(b, 255);\n  var max = Math.max(r, g, b),\n    min = Math.min(r, g, b);\n  var h,\n    s,\n    l = (max + min) / 2;\n  if (max == min) {\n    h = s = 0; // achromatic\n  } else {\n    var d = max - min;\n    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n    switch (max) {\n      case r:\n        h = (g - b) / d + (g < b ? 6 : 0);\n        break;\n      case g:\n        h = (b - r) / d + 2;\n        break;\n      case b:\n        h = (r - g) / d + 4;\n        break;\n    }\n    h /= 6;\n  }\n  return {\n    h: h,\n    s: s,\n    l: l\n  };\n}\n\n// `hslToRgb`\n// Converts an HSL color value to RGB.\n// *Assumes:* h is contained in [0, 1] or [0, 360] and s and l are contained [0, 1] or [0, 100]\n// *Returns:* { r, g, b } in the set [0, 255]\nfunction hslToRgb(h, s, l) {\n  var r, g, b;\n  h = bound01(h, 360);\n  s = bound01(s, 100);\n  l = bound01(l, 100);\n  function hue2rgb(p, q, t) {\n    if (t < 0) t += 1;\n    if (t > 1) t -= 1;\n    if (t < 1 / 6) return p + (q - p) * 6 * t;\n    if (t < 1 / 2) return q;\n    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n    return p;\n  }\n  if (s === 0) {\n    r = g = b = l; // achromatic\n  } else {\n    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n    var p = 2 * l - q;\n    r = hue2rgb(p, q, h + 1 / 3);\n    g = hue2rgb(p, q, h);\n    b = hue2rgb(p, q, h - 1 / 3);\n  }\n  return {\n    r: r * 255,\n    g: g * 255,\n    b: b * 255\n  };\n}\n\n// `rgbToHsv`\n// Converts an RGB color value to HSV\n// *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]\n// *Returns:* { h, s, v } in [0,1]\nfunction rgbToHsv(r, g, b) {\n  r = bound01(r, 255);\n  g = bound01(g, 255);\n  b = bound01(b, 255);\n  var max = Math.max(r, g, b),\n    min = Math.min(r, g, b);\n  var h,\n    s,\n    v = max;\n  var d = max - min;\n  s = max === 0 ? 0 : d / max;\n  if (max == min) {\n    h = 0; // achromatic\n  } else {\n    switch (max) {\n      case r:\n        h = (g - b) / d + (g < b ? 6 : 0);\n        break;\n      case g:\n        h = (b - r) / d + 2;\n        break;\n      case b:\n        h = (r - g) / d + 4;\n        break;\n    }\n    h /= 6;\n  }\n  return {\n    h: h,\n    s: s,\n    v: v\n  };\n}\n\n// `hsvToRgb`\n// Converts an HSV color value to RGB.\n// *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]\n// *Returns:* { r, g, b } in the set [0, 255]\nfunction hsvToRgb(h, s, v) {\n  h = bound01(h, 360) * 6;\n  s = bound01(s, 100);\n  v = bound01(v, 100);\n  var i = Math.floor(h),\n    f = h - i,\n    p = v * (1 - s),\n    q = v * (1 - f * s),\n    t = v * (1 - (1 - f) * s),\n    mod = i % 6,\n    r = [v, q, p, p, t, v][mod],\n    g = [t, v, v, q, p, p][mod],\n    b = [p, p, t, v, v, q][mod];\n  return {\n    r: r * 255,\n    g: g * 255,\n    b: b * 255\n  };\n}\n\n// `rgbToHex`\n// Converts an RGB color to hex\n// Assumes r, g, and b are contained in the set [0, 255]\n// Returns a 3 or 6 character hex\nfunction rgbToHex(r, g, b, allow3Char) {\n  var hex = [pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16))];\n\n  // Return a 3 character hex if possible\n  if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {\n    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);\n  }\n  return hex.join(\"\");\n}\n\n// `rgbaToHex`\n// Converts an RGBA color plus alpha transparency to hex\n// Assumes r, g, b are contained in the set [0, 255] and\n// a in [0, 1]. Returns a 4 or 8 character rgba hex\nfunction rgbaToHex(r, g, b, a, allow4Char) {\n  var hex = [pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16)), pad2(convertDecimalToHex(a))];\n\n  // Return a 4 character hex if possible\n  if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {\n    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);\n  }\n  return hex.join(\"\");\n}\n\n// `rgbaToArgbHex`\n// Converts an RGBA color to an ARGB Hex8 string\n// Rarely used, but required for \"toFilter()\"\nfunction rgbaToArgbHex(r, g, b, a) {\n  var hex = [pad2(convertDecimalToHex(a)), pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16))];\n  return hex.join(\"\");\n}\n\n// `equals`\n// Can be called with any tinycolor input\ntinycolor.equals = function (color1, color2) {\n  if (!color1 || !color2) return false;\n  return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();\n};\ntinycolor.random = function () {\n  return tinycolor.fromRatio({\n    r: Math.random(),\n    g: Math.random(),\n    b: Math.random()\n  });\n};\n\n// Modification Functions\n// ----------------------\n// Thanks to less.js for some of the basics here\n// <https://github.com/cloudhead/less.js/blob/master/lib/less/functions.js>\n\nfunction _desaturate(color, amount) {\n  amount = amount === 0 ? 0 : amount || 10;\n  var hsl = tinycolor(color).toHsl();\n  hsl.s -= amount / 100;\n  hsl.s = clamp01(hsl.s);\n  return tinycolor(hsl);\n}\nfunction _saturate(color, amount) {\n  amount = amount === 0 ? 0 : amount || 10;\n  var hsl = tinycolor(color).toHsl();\n  hsl.s += amount / 100;\n  hsl.s = clamp01(hsl.s);\n  return tinycolor(hsl);\n}\nfunction _greyscale(color) {\n  return tinycolor(color).desaturate(100);\n}\nfunction _lighten(color, amount) {\n  amount = amount === 0 ? 0 : amount || 10;\n  var hsl = tinycolor(color).toHsl();\n  hsl.l += amount / 100;\n  hsl.l = clamp01(hsl.l);\n  return tinycolor(hsl);\n}\nfunction _brighten(color, amount) {\n  amount = amount === 0 ? 0 : amount || 10;\n  var rgb = tinycolor(color).toRgb();\n  rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));\n  rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));\n  rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));\n  return tinycolor(rgb);\n}\nfunction _darken(color, amount) {\n  amount = amount === 0 ? 0 : amount || 10;\n  var hsl = tinycolor(color).toHsl();\n  hsl.l -= amount / 100;\n  hsl.l = clamp01(hsl.l);\n  return tinycolor(hsl);\n}\n\n// Spin takes a positive or negative amount within [-360, 360] indicating the change of hue.\n// Values outside of this range will be wrapped into this range.\nfunction _spin(color, amount) {\n  var hsl = tinycolor(color).toHsl();\n  var hue = (hsl.h + amount) % 360;\n  hsl.h = hue < 0 ? 360 + hue : hue;\n  return tinycolor(hsl);\n}\n\n// Combination Functions\n// ---------------------\n// Thanks to jQuery xColor for some of the ideas behind these\n// <https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js>\n\nfunction _complement(color) {\n  var hsl = tinycolor(color).toHsl();\n  hsl.h = (hsl.h + 180) % 360;\n  return tinycolor(hsl);\n}\nfunction polyad(color, number) {\n  if (isNaN(number) || number <= 0) {\n    throw new Error(\"Argument to polyad must be a positive number\");\n  }\n  var hsl = tinycolor(color).toHsl();\n  var result = [tinycolor(color)];\n  var step = 360 / number;\n  for (var i = 1; i < number; i++) {\n    result.push(tinycolor({\n      h: (hsl.h + i * step) % 360,\n      s: hsl.s,\n      l: hsl.l\n    }));\n  }\n  return result;\n}\nfunction _splitcomplement(color) {\n  var hsl = tinycolor(color).toHsl();\n  var h = hsl.h;\n  return [tinycolor(color), tinycolor({\n    h: (h + 72) % 360,\n    s: hsl.s,\n    l: hsl.l\n  }), tinycolor({\n    h: (h + 216) % 360,\n    s: hsl.s,\n    l: hsl.l\n  })];\n}\nfunction _analogous(color, results, slices) {\n  results = results || 6;\n  slices = slices || 30;\n  var hsl = tinycolor(color).toHsl();\n  var part = 360 / slices;\n  var ret = [tinycolor(color)];\n  for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results;) {\n    hsl.h = (hsl.h + part) % 360;\n    ret.push(tinycolor(hsl));\n  }\n  return ret;\n}\nfunction _monochromatic(color, results) {\n  results = results || 6;\n  var hsv = tinycolor(color).toHsv();\n  var h = hsv.h,\n    s = hsv.s,\n    v = hsv.v;\n  var ret = [];\n  var modification = 1 / results;\n  while (results--) {\n    ret.push(tinycolor({\n      h: h,\n      s: s,\n      v: v\n    }));\n    v = (v + modification) % 1;\n  }\n  return ret;\n}\n\n// Utility Functions\n// ---------------------\n\ntinycolor.mix = function (color1, color2, amount) {\n  amount = amount === 0 ? 0 : amount || 50;\n  var rgb1 = tinycolor(color1).toRgb();\n  var rgb2 = tinycolor(color2).toRgb();\n  var p = amount / 100;\n  var rgba = {\n    r: (rgb2.r - rgb1.r) * p + rgb1.r,\n    g: (rgb2.g - rgb1.g) * p + rgb1.g,\n    b: (rgb2.b - rgb1.b) * p + rgb1.b,\n    a: (rgb2.a - rgb1.a) * p + rgb1.a\n  };\n  return tinycolor(rgba);\n};\n\n// Readability Functions\n// ---------------------\n// <http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef (WCAG Version 2)\n\n// `contrast`\n// Analyze the 2 colors and returns the color contrast defined by (WCAG Version 2)\ntinycolor.readability = function (color1, color2) {\n  var c1 = tinycolor(color1);\n  var c2 = tinycolor(color2);\n  return (Math.max(c1.getLuminance(), c2.getLuminance()) + 0.05) / (Math.min(c1.getLuminance(), c2.getLuminance()) + 0.05);\n};\n\n// `isReadable`\n// Ensure that foreground and background color combinations meet WCAG2 guidelines.\n// The third argument is an optional Object.\n//      the 'level' property states 'AA' or 'AAA' - if missing or invalid, it defaults to 'AA';\n//      the 'size' property states 'large' or 'small' - if missing or invalid, it defaults to 'small'.\n// If the entire object is absent, isReadable defaults to {level:\"AA\",size:\"small\"}.\n\n// *Example*\n//    tinycolor.isReadable(\"#000\", \"#111\") => false\n//    tinycolor.isReadable(\"#000\", \"#111\",{level:\"AA\",size:\"large\"}) => false\ntinycolor.isReadable = function (color1, color2, wcag2) {\n  var readability = tinycolor.readability(color1, color2);\n  var wcag2Parms, out;\n  out = false;\n  wcag2Parms = validateWCAG2Parms(wcag2);\n  switch (wcag2Parms.level + wcag2Parms.size) {\n    case \"AAsmall\":\n    case \"AAAlarge\":\n      out = readability >= 4.5;\n      break;\n    case \"AAlarge\":\n      out = readability >= 3;\n      break;\n    case \"AAAsmall\":\n      out = readability >= 7;\n      break;\n  }\n  return out;\n};\n\n// `mostReadable`\n// Given a base color and a list of possible foreground or background\n// colors for that base, returns the most readable color.\n// Optionally returns Black or White if the most readable color is unreadable.\n// *Example*\n//    tinycolor.mostReadable(tinycolor.mostReadable(\"#123\", [\"#124\", \"#125\"],{includeFallbackColors:false}).toHexString(); // \"#112255\"\n//    tinycolor.mostReadable(tinycolor.mostReadable(\"#123\", [\"#124\", \"#125\"],{includeFallbackColors:true}).toHexString();  // \"#ffffff\"\n//    tinycolor.mostReadable(\"#a8015a\", [\"#faf3f3\"],{includeFallbackColors:true,level:\"AAA\",size:\"large\"}).toHexString(); // \"#faf3f3\"\n//    tinycolor.mostReadable(\"#a8015a\", [\"#faf3f3\"],{includeFallbackColors:true,level:\"AAA\",size:\"small\"}).toHexString(); // \"#ffffff\"\ntinycolor.mostReadable = function (baseColor, colorList, args) {\n  var bestColor = null;\n  var bestScore = 0;\n  var readability;\n  var includeFallbackColors, level, size;\n  args = args || {};\n  includeFallbackColors = args.includeFallbackColors;\n  level = args.level;\n  size = args.size;\n  for (var i = 0; i < colorList.length; i++) {\n    readability = tinycolor.readability(baseColor, colorList[i]);\n    if (readability > bestScore) {\n      bestScore = readability;\n      bestColor = tinycolor(colorList[i]);\n    }\n  }\n  if (tinycolor.isReadable(baseColor, bestColor, {\n    level: level,\n    size: size\n  }) || !includeFallbackColors) {\n    return bestColor;\n  } else {\n    args.includeFallbackColors = false;\n    return tinycolor.mostReadable(baseColor, [\"#fff\", \"#000\"], args);\n  }\n};\n\n// Big List of Colors\n// ------------------\n// <https://www.w3.org/TR/css-color-4/#named-colors>\nvar names = tinycolor.names = {\n  aliceblue: \"f0f8ff\",\n  antiquewhite: \"faebd7\",\n  aqua: \"0ff\",\n  aquamarine: \"7fffd4\",\n  azure: \"f0ffff\",\n  beige: \"f5f5dc\",\n  bisque: \"ffe4c4\",\n  black: \"000\",\n  blanchedalmond: \"ffebcd\",\n  blue: \"00f\",\n  blueviolet: \"8a2be2\",\n  brown: \"a52a2a\",\n  burlywood: \"deb887\",\n  burntsienna: \"ea7e5d\",\n  cadetblue: \"5f9ea0\",\n  chartreuse: \"7fff00\",\n  chocolate: \"d2691e\",\n  coral: \"ff7f50\",\n  cornflowerblue: \"6495ed\",\n  cornsilk: \"fff8dc\",\n  crimson: \"dc143c\",\n  cyan: \"0ff\",\n  darkblue: \"00008b\",\n  darkcyan: \"008b8b\",\n  darkgoldenrod: \"b8860b\",\n  darkgray: \"a9a9a9\",\n  darkgreen: \"006400\",\n  darkgrey: \"a9a9a9\",\n  darkkhaki: \"bdb76b\",\n  darkmagenta: \"8b008b\",\n  darkolivegreen: \"556b2f\",\n  darkorange: \"ff8c00\",\n  darkorchid: \"9932cc\",\n  darkred: \"8b0000\",\n  darksalmon: \"e9967a\",\n  darkseagreen: \"8fbc8f\",\n  darkslateblue: \"483d8b\",\n  darkslategray: \"2f4f4f\",\n  darkslategrey: \"2f4f4f\",\n  darkturquoise: \"00ced1\",\n  darkviolet: \"9400d3\",\n  deeppink: \"ff1493\",\n  deepskyblue: \"00bfff\",\n  dimgray: \"696969\",\n  dimgrey: \"696969\",\n  dodgerblue: \"1e90ff\",\n  firebrick: \"b22222\",\n  floralwhite: \"fffaf0\",\n  forestgreen: \"228b22\",\n  fuchsia: \"f0f\",\n  gainsboro: \"dcdcdc\",\n  ghostwhite: \"f8f8ff\",\n  gold: \"ffd700\",\n  goldenrod: \"daa520\",\n  gray: \"808080\",\n  green: \"008000\",\n  greenyellow: \"adff2f\",\n  grey: \"808080\",\n  honeydew: \"f0fff0\",\n  hotpink: \"ff69b4\",\n  indianred: \"cd5c5c\",\n  indigo: \"4b0082\",\n  ivory: \"fffff0\",\n  khaki: \"f0e68c\",\n  lavender: \"e6e6fa\",\n  lavenderblush: \"fff0f5\",\n  lawngreen: \"7cfc00\",\n  lemonchiffon: \"fffacd\",\n  lightblue: \"add8e6\",\n  lightcoral: \"f08080\",\n  lightcyan: \"e0ffff\",\n  lightgoldenrodyellow: \"fafad2\",\n  lightgray: \"d3d3d3\",\n  lightgreen: \"90ee90\",\n  lightgrey: \"d3d3d3\",\n  lightpink: \"ffb6c1\",\n  lightsalmon: \"ffa07a\",\n  lightseagreen: \"20b2aa\",\n  lightskyblue: \"87cefa\",\n  lightslategray: \"789\",\n  lightslategrey: \"789\",\n  lightsteelblue: \"b0c4de\",\n  lightyellow: \"ffffe0\",\n  lime: \"0f0\",\n  limegreen: \"32cd32\",\n  linen: \"faf0e6\",\n  magenta: \"f0f\",\n  maroon: \"800000\",\n  mediumaquamarine: \"66cdaa\",\n  mediumblue: \"0000cd\",\n  mediumorchid: \"ba55d3\",\n  mediumpurple: \"9370db\",\n  mediumseagreen: \"3cb371\",\n  mediumslateblue: \"7b68ee\",\n  mediumspringgreen: \"00fa9a\",\n  mediumturquoise: \"48d1cc\",\n  mediumvioletred: \"c71585\",\n  midnightblue: \"191970\",\n  mintcream: \"f5fffa\",\n  mistyrose: \"ffe4e1\",\n  moccasin: \"ffe4b5\",\n  navajowhite: \"ffdead\",\n  navy: \"000080\",\n  oldlace: \"fdf5e6\",\n  olive: \"808000\",\n  olivedrab: \"6b8e23\",\n  orange: \"ffa500\",\n  orangered: \"ff4500\",\n  orchid: \"da70d6\",\n  palegoldenrod: \"eee8aa\",\n  palegreen: \"98fb98\",\n  paleturquoise: \"afeeee\",\n  palevioletred: \"db7093\",\n  papayawhip: \"ffefd5\",\n  peachpuff: \"ffdab9\",\n  peru: \"cd853f\",\n  pink: \"ffc0cb\",\n  plum: \"dda0dd\",\n  powderblue: \"b0e0e6\",\n  purple: \"800080\",\n  rebeccapurple: \"663399\",\n  red: \"f00\",\n  rosybrown: \"bc8f8f\",\n  royalblue: \"4169e1\",\n  saddlebrown: \"8b4513\",\n  salmon: \"fa8072\",\n  sandybrown: \"f4a460\",\n  seagreen: \"2e8b57\",\n  seashell: \"fff5ee\",\n  sienna: \"a0522d\",\n  silver: \"c0c0c0\",\n  skyblue: \"87ceeb\",\n  slateblue: \"6a5acd\",\n  slategray: \"708090\",\n  slategrey: \"708090\",\n  snow: \"fffafa\",\n  springgreen: \"00ff7f\",\n  steelblue: \"4682b4\",\n  tan: \"d2b48c\",\n  teal: \"008080\",\n  thistle: \"d8bfd8\",\n  tomato: \"ff6347\",\n  turquoise: \"40e0d0\",\n  violet: \"ee82ee\",\n  wheat: \"f5deb3\",\n  white: \"fff\",\n  whitesmoke: \"f5f5f5\",\n  yellow: \"ff0\",\n  yellowgreen: \"9acd32\"\n};\n\n// Make it easy to access colors via `hexNames[hex]`\nvar hexNames = tinycolor.hexNames = flip(names);\n\n// Utilities\n// ---------\n\n// `{ 'name1': 'val1' }` becomes `{ 'val1': 'name1' }`\nfunction flip(o) {\n  var flipped = {};\n  for (var i in o) {\n    if (o.hasOwnProperty(i)) {\n      flipped[o[i]] = i;\n    }\n  }\n  return flipped;\n}\n\n// Return a valid alpha value [0,1] with all invalid values being set to 1\nfunction boundAlpha(a) {\n  a = parseFloat(a);\n  if (isNaN(a) || a < 0 || a > 1) {\n    a = 1;\n  }\n  return a;\n}\n\n// Take input from [0, n] and return it as [0, 1]\nfunction bound01(n, max) {\n  if (isOnePointZero(n)) n = \"100%\";\n  var processPercent = isPercentage(n);\n  n = Math.min(max, Math.max(0, parseFloat(n)));\n\n  // Automatically convert percentage into number\n  if (processPercent) {\n    n = parseInt(n * max, 10) / 100;\n  }\n\n  // Handle floating point rounding errors\n  if (Math.abs(n - max) < 0.000001) {\n    return 1;\n  }\n\n  // Convert into [0, 1] range if it isn't already\n  return n % max / parseFloat(max);\n}\n\n// Force a number between 0 and 1\nfunction clamp01(val) {\n  return Math.min(1, Math.max(0, val));\n}\n\n// Parse a base-16 hex value into a base-10 integer\nfunction parseIntFromHex(val) {\n  return parseInt(val, 16);\n}\n\n// Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1\n// <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>\nfunction isOnePointZero(n) {\n  return typeof n == \"string\" && n.indexOf(\".\") != -1 && parseFloat(n) === 1;\n}\n\n// Check to see if string passed in is a percentage\nfunction isPercentage(n) {\n  return typeof n === \"string\" && n.indexOf(\"%\") != -1;\n}\n\n// Force a hex value to have 2 characters\nfunction pad2(c) {\n  return c.length == 1 ? \"0\" + c : \"\" + c;\n}\n\n// Replace a decimal with it's percentage value\nfunction convertToPercentage(n) {\n  if (n <= 1) {\n    n = n * 100 + \"%\";\n  }\n  return n;\n}\n\n// Converts a decimal to a hex value\nfunction convertDecimalToHex(d) {\n  return Math.round(parseFloat(d) * 255).toString(16);\n}\n// Converts a hex value to a decimal\nfunction convertHexToDecimal(h) {\n  return parseIntFromHex(h) / 255;\n}\nvar matchers = function () {\n  // <http://www.w3.org/TR/css3-values/#integers>\n  var CSS_INTEGER = \"[-\\\\+]?\\\\d+%?\";\n\n  // <http://www.w3.org/TR/css3-values/#number-value>\n  var CSS_NUMBER = \"[-\\\\+]?\\\\d*\\\\.\\\\d+%?\";\n\n  // Allow positive/negative integer/number.  Don't capture the either/or, just the entire outcome.\n  var CSS_UNIT = \"(?:\" + CSS_NUMBER + \")|(?:\" + CSS_INTEGER + \")\";\n\n  // Actual matching.\n  // Parentheses and commas are optional, but not required.\n  // Whitespace can take the place of commas or opening paren\n  var PERMISSIVE_MATCH3 = \"[\\\\s|\\\\(]+(\" + CSS_UNIT + \")[,|\\\\s]+(\" + CSS_UNIT + \")[,|\\\\s]+(\" + CSS_UNIT + \")\\\\s*\\\\)?\";\n  var PERMISSIVE_MATCH4 = \"[\\\\s|\\\\(]+(\" + CSS_UNIT + \")[,|\\\\s]+(\" + CSS_UNIT + \")[,|\\\\s]+(\" + CSS_UNIT + \")[,|\\\\s]+(\" + CSS_UNIT + \")\\\\s*\\\\)?\";\n  return {\n    CSS_UNIT: new RegExp(CSS_UNIT),\n    rgb: new RegExp(\"rgb\" + PERMISSIVE_MATCH3),\n    rgba: new RegExp(\"rgba\" + PERMISSIVE_MATCH4),\n    hsl: new RegExp(\"hsl\" + PERMISSIVE_MATCH3),\n    hsla: new RegExp(\"hsla\" + PERMISSIVE_MATCH4),\n    hsv: new RegExp(\"hsv\" + PERMISSIVE_MATCH3),\n    hsva: new RegExp(\"hsva\" + PERMISSIVE_MATCH4),\n    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,\n    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,\n    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,\n    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/\n  };\n}();\n\n// `isValidCSSUnit`\n// Take in a single string / number and check to see if it looks like a CSS unit\n// (see `matchers` above for definition).\nfunction isValidCSSUnit(color) {\n  return !!matchers.CSS_UNIT.exec(color);\n}\n\n// `stringInputToObject`\n// Permissive string parsing.  Take in a number of formats, and output an object\n// based on detected format.  Returns `{ r, g, b }` or `{ h, s, l }` or `{ h, s, v}`\nfunction stringInputToObject(color) {\n  color = color.replace(trimLeft, \"\").replace(trimRight, \"\").toLowerCase();\n  var named = false;\n  if (names[color]) {\n    color = names[color];\n    named = true;\n  } else if (color == \"transparent\") {\n    return {\n      r: 0,\n      g: 0,\n      b: 0,\n      a: 0,\n      format: \"name\"\n    };\n  }\n\n  // Try to match string input using regular expressions.\n  // Keep most of the number bounding out of this function - don't worry about [0,1] or [0,100] or [0,360]\n  // Just return an object and let the conversion functions handle that.\n  // This way the result will be the same whether the tinycolor is initialized with string or object.\n  var match;\n  if (match = matchers.rgb.exec(color)) {\n    return {\n      r: match[1],\n      g: match[2],\n      b: match[3]\n    };\n  }\n  if (match = matchers.rgba.exec(color)) {\n    return {\n      r: match[1],\n      g: match[2],\n      b: match[3],\n      a: match[4]\n    };\n  }\n  if (match = matchers.hsl.exec(color)) {\n    return {\n      h: match[1],\n      s: match[2],\n      l: match[3]\n    };\n  }\n  if (match = matchers.hsla.exec(color)) {\n    return {\n      h: match[1],\n      s: match[2],\n      l: match[3],\n      a: match[4]\n    };\n  }\n  if (match = matchers.hsv.exec(color)) {\n    return {\n      h: match[1],\n      s: match[2],\n      v: match[3]\n    };\n  }\n  if (match = matchers.hsva.exec(color)) {\n    return {\n      h: match[1],\n      s: match[2],\n      v: match[3],\n      a: match[4]\n    };\n  }\n  if (match = matchers.hex8.exec(color)) {\n    return {\n      r: parseIntFromHex(match[1]),\n      g: parseIntFromHex(match[2]),\n      b: parseIntFromHex(match[3]),\n      a: convertHexToDecimal(match[4]),\n      format: named ? \"name\" : \"hex8\"\n    };\n  }\n  if (match = matchers.hex6.exec(color)) {\n    return {\n      r: parseIntFromHex(match[1]),\n      g: parseIntFromHex(match[2]),\n      b: parseIntFromHex(match[3]),\n      format: named ? \"name\" : \"hex\"\n    };\n  }\n  if (match = matchers.hex4.exec(color)) {\n    return {\n      r: parseIntFromHex(match[1] + \"\" + match[1]),\n      g: parseIntFromHex(match[2] + \"\" + match[2]),\n      b: parseIntFromHex(match[3] + \"\" + match[3]),\n      a: convertHexToDecimal(match[4] + \"\" + match[4]),\n      format: named ? \"name\" : \"hex8\"\n    };\n  }\n  if (match = matchers.hex3.exec(color)) {\n    return {\n      r: parseIntFromHex(match[1] + \"\" + match[1]),\n      g: parseIntFromHex(match[2] + \"\" + match[2]),\n      b: parseIntFromHex(match[3] + \"\" + match[3]),\n      format: named ? \"name\" : \"hex\"\n    };\n  }\n  return false;\n}\nfunction validateWCAG2Parms(parms) {\n  // return valid WCAG2 parms for isReadable.\n  // If input parms are invalid, return {\"level\":\"AA\", \"size\":\"small\"}\n  var level, size;\n  parms = parms || {\n    level: \"AA\",\n    size: \"small\"\n  };\n  level = (parms.level || \"AA\").toUpperCase();\n  size = (parms.size || \"small\").toLowerCase();\n  if (level !== \"AA\" && level !== \"AAA\") {\n    level = \"AA\";\n  }\n  if (size !== \"small\" && size !== \"large\") {\n    size = \"small\";\n  }\n  return {\n    level: level,\n    size: size\n  };\n}\n\nexport { tinycolor as default };\n", "import { IParticle, ISettings, IState } from '../interfaces';\nimport { circle } from 'mz-canvas';\nimport { getRandom, getRandomBoolean, getRandomHexColor, getRandomItemFromArray, Vector2 } from 'mz-math';\nimport { getPathBBox } from 'mz-svg';\nimport tinycolor from 'tinycolor2';\nimport { rgbaToString } from './colors-provider';\n\n/**\n * This method is called once on the particles' initialization.\n */\nexport const createParticles = (options: ISettings, state: IState) : IParticle[] => {\n\n    const { $canvas } = state;\n\n    const particles: IParticle[] = [];\n\n    let svgPathData: string|undefined = undefined;\n    let svgSize: Vector2|undefined = undefined;\n\n    const minSize = options.minSize as number;\n    const maxSize = options.maxSize as number;\n    const minSpeed = options.minSpeed as number;\n    const maxSpeed = options.maxSpeed as number;\n    const maxScale = options.maxScale as number;\n\n    const minScale = options.minScale as number;\n\n    for(let i= 0; i< options.particlesNumber; i++) {\n\n        const rnd = getRandom(minSize, maxSize);\n        const particleSize: Vector2 = [rnd, rnd];\n\n        // handle case when provided SVG path data -------------\n        if(options.svgPathData && options.svgPathData.length > 0){\n\n            // get random SVG shape from the provided list, and calculate it's size\n            svgPathData = getRandomItemFromArray(options.svgPathData);\n            const bbox = getPathBBox(svgPathData);\n\n            if(bbox){\n                svgSize = [\n                    particleSize[0] / bbox.w,\n                    particleSize[1] / bbox.h,\n                ];\n            }\n        }\n\n        let color;\n\n        if(options.particlesColors && options.particlesColors.length > 0){\n            color = getRandomItemFromArray(options.particlesColors);\n        }\n        else{\n            // when no color is provided ---> get random color\n            color = getRandomHexColor();\n        }\n\n        const tColor = tinycolor(color);\n        const tColorRGB = tColor.toRgb();\n\n        particles.push({\n            center: [\n                getRandom(0, $canvas.width),\n                getRandom(0, $canvas.height),\n            ],\n            speed: [\n                getRandom(minSpeed, maxSpeed),\n                getRandom(minSpeed, maxSpeed),\n            ],\n            size: particleSize,\n\n            color,\n            rgbaColor: [tColorRGB.r, tColorRGB.g, tColorRGB.b, tColorRGB.a],\n\n            // SVG path props ----------\n            svgPathData,\n            svgSize,\n\n            // rotation effect ------------\n            angleRad: 0,\n            rotateCounterClockwise: getRandomBoolean(),\n\n            // scale effect ---------------\n            scale: (minScale + maxScale) / 2,\n            scaleDirection: getRandomItemFromArray([-1, 1]),\n\n            // fade in/out effect ---------\n            opacity: getRandom(0, 1),\n            opacityDirection: getRandomItemFromArray([-1, 1]),\n        });\n    }\n\n    return particles;\n};\n\nexport const moveParticle = (particle: IParticle, options: ISettings, state: IState) : IParticle => {\n\n    const { $canvas } = state;\n\n    const copy = { ...particle };\n\n    const [cx, cy]: Vector2 = particle.center;\n    const speed: Vector2 = [...particle.speed] as Vector2;\n\n    if(cx > $canvas.width || cx < 0) {\n        speed[0] = -speed[0];\n    }\n\n    if(cy > $canvas.height || cy < 0) {\n        speed[1] = -speed[1];\n    }\n\n    copy.speed = speed;\n    copy.center = [cx + copy.speed[0], cy + copy.speed[1]];\n\n    if(options.rotate) {\n        if(particle.rotateCounterClockwise){\n            copy.angleRad += Math.PI / 180;\n        }\n        else{\n            copy.angleRad -= Math.PI / 180;\n        }\n    }\n\n    if(options.scaleInOut){\n        const scaleStep = options.scaleStep as number;\n        const maxScale = options.maxScale as number;\n        const minScale = options.minScale as number;\n\n        if(copy.scaleDirection > 0){\n            copy.scale += scaleStep;\n        }\n        else{\n            copy.scale -= scaleStep;\n        }\n\n        if(copy.scale > maxScale){\n            copy.scale = maxScale;\n            copy.scaleDirection = -1;\n        }\n\n        if(copy.scale < minScale){\n            copy.scale = minScale;\n            copy.scaleDirection = 1;\n        }\n    }\n\n    if(options.fadeInOut){\n        const opacityStep = options.opacityStep as number;\n\n        if(copy.opacityDirection > 0){\n            copy.opacity += opacityStep;\n        }\n        else{\n            copy.opacity -= opacityStep;\n        }\n\n        if(copy.opacity > 1){\n            copy.scale = 1;\n            copy.opacityDirection = -1;\n        }\n\n        if(copy.opacity < 0){\n            copy.opacity = 0;\n            copy.opacityDirection = 1;\n        }\n    }\n\n    return copy;\n};\n\nexport const drawParticle = (particle: IParticle, options: ISettings, state: IState) => {\n\n    const { ctx } = state;\n\n    if(!options.svgPathData){\n\n        ctx.save();\n\n        const { size } = particle;\n        let r = size[0];\n\n        if(options.scaleInOut){\n            r *= particle.scale;\n        }\n\n        const fillStyle = options.fadeInOut ?\n            rgbaToString(\n                particle.rgbaColor[0],\n                particle.rgbaColor[1],\n                particle.rgbaColor[2],\n                particle.opacity\n            ) :\n            particle.color;\n\n        circle({\n            cx: particle.center[0],\n            cy: particle.center[1],\n            r,\n            fillStyle,\n        }, ctx);\n\n        ctx.restore();\n        return;\n    }\n\n    const [w, h] = particle.size;\n\n    const path = new Path2D(particle.svgPathData);\n    ctx.save();\n\n    const halfWidth = w/2;\n    const halfHeight = h/2;\n\n    const [cx, cy] = [particle.center[0] - halfWidth, particle.center[1] - halfHeight];\n    ctx.translate(cx, cy);\n\n    if(particle.svgSize){\n        // scale the path -------------------------------\n        ctx.translate(halfWidth, halfHeight);\n        ctx.scale(...particle.svgSize);\n        ctx.translate(-halfWidth, -halfHeight);\n    }\n\n    if(options.rotate) {\n        ctx.translate(halfWidth, halfHeight);\n        ctx.rotate(particle.angleRad);\n        ctx.translate(-halfWidth, -halfHeight);\n    }\n\n    if(options.scaleInOut){\n        ctx.translate(halfWidth, halfHeight);\n        ctx.scale(particle.scale, particle.scale);\n        ctx.translate(-halfWidth, -halfHeight);\n    }\n\n    if(options.fadeInOut){\n        ctx.fillStyle = rgbaToString(\n            particle.rgbaColor[0],\n            particle.rgbaColor[1],\n            particle.rgbaColor[2],\n            particle.opacity,\n        );\n    }\n    else{\n        ctx.fillStyle = particle.color;\n    }\n\n    ctx.fill(path);\n    ctx.restore();\n};\n\n\n", "import { ISettings } from '../interfaces';\n\nexport const DEFAULTS: ISettings = {\n    // canvas settings --------------\n    canvasWidth: 600,\n    canvasHeight: 600,\n\n    particlesNumber: 40,\n    particlesColors: [],\n\n    minSpeed: -2,\n    maxSpeed: 2,\n\n    minSize: 5,\n    maxSize: 10,\n\n    // connection lines ------------\n    connected: true,\n    maxConnectionSize: 150,\n    connectionColor: 'rgb(45, 56, 91)',\n\n    // scale effect\n    maxScale: 2,\n    minScale: 0.5,\n    scaleStep: 0.01,\n\n    // fade in/out effect ---------\n    opacityStep: 0.001,\n};\n\n/**\n * Merge settings with the defaults\n */\nexport const mergeSettings = (defaults: ISettings, settings?: ISettings) : ISettings => {\n    if(!settings) return { ...defaults };\n    return { ...defaults, ...settings };\n};\n", "import { ISettings, IState } from './interfaces';\nimport { drawConnections } from './domain/connections-provider';\nimport { createParticles, drawParticle, moveParticle } from './domain/particles-provider';\nimport { DEFAULTS, mergeSettings } from './domain/settings-provider';\nimport { canvas, IRectProps, rect } from 'mz-canvas';\nimport { animate } from 'mz-math';\nimport tinycolor from 'tinycolor2';\n\nconst redraw = (options: ISettings, state: IState) => {\n\n    const { $canvas, ctx } = state;\n\n    // set bg color or clear the canvas ---------------------------\n    const rectProps: IRectProps = {\n        x: 0,\n        y: 0,\n        w: $canvas.width,\n        h: $canvas.height,\n    };\n\n    if(options.canvasColor){\n        rectProps.fillStyle = options.canvasColor;\n    }\n    else{\n        rectProps.clear = true;\n    }\n\n    rect(rectProps, ctx);\n\n    // draw the particle connections -------------------------------\n    if(options.connected){\n        drawConnections(options, state);\n    }\n\n    // draw the updated particles ------------------\n    for(let i= 0; i<state.particles.length; i++){\n        const particle = state.particles[i];\n        drawParticle(particle, options, state);\n        state.particles[i] = moveParticle(particle, options, state);\n    }\n};\n\n/**\n * Entry point.\n */\nexport const init = (settings?: ISettings) => {\n\n    const options = mergeSettings(DEFAULTS, settings);\n    if(!options.$placeholder) return;\n\n    const rect = options.$placeholder.getBoundingClientRect();\n\n    const canvasProps = {\n        width: rect.width,\n        height: rect.height,\n    };\n\n    const { ctx, $canvas } = canvas(canvasProps);\n    if(!ctx) return;\n\n    options.$placeholder.append($canvas);\n\n    // parse connection lines color ----------\n    const connectionsColor = tinycolor(options.connectionColor);\n    const tConnectionsRGB = connectionsColor.toRgb();\n\n    const state: IState = {\n        connectionRgbColor: [tConnectionsRGB.r, tConnectionsRGB.g, tConnectionsRGB.b, tConnectionsRGB.a],\n        particles: [],\n        ctx,\n        $canvas,\n    };\n\n    // create random particles -----------------------------\n    state.particles = createParticles(options, state);\n\n    const api = animate({\n\n        // A function to be called on each animation frame.\n        // It receives an object of type IAnimationResult.\n        callback: () => {\n            if(!ctx) return;\n            redraw(options, state);\n        },\n        restartOnResize: true,\n        resizeCallback: () => {\n            const rect = options.$placeholder.getBoundingClientRect();\n            $canvas.width = rect.width;\n            $canvas.height = rect.height;\n            redraw(options, state);\n        },\n    });\n\n    // Starts the animation.\n    api.start();\n\n    // document.body.append($canvas);\n    return $canvas;\n};", "import { init as particles } from './app';\n\ndeclare global {\n    interface Window {\n        particles: typeof particles,\n    }\n}\n\nwindow.particles = particles;\n\nexport default particles;\n", "import { initMenuCollapsible, initMenuScroll } from './menu/side-menu';\nimport { initMobileMenu } from './menu/mobile-menu';\nimport { handleDarkLightModes } from './dark-mode';\n// import hljs from 'highlight.js';\nimport particles from 'mz-particles';\n\nconst initAnimation = () => {\n  const $placeholder = document.getElementById('hp-animation');\n  if(!$placeholder) return;\n\n  particles({\n    $placeholder,\n    particlesNumber: 100,\n\n    minSize: 10,\n    maxSize: 30,\n\n    particlesColors: [\n      '#366d8c', '#368c8c', '#fffc00', '#92fae7',\n      '#5daed2', '#366d8c'\n    ],\n    connectionColor: '#7fb2b7',\n\n    // stars -------------\n    svgPathData: [\n      'm14.5 21.75-8.52289 4.48075 1.62773-9.49038-6.89516-6.72112 9.52888-1.38462L14.5 0l4.26144 8.63463 9.52888 1.38462-6.89516 6.72112 1.62773 9.49038z',\n      'M14.5 21.75 4.24695 24.75305 7.25 14.5 4.24695 4.24695 14.5 7.25l10.25305-3.00305L21.75 14.5l3.00305 10.25305z',\n      'm14.5 21.75-5.54891 6.14625.42239-8.26973-8.26973.42239L7.25 14.5 1.10375 8.95109l8.26973.42239-.42239-8.26973L14.5 7.25l5.54891-6.14625-.42239 8.26973 8.26973-.42239L21.75 14.5l6.14625 5.54891-8.26973-.42239.42239 8.26973z',\n    ],\n\n    // effects ------------\n    rotate: true,\n    // fadeInOut: true,\n\n    // scale effect -------\n    scaleInOut: true,\n    maxScale: 1.2,\n    minScale: 0.7,\n    scaleStep: 0.005,\n  });\n};\n\nconst init = () => {\n  const $special = document.getElementById('special-page');\n  if($special) {\n    initAnimation();\n\n    /*if(hljs){\n      hljs.highlightAll();\n    }*/\n    return;\n  }\n\n  initMobileMenu();\n  initMenuScroll();\n  initMenuCollapsible();\n  handleDarkLightModes();\n};\n\ndocument.addEventListener('DOMContentLoaded', () => {\n  init();\n});\n\nexport {};\n"],
  "mappings": "MAAA,IAAMA,EAA0B,YAOnBC,EAAiB,IAAM,CAChC,IAAMC,EAAQ,SAAS,cAAc,YAAY,EACjD,GAAG,CAACA,EAAO,OAEX,IAAMC,EAAO,OAAO,SAAS,SACvBC,EAAQF,EAAM,cAAc,WAAYC,KAAS,EACpD,CAACC,GAEJA,EAAM,eAAe,CACjB,MAAO,QACX,CAAC,CACL,EAEMC,GAAsB,IAAsB,CAC9C,IAAMC,EAAO,OAAO,aAAa,QAAQN,CAAuB,EAChE,GAAG,CAACM,EAAM,MAAO,CAAC,EAElB,IAAIC,EAAuB,CAAC,EAE5B,GAAG,CACCA,EAAO,KAAK,MAAMD,CAAI,GAAK,CAAC,CAChC,OACME,EAAN,CAEA,CAEA,OAAOD,CACX,EAEME,GAAqB,IAAM,CAC7B,IAAMC,EAAU,SAAS,iBAAiB,qCAAqC,EACzEH,EAAuB,CAAC,EAE9B,QAAUI,KAAUD,EAAQ,CACxB,IAAME,EAAKD,EAAO,aAAa,SAAS,GAAK,GAC7C,GAAG,CAACC,EAAI,SAER,IAAMC,EAASF,EAAO,aAAa,aAAa,IAAM,OAEtDJ,EAAK,KAAK,CACN,GAAAK,EACA,OAAAC,CACJ,CAAC,CACL,CAEA,OAAO,aAAa,QAAQb,EAAyB,KAAK,UAAUO,CAAI,CAAC,CAC7E,EAEMO,GAAqB,IAAM,CAC7B,IAAMP,EAAOF,GAAoB,EACjC,GAAG,EAAC,MAAM,QAAQE,CAAI,EAEtB,QAAUQ,KAAYR,EAAK,CACvB,IAAMI,EAAS,SAAS,cAAc,wBAAyBI,EAAS,MAAO,EAC5E,CAACJ,GAEJK,GAAOL,EAAQI,EAAS,OAAQ,EAAK,CACzC,CACJ,EAEMC,GAAS,CAACL,EAAqBE,EAAiBI,IAA2B,CAnEjF,IAAAC,EAqEIP,EAAO,aAAa,cAAeE,EAAO,SAAS,CAAC,EAEpD,IAAMM,EAASR,EAAO,cAAc,cAAc,EAC/C,CAACQ,IAEJA,EAAO,UAAU,OAAO,YAAaN,CAAM,GAC3CK,EAAAP,EAAO,qBAAP,MAAAO,EAA2B,UAAU,OAAO,SAAU,CAACL,GAEpDI,GACCR,GAAmB,EAE3B,EAEaW,GAAsB,IAAM,CACrC,IAAMV,EAAU,SAAS,iBAAiB,qCAAqC,EAE/E,QAAUC,KAAUD,EAEhBC,EAAO,iBAAiB,QAAS,IAAM,CACnC,IAAMU,EAAWV,EAAO,aAAa,aAAa,IAAM,OACxDK,GAAOL,EAAQ,CAACU,EAAU,EAAI,CAClC,CAAC,EAILP,GAAmB,CACvB,EC/FO,IAAMQ,GAAiB,IAAM,CAChC,IAAMC,EAAO,SAAS,eAAe,iBAAiB,EACtD,GAAG,CAACA,EAAM,OAEVA,EAAK,iBAAiB,QAAUC,GAAQ,CACpCA,EAAI,gBAAgB,EACpB,SAAS,KAAK,UAAU,OAAO,oBAAoB,CACvD,CAAC,EAED,SAAS,KAAK,iBAAiB,QAAS,IAAM,CAC1C,SAAS,KAAK,UAAU,OAAO,oBAAoB,CACvD,CAAC,EAED,IAAMC,EAAY,SAAS,eAAe,WAAW,EACrD,GAAG,CAACA,EAAW,OAEfA,EAAU,iBAAiB,QAAUD,GAAQ,CACzCA,EAAI,gBAAgB,CACxB,CAAC,EAED,IAAME,EAAS,SAAS,eAAe,uBAAuB,EAC3D,CAACA,GAEJA,EAAO,iBAAiB,QAAS,IAAM,CACnC,SAAS,KAAK,UAAU,OAAO,oBAAoB,CACvD,CAAC,CACL,EC1BA,IAAMC,EAAmB,OAEZC,GAAuB,IAAM,CAEtC,IAAMC,EAAO,OAAO,aAAa,QAAQF,CAAgB,GAAK,QAC9D,SAAS,gBAAgB,UAAU,OAAO,OAAQE,IAAS,MAAM,EAEjE,IAAMC,EAAiB,SAAS,eAAe,uBAAuB,EAChEC,EAAkB,SAAS,eAAe,wBAAwB,EAElEC,EAAa,IAAM,CACrB,SAAS,gBAAgB,UAAU,IAAI,MAAM,EAC7CF,EAAe,UAAU,IAAI,QAAQ,EACrCC,EAAgB,UAAU,OAAO,QAAQ,EACzC,OAAO,aAAa,QAAQJ,EAAkB,MAAM,CACxD,EAEMM,EAAc,IAAM,CACtB,SAAS,gBAAgB,UAAU,OAAO,MAAM,EAChDF,EAAgB,UAAU,IAAI,QAAQ,EACtCD,EAAe,UAAU,OAAO,QAAQ,EACxC,OAAO,aAAa,QAAQH,EAAkB,OAAO,CACzD,EAEGE,IAAS,OACRG,EAAW,EAGXC,EAAY,EAGhBH,GAAA,MAAAA,EAAgB,iBAAiB,QAASE,GAC1CD,GAAA,MAAAA,EAAiB,iBAAiB,QAASE,EAC/C,2VC/BMC,GAAgB,CAACC,EAA4BC,IAAoD,CACnG,QAAUC,KAAQD,EAAW,CAEzB,IAAME,EAAQD,EAAK,GACnB,GAAGC,IAAU,OAAW,SAExB,IAAMC,EAAMF,EAAK,GACjBF,EAAQ,aAAaI,EAAKD,EAAM,SAAS,CAAC,CAAA,CAElD,EAEaE,GAAkB,CAACC,EAA4CC,IAAkC,CAC1G,QAAUC,KAAQF,EAAM,CAEpB,IAAMH,EAAQK,EAAK,GACnB,GAAGL,IAAU,OAAW,SAExB,IAAMC,EAAMI,EAAK,GACjBD,EAAIH,GAAOD,CAAAA,CAEnB,EAEaM,GAAUH,GAAmB,CAEtC,IAAMN,EAA6B,SAAS,cAAc,QAAQ,EAElED,GAAcC,EAAS,CACnB,CAAC,KAAMM,EAAM,EAAE,EACf,CAAC,QAASA,EAAM,OAAO,EACvB,CAAC,QAASA,EAAM,KAAK,EACrB,CAAC,QAASA,EAAM,KAAK,EACrB,CAAC,WAAYA,EAAM,QAAQ,EAC3B,CAAC,OAAQA,EAAM,IAAI,EACnB,CAAC,aAAcA,EAAM,SAAS,CAClC,CAAC,EAKEA,EAAM,WACLN,EAAQ,YAAcM,EAAM,UAGhC,IAAMC,EACF,OAAOP,EAAQ,YAAe,WAC1BA,EAAQ,WAAW,KAAMM,EAAM,iBAAiB,EAChD,KAER,OAAAN,EAAQ,MAAQM,EAAM,MACtBN,EAAQ,OAASM,EAAM,OAEhB,CAAE,IAAAC,EAAK,QAAAP,CAAQ,CAC1B,EAEaU,EAAS,CAACJ,EAAqBC,IAAkC,CAC1EF,GAAgB,CACZ,CAAC,YAAaC,EAAM,SAAS,EAC7B,CAAC,cAAeA,EAAM,WAAW,EACjC,CAAC,UAAWA,EAAM,OAAO,EACzB,CAAC,WAAYA,EAAM,QAAQ,EAC3B,CAAC,aAAcA,EAAM,UAAU,EAC/B,CAAC,iBAAkBA,EAAM,cAAc,CAC3C,EAAEC,CAAG,EAEFD,EAAM,kBACLC,EAAI,YAAYD,EAAM,gBAAgB,CAE9C,EAEaK,EAAO,CAACL,EAAmBC,IAAkC,CAEnED,EAAM,YAAc,SACnBC,EAAI,UAAYD,EAAM,WAG1BD,GAAgB,CACZ,CAAC,gBAAiBC,EAAM,aAAa,EACrC,CAAC,gBAAiBA,EAAM,aAAa,EACrC,CAAC,aAAcA,EAAM,UAAU,EAC/B,CAAC,cAAeA,EAAM,WAAW,CACrC,EAAEC,CAAG,CACT,ECxEaK,GAAO,CAACN,EAAmBC,IAAkC,CAEtE,GAAM,CAAE,GAAAM,EAAI,GAAAC,EAAI,GAAAC,EAAI,GAAAC,CAAG,EAAIV,EAE3BC,EAAI,KAAK,EAETA,EAAI,UAAU,EACdA,EAAI,OAAOM,EAAIC,CAAE,EACjBP,EAAI,OAAOQ,EAAIC,CAAE,EAEdV,EAAM,cACLI,EAAOJ,EAAOC,CAAG,EACjBA,EAAI,OAAO,GAGfA,EAAI,QAAQ,CAChB,EAgCaU,GAAO,CAACX,EAAmBC,IAAkC,CAEtE,GAAM,CAAE,EAAAW,EAAG,EAAAC,EAAG,EAAAC,EAAG,EAAAC,CAAC,EAAIf,EAEtB,GAAGA,EAAM,MAAM,CACXC,EAAI,UAAUW,EAAGC,EAAGC,EAAGC,CAAC,EACxB,MAAA,CAGJ,GAAGf,EAAM,MAAM,CACXC,EAAI,KAAK,EAETI,EAAKL,EAAOC,CAAG,EACfG,EAAOJ,EAAOC,CAAG,EAEjBA,EAAI,UAAU,EAGdA,EAAI,UAAUW,EAAGC,EAAGC,EAAGC,EAAGf,EAAM,KAAK,EAClCA,EAAM,WACLC,EAAI,KAAK,EAGVD,EAAM,aACLC,EAAI,OAAO,EAGfA,EAAI,QAAQ,EACZ,MAAA,CAGJA,EAAI,KAAK,EAEND,EAAM,YACLK,EAAKL,EAAOC,CAAG,EACfA,EAAI,SAASW,EAAGC,EAAGC,EAAGC,CAAC,GAGxBf,EAAM,cACLI,EAAOJ,EAAOC,CAAG,EACjBA,EAAI,WAAWW,EAAGC,EAAGC,EAAGC,CAAC,GAG7Bd,EAAI,QAAQ,CAChB,EA4Hae,GAAS,CAAChB,EAAqBC,IAAkC,CAC1E,GAAM,CAAE,GAAAgB,EAAI,GAAAC,EAAG,EAAAC,CAAC,EAAInB,EAEdoB,EAAgBpB,EAAM,gBAAkB,OAAY,EAAIA,EAAM,cAC9DqB,EAAcrB,EAAM,cAAgB,OAAY,EAAI,KAAK,GAAKA,EAAM,YAE1EC,EAAI,KAAK,EAETA,EAAI,UAAU,EAEdI,EAAKL,EAAOC,CAAG,EACfG,EAAOJ,EAAOC,CAAG,EAEjBA,EAAI,IAAIgB,EAAIC,EAAIC,EAAGC,EAAeC,EAAarB,EAAM,gBAAgB,EAElEA,EAAM,WACLC,EAAI,KAAK,EAGVD,EAAM,cACLI,EAAOJ,EAAOC,CAAG,EACjBA,EAAI,OAAO,GAGfA,EAAI,QAAQ,CAChB,EAAAqB,GAAA,KAAA,IC5PaC,EAAmB,CAACC,EAAaC,EAAoC,EAAA,IAAa,CAC3F,GAAGA,IAAkB,EAAA,EAAU,OAAOD,EAEnCC,EAAgB,IACfA,EAAgB,GAGpB,IAAMC,EAAcC,GAAA,GAAMF,CAAAA,EAC1B,OAAO,KAAK,MAAMD,EAAME,CAAW,EAAIA,CAC3C,EEkBaE,GAAO,CAACC,EAAiBC,EAAiBL,EAAgB,EAAA,IAAsB,CAEzF,IAAMM,EAAiB,CAAC,EAExB,QAAQC,EAAE,EAAGA,EAAEH,EAAQ,OAAQG,IAC3BD,EAAO,KAAKR,EAAiBM,EAAQG,GAAKF,EAAQE,GAAIP,CAAa,CAAC,EAGxE,OAAOM,CACX,EAwDaE,GAAU,CAACF,EAAgBN,EAAgB,EAAA,IAAa,CACjE,IAAIS,EAAM,EAEV,QAAQF,EAAE,EAAGA,EAAED,EAAO,OAAQC,IAC1BE,GAAOH,EAAOC,GAAKD,EAAOC,GAG9B,OAAOT,EAAiB,KAAK,KAAKW,CAAG,EAAGT,CAAa,CACzD,EAyBaU,GAAa,CAACN,EAAkBC,EAAkBL,EAAgB,EAAA,IAAa,CACxF,IAAMW,EAAOR,GAAKC,EAASC,CAAO,EAClC,OAAOG,GAAQG,EAAMX,CAAa,CACtC,EG3HaY,EAAY,CAACC,EAAaC,EAAad,EAAgB,EAAA,IACzDF,EAAiB,KAAK,OAAO,GAAKgB,EAAMD,GAAOA,EAAKb,CAAa,EAM/De,GAAe,CAACF,EAAaC,IAC/B,KAAK,MAAM,KAAK,OAAO,GAAKA,EAAMD,EAAM,GAAKA,CAAG,EAG9CG,GAAmB,IAAM,KAAK,OAAO,EAAI,GAGzCC,EAA0BC,GAAiB,CACpD,IAAMC,EAAcJ,GAAa,EAAGG,EAAM,OAAS,CAAC,EACpD,OAAOA,EAAMC,EACjB,EQVaC,GAAoB,IAAe,CAC5C,IAAMC,EAAWC,GAAkB,EACnC,OAAOC,GAASF,CAAQ,CAC5B,EAEaC,GAAoB,IAAiB,CAC9C,IAAMhC,EAAIsB,EAAU,EAAG,GAAG,EACpBY,EAAIZ,EAAU,EAAG,GAAG,EACpBa,EAAIb,EAAU,EAAG,GAAG,EAC1B,MAAO,CAACtB,EAAGkC,EAAGC,CAAC,CACnB,EAyRaF,GAAYG,GAAkB,CAEvC,GAAGA,EAAI,GAAK,KAAOA,EAAI,GAAK,KAAOA,EAAI,GAAK,IACxC,MAAO,UAGX,GAAGA,EAAI,GAAK,GAAKA,EAAI,GAAK,GAAKA,EAAI,GAAK,EACpC,MAAO,UAGX,IAAMpC,EAAIoC,EAAI,GAAK,IACbF,EAAIE,EAAI,GAAK,IACbD,EAAIC,EAAI,GAAK,IAEfhC,EAAGiC,EAAGC,EACV,GAAIJ,IAAM,EACN9B,EAAIiC,EAAIC,EAAIH,MACT,CACH,IAAMI,EAAU,CAACC,EAAWC,EAAWC,KAC/BA,EAAI,IAAGA,GAAK,GACZA,EAAI,IAAGA,GAAK,GACZA,EAAI,mBAAcF,GAAKC,EAAID,GAAK,EAAIE,EACpCA,EAAI,GAAcD,EAClBC,EAAI,kBAAcF,GAAKC,EAAID,IAAM,kBAAQE,GAAK,EAC3CF,GAELC,EAAIN,EAAI,GAAMA,GAAK,EAAID,GAAKC,EAAID,EAAIC,EAAID,EACxCM,EAAI,EAAIL,EAAIM,EAClBrC,EAAImC,EAAQC,EAAGC,EAAGzC,EAAI,EAAI,CAAC,EAC3BqC,EAAIE,EAAQC,EAAGC,EAAGzC,CAAC,EACnBsC,EAAIC,EAAQC,EAAGC,EAAGzC,EAAI,EAAI,CAAC,CAAA,CAE/B,IAAM2C,EAAS9C,GAAc,CACzB,IAAM+C,EAAM,KAAK,MAAM/C,EAAI,GAAG,EAAE,SAAS,EAAE,EAC3C,OAAO+C,EAAI,SAAW,EAAI,IAAMA,EAAMA,CAC1C,EAEA,MAAO,IAAID,EAAMvC,CAAC,IAAIuC,EAAMN,CAAC,IAAIM,EAAML,CAAC,GAC5C,EIjUaO,GAAW5D,GAA8C,CAElE,IAAM6D,EAAY7D,EAAM,WAAa,OAAYA,EAAM,SAAW,IAE9D8D,EACAC,EAGAC,EACAC,EAEAC,EAAY,GACZC,EAIEC,EAAO,IAAM,CACfN,EAAY,OACZE,EAAU,OACVC,EAAoB,OACpBC,EAAY,GAOTH,IAAgB,QACnB,OAAO,qBAAqBA,CAAW,CAC3C,EAEMM,EAAU,IAAM,CAClBD,EAAK,EACLE,EAAM,CACV,EAEMC,EAAQ,IAAM,CAChBL,EAAY,EAChB,EAEMM,EAAS,IAAM,CACjBN,EAAY,EAChB,EAMMO,EAAQC,GAAmC,CAEzCZ,IAAc,SACdA,EAAYY,GAIhBV,EAAUU,EAAYZ,EAElBI,GAAaD,IAAsBS,GAAa,OAAO1E,EAAM,UAAa,YAG1EA,EAAM,SAAS2E,EAAU,CAAC,EAG3BX,GAAWH,GACVI,EAAoBS,EACpBX,EAAc,OAAO,sBAAsBU,CAAI,GAG/CL,EAAK,CAEb,EAEMQ,EAAkB,CAACC,EAAiCC,IAA8B,CACpFT,EAAQ,EAEL,OAAOrE,EAAM,gBAAmB,YAC/BA,EAAM,eAAe6E,EAAUC,CAAS,CAEhD,EAEMR,EAAQ,IAAM,CAChBR,EAAY,OACZE,EAAU,OACVC,EAAoB,OACpBC,EAAY,GAETlE,EAAM,iBAAmB,OAAO,gBAAkBmE,IAAa,QAC9DA,EAAW,IAAI,eAAeS,CAAe,EAC7CT,EAAS,QAAQ,SAAS,KAAM,CAAE,IAAK,YAAa,CAAC,GAGrDJ,EAAc,OAAO,sBAAsBU,CAAI,CAEvD,EAOMM,EAAiB,IACZf,EAGLgB,EAAc,IACTd,EAGLe,EAAe,IACVnB,EAGLoB,EAAa,IAAM,CACrB,GAAG,EAAArB,IAAc,EAAA,GAAYG,IAAY,QACzC,OAAOA,EAAU,IAAMH,CAC3B,EAEMsB,EAAoB,IACjBhB,EAGHQ,EAAY,KACP,CAGH,MAAAL,EACA,KAAAF,EACA,MAAAG,EACA,OAAAC,EACA,QAAAH,EAGA,YAAAW,EACA,eAAAD,EACA,aAAAE,EACA,WAAAC,EACA,kBAAAC,CACJ,GAGJ,OAAOR,EAAU,CACrB,ECjKaS,EAAe,CAACjE,EAAWiC,EAAWC,EAAWgC,IACnD,QAASlE,MAAQiC,MAAQC,MAAQgC,MCO/BC,GAAkB,CAACC,EAAoBC,IAAkB,CAElE,GAAM,CAAE,UAAAC,EAAW,IAAAxF,EAAK,mBAAAyF,CAAmB,EAAIF,EAEzCG,EAAoBJ,EAAQ,kBAElC,QAAQvD,EAAG,EAAGA,EAAEyD,EAAU,OAAQzD,IAAI,CAClC,IAAM4D,EAAYH,EAAUzD,GAE5B,QAAQ6D,EAAG,EAAGA,EAAEJ,EAAU,OAAQI,IAAI,CAClC,IAAMC,EAAYL,EAAUI,GAEtBE,EAAWC,GAAWJ,EAAU,OAAQE,EAAU,MAAM,EAC9D,GAAGC,EAAWJ,EAAkB,CAE5B,IAAMM,EAAUV,EAAQ,oBAAsB,EAAI,EAAK,EAAIQ,EAAWJ,EAEtEO,GAAK,CACD,GAAIN,EAAU,OAAO,GACrB,GAAIA,EAAU,OAAO,GACrB,GAAIE,EAAU,OAAO,GACrB,GAAIA,EAAU,OAAO,GACrB,YAAaV,EACTM,EAAmB,GACnBA,EAAmB,GACnBA,EAAmB,GACnBO,CACJ,CACJ,EAAGhG,CAAG,CAAA,CAAA,CAAA,CAItB,EEiIAkG,GAAA,KAAA,ICzKa5E,EAAmB,CAACC,EAAaC,EAAoC,EAAA,IAAa,CAC3F,GAAGA,IAAkB,EAAA,EAAU,OAAOD,EAEnCC,EAAgB,IACfA,EAAgB,GAGpB,IAAMC,EAAcC,GAAA,GAAMF,CAAAA,EAC1B,OAAO,KAAK,MAAMD,EAAME,CAAW,EAAIA,CAC3C,ECaa0E,GAAmB,CAACC,EAAiB5E,EAAgB,EAAA,IAAa,CAC3E,IAAM6E,EAAMD,GAAW,KAAK,GAAK,KACjC,OAAO9E,EAAiB+E,EAAK7E,CAAa,CAC9C,EKLa8E,EAAY1G,GACd,CAAC,MAAM,WAAWA,CAAK,CAAC,GAAK,SAASA,CAAK,EGZzC2G,EAAiB,CAACC,EAAmBhF,EAAgB,EAAA,IAAsB,CACpF,IAAM4D,EAAIoB,EAAS,GACbpD,EAAIoD,EAAS,GAGbrE,EAFIqE,EAAS,GAEFpD,EAEjB,OAAGgC,IAAM,GAAKjD,IAAS,EAAU,EAAA,EAC9BiD,IAAM,EAAU,IAEZ9D,EAAiBa,EAAOiD,EAAG5D,CAAa,CACnD,ECXaiF,GAAoB,CAACD,EAAkBhF,EAAgB,EAAA,IAAsB,CACtF,IAAM4D,EAAIoB,EAAS,GACbpD,EAAIoD,EAAS,GACbE,EAAIF,EAAS,GACbG,EAAIH,EAAS,GAEnB,GAAGpB,IAAM,EAAE,CAEP,IAAMiB,EAAME,EAAe,CAACnD,EAAGsD,EAAGC,CAAC,EAAGnF,CAAa,EACnD,OAAG8E,EAASD,CAAG,EAAU,CAACA,CAAG,EACtB,CAAC,CAAA,CAGZ,IAAMlE,EAAOuE,EAAIC,EAEXC,EAAexD,EAAIA,EAAK,EAAIgC,EAAIjD,EAEtC,GAAGyE,EAAe,EACd,MAAO,CAAC,EAGZ,GAAGA,IAAiB,EAChB,MAAO,CAAEtF,EAAiB,CAAC8B,GAAK,EAAIgC,GAAI5D,CAAa,CAAE,EAI3D,IAAMqF,EAAK,EAAIzB,EACT0B,EAAK,KAAK,KAAKF,CAAY,EAEjC,MAAO,CACHtF,GAAkB,CAAC8B,EAAI0D,GAAMD,EAAIrF,CAAa,EAC9CF,GAAkB,CAAC8B,EAAI0D,GAAMD,EAAIrF,CAAa,CAClD,CACJ,EClBauF,GAAyB,CAClCvD,EACAwD,EACAC,EACAC,EACA1F,EAAgB,EAAA,IACL,CAEX,IAAM2F,EAAQ,KAAK,IAAI,EAAI3D,EAAG,CAAC,EACzB4D,GAAS,EAAI5D,GAAK,EAAIA,EACtB6D,EAAQ7D,EAAIA,EAElB,MAAO,CACHlC,EAAiB6F,EAAQH,EAAkB,GAAKI,EAAQH,EAAmB,GAAKI,EAAQH,EAAgB,GAAI1F,CAAa,EACzHF,EAAiB6F,EAAQH,EAAkB,GAAKI,EAAQH,EAAmB,GAAKI,EAAQH,EAAgB,GAAI1F,CAAa,CAC7H,CACJ,EAwBa8F,GAAqB,CAC9B9D,EACAwD,EACAO,EACAC,EACAN,EACA1F,EAAgB,EAAA,IACL,CAEX,IAAM2F,EAAQ,KAAK,IAAI,EAAI3D,EAAG,CAAC,EACzB4D,EAAQ,KAAK,IAAI,EAAI5D,EAAG,CAAC,EAAI,EAAIA,EACjC6D,GAAS,EAAI7D,GAAK,EAAIA,EAAIA,EAC1BiE,EAAQjE,EAAIA,EAAIA,EAEtB,MAAO,CACHlC,EAAiB6F,EAAQH,EAAkB,GAAKI,EAAQG,EAAoB,GAAKF,EAAQG,EAAoB,GAAKC,EAAQP,EAAgB,GAAI1F,CAAa,EAC3JF,EAAiB6F,EAAQH,EAAkB,GAAKI,EAAQG,EAAoB,GAAKF,EAAQG,EAAoB,GAAKC,EAAQP,EAAgB,GAAI1F,CAAa,CAC/J,CACJ,EAgHakG,GAAgC,CACzCV,EACAC,EACAC,EACA1F,EAAgB,EAAA,IACN,CAQV,IAAMmG,EAAK,EAAKX,EAAkB,GAAK,EAAIC,EAAmB,GAAK,EAAIC,EAAgB,GACjFU,EAAK,GAAKZ,EAAkB,GAAK,EAAIC,EAAmB,GAExDY,EAAOtB,EADc,CAACoB,EAAIC,EAAI,CAAC,EACEpG,CAAa,EAE9CsG,EAAK,EAAKd,EAAkB,GAAK,EAAIC,EAAmB,GAAK,EAAIC,EAAgB,GACjFa,EAAK,GAAKf,EAAkB,GAAK,EAAIC,EAAmB,GAExDe,EAAOzB,EADc,CAACuB,EAAIC,EAAI,CAAC,EACEvG,CAAa,EAE9C6E,EAAc,CAAC,EAErB,OAAGC,EAASuB,CAAI,GACZxB,EAAI,KAAKwB,CAAI,EAGdvB,EAAS0B,CAAI,GACZ3B,EAAI,KAAK2B,CAAI,EAGV3B,CACX,EAMa4B,GAA4B,CACrCjB,EACAO,EACAC,EACAN,EACA1F,EAAgB,EAAA,IACA,CAEhB,IAAMmG,EAAK,GAAMX,EAAkB,GAAK,EAAIO,EAAoB,GAAK,EAAIC,EAAoB,GAAK,EAAIN,EAAgB,GAChHU,EAAK,EAAKZ,EAAkB,GAAK,GAAKO,EAAoB,GAAK,EAAIC,EAAoB,GACvFU,EAAK,GAAMlB,EAAkB,GAAK,EAAIO,EAAoB,GAC1DY,EAAoB,CAACR,EAAIC,EAAIM,EAAI,CAAC,EAElCJ,EAAK,GAAMd,EAAkB,GAAK,EAAIO,EAAoB,GAAK,EAAIC,EAAoB,GAAK,EAAIN,EAAgB,GAChHa,EAAK,EAAKf,EAAkB,GAAK,GAAKO,EAAoB,GAAK,EAAIC,EAAoB,GACvFY,EAAK,GAAMpB,EAAkB,GAAK,EAAIO,EAAoB,GAC1Dc,EAAoB,CAACP,EAAIC,EAAIK,EAAI,CAAC,EAGlCP,EAAOpB,GAAkB0B,EAAW3G,CAAa,EAAE,OAAOD,GAAOA,GAAO,GAAKA,GAAO,CAAC,EACrFyG,EAAOvB,GAAkB4B,EAAW7G,CAAa,EAAE,OAAOD,GAAOA,GAAO,GAAKA,GAAO,CAAC,EAG3F,MADY,CAAC,GAAGsG,EAAM,GAAGG,CAAI,EACtB,SAAW,EACP,CAAC,GAAGH,EAAM,GAAGG,CAAI,EAGrB,IACX,EAIaM,GAAwB,CACjCtB,EACAC,EACAC,EACA1F,EAAgB,EAAA,IACP,CAET,IAAM+G,EAAUb,GAA8BV,EAAmBC,EAAoBC,CAAe,EAEhGsB,EAAO,EAAA,EACPC,EAAO,EAAA,EACPC,EAAO,GAAA,EACPC,EAAO,GAAA,EAEX,QAAUC,KAAWL,EAAQ,CACzB,IAAMM,EAAQ9B,GAAuB6B,EAAS5B,EAAmBC,EAAoBC,CAAe,EAE9FvG,EAAIkI,EAAM,GACVjI,EAAIiI,EAAM,GAEhBL,EAAO,KAAK,IAAIA,EAAM7H,CAAC,EACvB+H,EAAO,KAAK,IAAIA,EAAM/H,CAAC,EAEvB8H,EAAO,KAAK,IAAIA,EAAM7H,CAAC,EACvB+H,EAAO,KAAK,IAAIA,EAAM/H,CAAC,CAAA,CAG3B,OAAA4H,EAAOlH,EAAiB,KAAK,IAAIkH,EAAMxB,EAAkB,GAAIE,EAAgB,EAAE,EAAG1F,CAAa,EAC/FkH,EAAOpH,EAAiB,KAAK,IAAIoH,EAAM1B,EAAkB,GAAIE,EAAgB,EAAE,EAAG1F,CAAa,EAC/FiH,EAAOnH,EAAiB,KAAK,IAAImH,EAAMzB,EAAkB,GAAIE,EAAgB,EAAE,EAAG1F,CAAa,EAC/FmH,EAAOrH,EAAiB,KAAK,IAAIqH,EAAM3B,EAAkB,GAAIE,EAAgB,EAAE,EAAG1F,CAAa,EAExF,CACH,EAAGgH,EACH,EAAGC,EACH,EAAG,KAAK,IAAIC,EAAOF,CAAI,EACvB,EAAG,KAAK,IAAIG,EAAOF,CAAI,EACvB,GAAIC,EACJ,GAAIC,CACR,CACJ,EAEaG,GAAoB,CAC7B9B,EACAO,EACAC,EACAN,EACA1F,EAAgB,EAAA,IACP,CAET,IAAM+G,EAAUN,GAA0BjB,EAAmBO,EAAqBC,EAAqBN,CAAe,GAAK,CAAC,EAExHsB,EAAO,EAAA,EACPC,EAAO,EAAA,EACPC,EAAO,GAAA,EACPC,EAAO,GAAA,EAEX,QAAUC,KAAWL,EAAQ,CACzB,IAAMM,EAAQvB,GAAmBsB,EAAS5B,EAAmBO,EAAqBC,EAAqBN,CAAe,EAEhHvG,EAAIkI,EAAM,GACVjI,EAAIiI,EAAM,GAEhBL,EAAO,KAAK,IAAIA,EAAM7H,GAAA,KAAAA,EAAK,EAAA,CAAQ,EACnC+H,EAAO,KAAK,IAAIA,EAAM/H,GAAA,KAAAA,EAAK,GAAA,CAAS,EAEpC8H,EAAO,KAAK,IAAIA,EAAM7H,GAAA,KAAAA,EAAK,EAAA,CAAQ,EACnC+H,EAAO,KAAK,IAAIA,EAAM/H,GAAA,KAAAA,EAAK,GAAA,CAAS,CAAA,CAGxC,OAAA4H,EAAOlH,EAAiB,KAAK,IAAIkH,EAAMxB,EAAkB,GAAIE,EAAgB,EAAE,EAAG1F,CAAa,EAC/FkH,EAAOpH,EAAiB,KAAK,IAAIoH,EAAM1B,EAAkB,GAAIE,EAAgB,EAAE,EAAG1F,CAAa,EAC/FiH,EAAOnH,EAAiB,KAAK,IAAImH,EAAMzB,EAAkB,GAAIE,EAAgB,EAAE,EAAG1F,CAAa,EAC/FmH,EAAOrH,EAAiB,KAAK,IAAIqH,EAAM3B,EAAkB,GAAIE,EAAgB,EAAE,EAAG1F,CAAa,EAExF,CACH,EAAGgH,EACH,EAAGC,EACH,EAAG,KAAK,IAAIC,EAAOF,CAAI,EACvB,EAAG,KAAK,IAAIG,EAAOF,CAAI,EACvB,GAAIC,EACJ,GAAIC,CACR,CACJ,EK3VMI,GAAe,IAAA,OAAC,gFAAuE,EAKhFC,GAAQC,GAA4C,CAE7D,IAAMC,EAA8B,CAChC,OAAQ,CAAC,EACT,OAAQ,CAAC,CACb,EAEA,GAAG,CAACD,GAAYA,EAAS,KAAK,IAAM,GAAI,OAAOC,EAE/C,IAAIC,EAAU,EACV9I,EAAO,EACP+I,EAAM,EAEJC,EAAQ,IACHF,GAAWF,EAAS,OAGzBK,EAAmBC,GAAgC,CACrDL,EAAO,OAAO,KAAK,CACf,UAAAK,EACA,KAAAlJ,EACA,IAAA+I,CACJ,CAAC,CACL,EAEMI,EAAkBjI,GAAuB,CAC3C2H,EAAO,OAAO,KAAK,CACf,UAAW,MACX,MAAO3H,EACP,KAAAlB,EACA,IAAA+I,CACJ,CAAC,CACL,EAEMK,EAAYC,GAAgB,CAC9BR,EAAO,OAAO,KAAK,CACf,KAAA7I,EACA,IAAA+I,EACA,IAAAM,CACJ,CAAC,CACL,EAEMC,EAAc,IACbN,EAAM,EAAU,GACZN,GAAa,KAAKE,EAAS,UAAUE,CAAO,CAAC,EAMlDS,EAAY,IAAM,CACpB,IAAMC,EAAOZ,EAASE,GAKtB,GAAGU,EAAK,OAAO,CAAC,IAAM;GAAQA,EAAK,OAAO,CAAC,IAAM,KAAK,CAClDV,IACAC,EAAM,EACN/I,IACA,MAAA,CAKJ,GAAG,KAAK,KAAKwJ,CAAI,GAAKA,IAAS,IAAI,CAC/BV,IACAC,IACA,MAAA,CAIJ,GAAGO,EAAY,EAAE,CACb,IAAMG,EAAWb,EAAS,UAAUE,CAAO,EAAE,MAAMJ,EAAY,EAE/D,GAAGe,GAAYA,EAAS,OAAS,EAAE,CAC/B,IAAMvI,EAAMuI,EAAS,GACrBN,EAAejI,CAAG,EAElB4H,GAAW5H,EAAI,OACf6H,GAAO7H,EAAI,OACX,MAAA,CAAA,CAIR,OAAOsI,EAAK,CACR,IAAK,IAAKP,EAAAA,GAA0C,EAAG,MACvD,IAAK,IAAKA,EAAAA,GAA0C,EAAG,MACvD,IAAK,IAAKA,EAAAA,GAA6C,EAAG,MAC1D,IAAK,IAAKA,EAAAA,GAA6C,EAAG,MAC1D,IAAK,IAAKA,EAAAA,GAA0C,EAAG,MACvD,IAAK,IAAKA,EAAAA,GAA0C,EAAG,MACvD,IAAK,IAAKA,EAAAA,GAAoD,EAAG,MACjE,IAAK,IAAKA,EAAAA,GAAoD,EAAG,MACjE,IAAK,IAAKA,EAAAA,GAAkD,EAAG,MAC/D,IAAK,IAAKA,EAAAA,GAAkD,EAAG,MAC/D,IAAK,IAAKA,EAAAA,GAAgD,EAAG,MAC7D,IAAK,IAAKA,EAAAA,GAAgD,EAAG,MAC7D,IAAK,IAAKA,EAAAA,GAAsD,EAAG,MACnE,IAAK,IAAKA,EAAAA,GAAsD,EAAG,MACnE,IAAK,IAAKA,EAAAA,GAAoD,EAAG,MACjE,IAAK,IAAKA,EAAAA,GAAoD,EAAG,MACjE,IAAK,IAAKA,EAAAA,GAA0D,EAAG,MACvE,IAAK,IAAKA,EAAAA,GAA0D,EAAG,MACvE,IAAK,IAAKA,EAAAA,GAAuC,EAAG,MACpD,IAAK,IAAKA,EAAAA,GAAuC,EAAG,MAEpD,QAAS,CACLG,EAAS,wBAAyBI,GAAO,EACzC,KACJ,CACJ,CAEAV,IACAC,GACJ,EAKA,KAAM,CAACC,EAAM,GACTO,EAAU,EAGd,OAAOV,CACX,EC7Haa,GAASC,GAAgD,CAElE,IAAMf,EAAsB,CACxB,SAAU,CAAC,EACX,OAAQe,EAAW,QAAU,CAAC,CAClC,EAEA,GAAGA,EAAW,OAAO,OAAS,GAC1BA,EAAW,OAAO,SAAW,EAAG,OAAOf,EAE3C,GAAM,CAAE,OAAAgB,EAAQ,OAAAC,CAAO,EAAIF,EAErBG,EAAQ,CAACC,EAAuBV,IAAgB,CAClDQ,EAAO,KAAK,CACR,KAAME,GAAA,KAAA,OAAAA,EAAO,KACb,IAAKA,GAAA,KAAA,OAAAA,EAAO,IACZ,IAAAV,CACJ,CAAC,CACL,EAIA,GAAGO,EAAO,GAAG,YAAA,KACTA,EAAO,GAAG,YAAA,IACV,OAAAE,EAAMF,EAAO,GAAI,oEAAoE,EAC9EhB,EAGX,IAAIE,EAAU,EAERE,EAAQ,IACHF,GAAWc,EAAO,OAGvBI,EAAoBd,GAA+B,CAzC7D,IAAAe,EAAAC,EA4CQ,GAAG,CAAChB,GAAaA,EAAU,YAAY,IAAM,IAAK,MAAO,GAGzD,IAAMiB,KAAQF,EAAAL,EAAOd,EAAU,KAAjB,KAAA,OAAAmB,EAAqB,QAAS,IAAI,SAAS,EACnDG,KAAQF,EAAAN,EAAOd,EAAU,KAAjB,KAAA,OAAAoB,EAAqB,QAAS,IAAI,SAAS,EAEzD,OAAQC,IAAS,KAAOA,IAAS,OAASC,IAAS,KAAOA,IAAS,IACvE,EAKMC,EAAe,CAACC,EAAqBC,EAAuCC,IAAwB,CAxD9G,IAAAP,EA0DQ,IAAMf,EAAYU,EAAOd,GAAS,UAC5B2B,EAAmB,CAAC,EAE1B,GAAGH,EAAc,EAGb,QAAQ5I,EAAG,EAAGA,GAAK4I,EAAa5I,IAAI,CAChC,GAAG,CAACkI,EAAOd,EAAUpH,IAAMkI,EAAOd,EAAUpH,GAAG,YAAc,MAAM,CAC/DoI,EAAMF,EAAOd,GAAU,oCAAqCI,IAAa,EACzEJ,GAAWwB,EACX,MAAA,CAGJG,EAAO,KAAK,OAAOb,EAAOd,EAAUpH,GAAG,KAAK,CAAC,CAAA,CAKrD,GAAG,CAACsI,EAAiBd,CAAS,EAAE,CAC5BY,EAAMF,EAAOd,GAAU,2BAA2B,EAClDA,GAAWwB,EAAc,EACzB,MAAA,CAIJ,GAAG,CAACN,EAAiBd,CAAS,EAAE,CAC5BY,EAAMF,EAAOd,GAAU,2BAA2B,EAClDA,GAAWwB,EAAc,EACzB,MAAA,CAUJ,GAPA1B,EAAS,SAAS,KAAK,CACnB,QAASgB,EAAOd,GAAS,UACzB,OAAA2B,CACJ,CAAC,EAED3B,GAAWwB,EAAc,EAEtBA,GAAe,EAAG,OAGrB,IAAMI,EAA+B,CAAC,EAGtC,OAAMT,EAAAL,EAAOd,KAAP,KAAA,OAAAmB,EAAiB,aAAc,OACjCS,EAAW,KAAKd,EAAOd,EAAQ,EAC/BA,IAIJ,GAAG4B,EAAW,OAASJ,IAAgB,EAAE,CACrCR,EAAMY,EAAWA,EAAW,OAAS,GAAI,oBAAoB,EAC7D,MAAA,CAGJ,IAAMC,EAAeH,EAAaD,EAAoB,YAAY,EAAIA,EAAoB,YAAY,EAGtG,QAAQ7I,EAAG,EAAGA,EAAIgJ,EAAW,OAAQhJ,GAAK4I,EAAY,CAClD,IAAMM,EAAuB,CAAC,EAC9B,QAAQrF,EAAI,EAAGA,EAAI+E,EAAa/E,IAC5BqF,EAAW,KAAK,OAAOF,EAAWhJ,EAAI6D,GAAG,KAAK,CAAC,EAEnDqD,EAAS,SAAS,KAAK,CACnB,QAAS+B,EACT,OAAQC,CACZ,CAAC,CAAA,CAET,EAEMC,EAAY,IAAM,CACpB,IAAMd,EAAQH,EAAOd,GAEf0B,EAAaT,EAAM,UAAU,YAAY,IAAMA,EAAM,UAE3D,OAAQA,EAAM,UAAU,CACpB,IAAA,IACA,IAAA,IACA,IAAA,IACA,IAAA,IAAgC,CAC5BM,EAAa,EAAA,IAA+BG,CAAU,EACtD,KACJ,CAEA,IAAA,IACA,IAAA,IAAmC,CAC/BH,EAAa,EAAA,IAA+BG,CAAU,EACtD,KACJ,CAEA,IAAA,IACA,IAAA,IACA,IAAA,IACA,IAAA,IAAwC,CACpCH,EAAa,EAAGN,EAAM,UAAWS,CAAU,EAC3C,KACJ,CAEA,IAAA,IACA,IAAA,IAAsC,CAClCH,EAAa,EAAGN,EAAM,UAAWS,CAAU,EAC3C,KACJ,CAEA,IAAA,IACA,IAAA,IACA,IAAA,IACA,IAAA,IAA0C,CACtCH,EAAa,EAAGN,EAAM,UAAWS,CAAU,EAC3C,KACJ,CAEA,IAAA,IACA,IAAA,IAAgD,CAC5CH,EAAa,EAAGN,EAAM,UAAWS,CAAU,EAC3C,KACJ,CAEA,IAAA,IACA,IAAA,IAA6B,CACzBH,EAAa,EAAGN,EAAM,UAAWS,CAAU,EAC3C,KACJ,CAEA,QAAS,CACLV,EAAMF,EAAOd,GAAU,qBAAqB,EAC5CA,IACA,KACJ,CACJ,CACJ,EAQA,IALAuB,EAAa,EAAA,IAA+BT,EAAO,GAAG,YAAA,GAAwC,EAKxF,CAACZ,EAAM,GACT6B,EAAU,EAGd,OAAOjC,CACX,EEtCakC,GAAsBlC,GAAmC,CAElE,GAAM,CAAE,SAAAmC,CAAS,EAAInC,EAErB,GAAGmC,EAAS,QAAU,EAAG,OAAOnC,EAGhC,IAAItI,EAAIyK,EAAS,GAAG,OAAO,GACvBxK,EAAIwK,EAAS,GAAG,OAAO,GAGvBC,EAAK1K,EACL2K,EAAK1K,EAGTwK,EAAS,GAAG,QAAA,IAEZ,QAAQrJ,EAAI,EAAGA,EAAEqJ,EAAS,OAAQrJ,IAAI,CAGlC,OAFaqJ,EAASrJ,GAET,QAAS,CAClB,IAAA,IAAgC,CAC5BqJ,EAASrJ,GAAG,OAAO,IAAMpB,EACzByK,EAASrJ,GAAG,OAAO,IAAMnB,EAEzByK,EAAKD,EAASrJ,GAAG,OAAO,GACxBuJ,EAAKF,EAASrJ,GAAG,OAAO,GACxB,KACJ,CAEA,IAAA,IACA,IAAA,IAAmC,CAC/BpB,EAAI0K,EACJzK,EAAI0K,EACJ,KACJ,CAEA,IAAA,IACA,IAAA,IAAgD,CAC5C,IAAMC,EAASH,EAASrJ,GAAG,OAAO,GAC5ByJ,EAASJ,EAASrJ,GAAG,OAAO,GAElCqJ,EAASrJ,GAAG,OAAO,IAAMpB,EACzByK,EAASrJ,GAAG,OAAO,IAAMnB,EAEzBD,GAAK4K,EACL3K,GAAK4K,EACL,KACJ,CAEA,IAAA,IACA,IAAA,IAAgC,CAC5B7K,EAAIyK,EAASrJ,GAAG,OAAO,GACvBnB,EAAIwK,EAASrJ,GAAG,OAAO,GACvB,KACJ,CAEA,IAAA,IAA0C,CACtC,IAAMwJ,EAASH,EAASrJ,GAAG,OAAO,GAClCqJ,EAASrJ,GAAG,OAAO,IAAMpB,EACzBA,GAAK4K,EACL,KACJ,CAEA,IAAA,IAA0C,CACtC5K,EAAIyK,EAASrJ,GAAG,OAAO,GACvB,KACJ,CAEA,IAAA,IAAwC,CACpC,IAAMyJ,EAASJ,EAASrJ,GAAG,OAAO,GAClCqJ,EAASrJ,GAAG,OAAO,IAAMnB,EACzBA,GAAK4K,EACL,KACJ,CAEA,IAAA,IAAwC,CACpC5K,EAAIwK,EAASrJ,GAAG,OAAO,GACvB,KACJ,CAEA,IAAA,IAAsC,CAClC,IAAMwJ,EAASH,EAASrJ,GAAG,OAAO,GAC5ByJ,EAASJ,EAASrJ,GAAG,OAAO,GAGlCqJ,EAASrJ,GAAG,OAAO,IAAMpB,EACzByK,EAASrJ,GAAG,OAAO,IAAMnB,EAGzBwK,EAASrJ,GAAG,OAAO,IAAMpB,EACzByK,EAASrJ,GAAG,OAAO,IAAMnB,EAGzBwK,EAASrJ,GAAG,OAAO,IAAMpB,EACzByK,EAASrJ,GAAG,OAAO,IAAMnB,EAEzBD,GAAK4K,EACL3K,GAAK4K,EACL,KACJ,CAEA,IAAA,IAAsC,CAClC7K,EAAIyK,EAASrJ,GAAG,OAAO,GACvBnB,EAAIwK,EAASrJ,GAAG,OAAO,GACvB,KACJ,CAEA,IAAA,IACA,IAAA,IAA0C,CACtC,IAAMwJ,EAASH,EAASrJ,GAAG,OAAO,GAC5ByJ,EAASJ,EAASrJ,GAAG,OAAO,GAElCqJ,EAASrJ,GAAG,OAAO,IAAMpB,EACzByK,EAASrJ,GAAG,OAAO,IAAMnB,EAEzBwK,EAASrJ,GAAG,OAAO,IAAMpB,EACzByK,EAASrJ,GAAG,OAAO,IAAMnB,EAEzBD,GAAK4K,EACL3K,GAAK4K,EACL,KACJ,CAEA,IAAA,IACA,IAAA,IAA0C,CACtC7K,EAAIyK,EAASrJ,GAAG,OAAO,GACvBnB,EAAIwK,EAASrJ,GAAG,OAAO,GACvB,KACJ,CAEA,IAAA,IAA6B,CAEzB,IAAMwJ,EAASH,EAASrJ,GAAG,OAAO,GAC5ByJ,EAASJ,EAASrJ,GAAG,OAAO,GAGlCqJ,EAASrJ,GAAG,OAAO,IAAMpB,EACzByK,EAASrJ,GAAG,OAAO,IAAMnB,EAEzBD,GAAK4K,EACL3K,GAAK4K,EACL,KACJ,CAEA,IAAA,IAA6B,CACzB7K,EAAIyK,EAASrJ,GAAG,OAAO,GACvBnB,EAAIwK,EAASrJ,GAAG,OAAO,GACvB,KACJ,CACJ,CAGAqJ,EAASrJ,GAAG,QAAUqJ,EAASrJ,GAAG,QAAQ,YAAY,CAAA,CAG1D,OAAOkH,CACX,EAwBawC,GAAwBxC,GAAmC,CAEpE,GAAM,CAAE,SAAAmC,CAAS,EAAInC,EAErB,GAAGmC,EAAS,QAAU,EAAG,OAAOnC,EAGhCmC,EAAS,GAAG,QAAA,IAEZ,QAAQrJ,EAAI,EAAGA,EAAEqJ,EAAS,OAAQrJ,IAG9B,OAFaqJ,EAASrJ,GAET,QAAS,CAElB,IAAA,IAA0C,CAEtC,IAAM2J,EAAON,EAASrJ,EAAI,GAC1B,GAAG,CAAC2J,EAAM,SAEVN,EAASrJ,GAAG,QAAA,IAGZqJ,EAASrJ,GAAG,OAAO,GAAK2J,EAAK,OAAO,GACpC,KACJ,CAEA,IAAA,IAAwC,CAEpC,IAAMA,EAAON,EAASrJ,EAAI,GAC1B,GAAG,CAAC2J,EAAM,SAEVN,EAASrJ,GAAG,QAAA,IACZ,IAAMnB,EAAIwK,EAASrJ,GAAG,OAAO,GAG7BqJ,EAASrJ,GAAG,OAAO,GAAK2J,EAAK,OAAO,GACpCN,EAASrJ,GAAG,OAAO,KAAKnB,CAAC,EACzB,KACJ,CAEA,IAAA,IAA4C,CAExC,IAAM8K,EAAON,EAASrJ,EAAI,GAC1B,GAAG,CAAC2J,EAAM,SAGVN,EAASrJ,GAAG,QAAA,IAQZqJ,EAASrJ,GAAG,OAAO,QAAQ2J,EAAK,OAAO,EAAE,EACzCN,EAASrJ,GAAG,OAAO,QAAQ2J,EAAK,OAAO,EAAE,EACzC,KACJ,CAEA,IAAA,IAAgD,CAG5C,IAAMA,EAAON,EAASrJ,EAAI,GAC1B,GAAG,CAAC2J,EAAM,SAGVN,EAASrJ,GAAG,QAAA,IAMZqJ,EAASrJ,GAAG,OAAO,QAAQ2J,EAAK,OAAO,EAAE,EACzCN,EAASrJ,GAAG,OAAO,QAAQ2J,EAAK,OAAO,EAAE,EACzC,KACJ,CACJ,CAGJ,OAAOzC,CACX,ECzZa0C,GAAahF,GAA0B,CAChD,IAAMqD,EAAahB,GAAKrC,CAAC,EACzB,OAAOoD,GAAMC,CAAU,CAC3B,EO4EM4B,EAAW,CAACC,EAAYC,IAAuB,CACjD,IAAMC,EAAM,EAAI,KAAK,GACflF,EAAKiF,EAAK,EAAI,EAAI,GACxB,OAASC,EAAMlF,EAAK,KAAK,KAAKgF,EAAK,KAAK,KAAKA,EAAKA,EAAKC,EAAKA,CAAE,CAAC,GAAKC,CACxE,EAEMC,EAAa,CAACC,EAAcC,EAAcC,EAAcC,KACnD,CACH,EAAGH,EACH,EAAGE,EACH,EAAG,KAAK,IAAIC,EAAOD,CAAI,EACvB,EAAG,KAAK,IAAID,EAAOD,CAAI,EACvB,GAAIC,EACJ,GAAIE,CACR,GAGEC,GAAoB,CACtB/L,EAAYC,EACZ+L,EAAYC,EACZC,EAAkBC,EAClBC,EACAlM,EAAYC,IACH,CAET,IAAIwL,EAAMC,EAAMC,EAAMC,EA2BtB,GARIE,EAAK,IACLA,GAAM,IAGNC,EAAK,IACLA,GAAM,IAGND,IAAO,GAAKC,IAAO,EACnB,OAAAN,EAAO3L,EAAKE,EAAKF,EAAKE,EACtB0L,EAAO5L,EAAKE,EAAKF,EAAKE,EACtB2L,EAAO5L,EAAKE,EAAKF,EAAKE,EACtB2L,EAAO7L,EAAKE,EAAKF,EAAKE,EAEfuL,EAAWC,EAAMC,EAAMC,EAAMC,CAAI,EAG5C,IAAMO,EAAkB,KAAK,IAAIH,CAAQ,GAAKlM,EAAKE,GAAM,EAAI,KAAK,IAAIgM,CAAQ,GAAKjM,EAAKE,GAAM,EACxFmM,EAAkB,CAAC,KAAK,IAAIJ,CAAQ,GAAKlM,EAAKE,GAAM,EAAI,KAAK,IAAIgM,CAAQ,GAAKjM,EAAKE,GAAM,EAE3FoM,EAAoBP,EAAKA,EAAKC,EAAKA,EAAKD,EAAKA,EAAKM,EAAUA,EAAUL,EAAKA,EAAKI,EAAUA,EAC9FE,GAAaP,EAAKA,EAAKM,EAAUA,EAAUL,EAAKA,EAAKI,EAAUA,EAE/D,IAAIG,EAAU,EACVC,EAAU,EAEd,GAAIF,EAAW,EAAG,CACd,IAAMG,EAAgBV,EAAKC,EAE3B,GADAM,EAAWD,EAAUA,EAAUD,EAAUA,GAAWK,EAAQA,GACxDH,EAAW,EACX,OAAAZ,EAAQ3L,EAAKE,EAAKF,EAAKE,EACvB0L,EAAQ5L,EAAKE,EAAKF,EAAKE,EACvB2L,EAAQ5L,EAAKE,EAAKF,EAAKE,EACvB2L,EAAQ7L,EAAKE,EAAKF,EAAKE,EAEhBuL,EAAWC,EAAMC,EAAMC,EAAMC,CAAI,EAE5CG,EAAK,KAAK,KAAKM,CAAQ,EACvBP,EAAKU,EAAQT,CAAAA,KAEZ,CACD,IAAMU,GAAUR,GAAYC,EAAQ,GAAK,GAAK,KAAK,KAAKG,CAAQ,EAChEC,EAAUG,EAASX,EAAKM,EAAUL,EAClCQ,EAAU,CAACE,EAASV,EAAKI,EAAUL,CAAAA,CAGvC,IAAMtL,EAAK8L,EAAU,KAAK,IAAIN,CAAQ,EAAIO,EAAU,KAAK,IAAIP,CAAQ,GAAKlM,EAAKE,GAAM,EAC/ES,EAAK6L,EAAU,KAAK,IAAIN,CAAQ,EAAIO,EAAU,KAAK,IAAIP,CAAQ,GAAKjM,EAAKE,GAAM,EAIjFyM,EAAeC,EAAeC,EAAeC,EAEjD,GAAIb,IAAa,GAAKA,IAAa,KAAK,GACpCP,EAAOjL,EAAKsL,EACZY,EAAQtB,EAAS,CAACU,EAAI,CAAC,EACvBJ,EAAOlL,EAAKsL,EACZa,EAAQvB,EAASU,EAAI,CAAC,EACtBH,EAAOlL,EAAKsL,EACZa,EAAQxB,EAAS,EAAG,CAACW,CAAE,EACvBH,EAAOnL,EAAKsL,EACZc,EAAQzB,EAAS,EAAGW,CAAE,UAEjBC,IAAa,KAAK,GAAK,GAAKA,IAAa,EAAM,KAAK,GAAK,EAC9DP,EAAOjL,EAAKuL,EACZW,EAAQtB,EAAS,CAACW,EAAI,CAAC,EACvBL,EAAOlL,EAAKuL,EACZY,EAAQvB,EAASW,EAAI,CAAC,EACtBJ,EAAOlL,EAAKqL,EACZc,EAAQxB,EAAS,EAAG,CAACU,CAAE,EACvBF,EAAOnL,EAAKqL,EACZe,EAAQzB,EAAS,EAAGU,CAAE,MAErB,CACDY,EAAQ,CAAC,KAAK,KAAKX,EAAK,KAAK,IAAIC,CAAQ,EAAIF,CAAE,EAC/Ca,EAAQ,KAAK,GAAK,KAAK,KAAKZ,EAAK,KAAK,IAAIC,CAAQ,EAAIF,CAAE,EAExDL,EAAOjL,EAAKsL,EAAK,KAAK,IAAIa,CAAK,EAAI,KAAK,IAAIX,CAAQ,EAAID,EAAK,KAAK,IAAIW,CAAK,EAAI,KAAK,IAAIV,CAAQ,EAChGN,EAAOlL,EAAKsL,EAAK,KAAK,IAAIa,CAAK,EAAI,KAAK,IAAIX,CAAQ,EAAID,EAAK,KAAK,IAAIY,CAAK,EAAI,KAAK,IAAIX,CAAQ,EAG5FP,EAAOC,IACP,CAACD,EAAMC,CAAI,EAAI,CAACA,EAAMD,CAAI,EAC1B,CAACiB,EAAOC,CAAK,EAAI,CAACA,EAAOD,CAAK,GAGlC,IAAII,EAAOrM,EAAKqL,EAAK,KAAK,IAAIY,CAAK,EAAI,KAAK,IAAIV,CAAQ,EAAID,EAAK,KAAK,IAAIW,CAAK,EAAI,KAAK,IAAIV,CAAQ,EACpGU,EAAQtB,EAASK,EAAOjL,EAAIsM,EAAOrM,CAAE,EACrCqM,EAAOrM,EAAKqL,EAAK,KAAK,IAAIa,CAAK,EAAI,KAAK,IAAIX,CAAQ,EAAID,EAAK,KAAK,IAAIY,CAAK,EAAI,KAAK,IAAIX,CAAQ,EAChGW,EAAQvB,EAASM,EAAOlL,EAAIsM,EAAOrM,CAAE,EAErCmM,EAAQ,KAAK,KAAKb,GAAM,KAAK,IAAIC,CAAQ,EAAIF,EAAG,EAChDe,EAAQ,KAAK,KAAKd,GAAM,KAAK,IAAIC,CAAQ,EAAIF,EAAG,EAAI,KAAK,GACzDH,EAAOlL,EAAKqL,EAAK,KAAK,IAAIc,CAAK,EAAI,KAAK,IAAIZ,CAAQ,EAAID,EAAK,KAAK,IAAIa,CAAK,EAAI,KAAK,IAAIZ,CAAQ,EAChGJ,EAAOnL,EAAKqL,EAAK,KAAK,IAAIe,CAAK,EAAI,KAAK,IAAIb,CAAQ,EAAID,EAAK,KAAK,IAAIc,CAAK,EAAI,KAAK,IAAIb,CAAQ,EAG5FL,EAAOC,IACP,CAACD,EAAMC,CAAI,EAAI,CAACA,EAAMD,CAAI,EAC1B,CAACiB,EAAOC,CAAK,EAAI,CAACA,EAAOD,CAAK,GAGlC,IAAIG,EAAOvM,EAAKsL,EAAK,KAAK,IAAIc,CAAK,EAAI,KAAK,IAAIZ,CAAQ,EAAID,EAAK,KAAK,IAAIa,CAAK,EAAI,KAAK,IAAIZ,CAAQ,EACpGY,EAAQxB,EAAS2B,EAAOvM,EAAImL,EAAOlL,CAAE,EACrCsM,EAAOvM,EAAKsL,EAAK,KAAK,IAAIe,CAAK,EAAI,KAAK,IAAIb,CAAQ,EAAID,EAAK,KAAK,IAAIc,CAAK,EAAI,KAAK,IAAIb,CAAQ,EAChGa,EAAQzB,EAAS2B,EAAOvM,EAAIoL,EAAOnL,CAAE,CAAA,CAGzC,IAAIuM,EAAS5B,EAAStL,EAAKU,EAAIT,EAAKU,CAAE,EAClCwM,EAAS7B,EAASpL,EAAKQ,EAAIP,EAAKQ,CAAE,EAEjCyL,IACD,CAACc,EAAQC,CAAM,EAAI,CAACA,EAAQD,CAAM,GAGtC,IAAIE,EAAW,GAEf,OAAIF,EAASC,IAET,CAACD,EAAQC,CAAM,EAAI,CAACA,EAAQD,CAAM,EAClCE,EAAW,KAGV,CAACA,IAAaF,EAASN,GAASO,EAASP,IAAYQ,GAAY,EAAEF,EAASN,GAASO,EAASP,MAC/FjB,EAAO,KAAK,IAAI3L,EAAIE,CAAE,IAGrB,CAACkN,IAAaF,EAASL,GAASM,EAASN,IAAYO,GAAY,EAAEF,EAASL,GAASM,EAASN,MAC/FjB,EAAO,KAAK,IAAI5L,EAAIE,CAAE,IAGrB,CAACkN,IAAaF,EAASJ,GAASK,EAASL,IAAYM,GAAY,EAAEF,EAASJ,GAASK,EAASL,MAC/FjB,EAAO,KAAK,IAAI5L,EAAIE,CAAE,IAGrB,CAACiN,IAAaF,EAASH,GAASI,EAASJ,IAAYK,GAAY,EAAEF,EAASH,GAASI,EAASJ,MAC/FjB,EAAO,KAAK,IAAI7L,EAAIE,CAAE,GAGnBuL,EAAWC,EAAMC,EAAMC,EAAMC,CAAI,CAC5C,EAKauB,GAAc,CAAChH,EAAYnF,EAAgB,IAAmB,CA3R3E,IAAA8I,EAAAC,EAAAqD,EAAAC,EA4RI,GAAG,CAAClH,GAAKA,EAAE,KAAK,IAAM,GAAI,OAAO,KAEjC,IAAMmH,EAASnC,GAAUhF,CAAC,EAC1B,GAAGmH,EAAO,OAAO,OAAS,EAAG,OAAO,KAEpC,IAAMC,EAAM5C,GAAmB2C,CAAM,EACrC,GAAG,CAACC,GAAOA,EAAI,SAAS,QAAU,EAAG,OAAO,KAE5C,IAAIvF,EAAO,EAAA,EACPC,EAAO,EAAA,EACPC,EAAO,GAAA,EACPC,EAAO,GAAA,EAELrG,EAAMmJ,GAAqBsC,CAAG,EAGhCpN,EAAI2B,EAAI,SAAS,GAAG,OAAO,GAC3B1B,EAAI0B,EAAI,SAAS,GAAG,OAAO,GAG3B+I,EAAK1K,EACL2K,EAAK1K,EAET,QAAUoN,KAAQ1L,EAAI,SAElB,OAAQ0L,EAAK,QAAQ,CACjB,IAAA,IAAiC,CAC7BxF,EAAO,KAAK,IAAIA,EAAMwF,EAAK,OAAO,EAAE,EACpCvF,EAAO,KAAK,IAAIA,EAAMuF,EAAK,OAAO,EAAE,EAEpCtF,EAAO,KAAK,IAAIA,EAAMsF,EAAK,OAAO,EAAE,EACpCrF,EAAO,KAAK,IAAIA,EAAMqF,EAAK,OAAO,EAAE,EAEpC3C,EAAK2C,EAAK,OAAO,GACjB1C,EAAK0C,EAAK,OAAO,GACjB,KACJ,CAEA,IAAA,IAAmC,CAC/BrN,EAAI0K,EACJzK,EAAI0K,EACJ,KACJ,CAEA,IAAA,IAAgC,CAC5B9C,EAAO,KAAK,IAAIA,EAAMwF,EAAK,OAAO,EAAE,EACpCvF,EAAO,KAAK,IAAIA,EAAMuF,EAAK,OAAO,EAAE,EAEpCtF,EAAO,KAAK,IAAIA,EAAMsF,EAAK,OAAO,EAAE,EACpCrF,EAAO,KAAK,IAAIA,EAAMqF,EAAK,OAAO,EAAE,EAEpCrN,EAAIqN,EAAK,OAAO,GAChBpN,EAAIoN,EAAK,OAAO,GAChB,KACJ,CAEA,IAAA,IAAsC,CAClC,IAAMhH,EAA6B,CAACrG,EAAGC,CAAC,EAClCqN,EAA+B,CAACD,EAAK,OAAO,GAAIA,EAAK,OAAO,EAAE,EAC9DE,EAA+B,CAACF,EAAK,OAAO,GAAIA,EAAK,OAAO,EAAE,EAC9D9G,EAA2B,CAAC8G,EAAK,OAAO,GAAIA,EAAK,OAAO,EAAE,EAC1DG,EAAOC,GAAkBpH,EAAmBiH,EAAqBC,EAAqBhH,CAAe,EAE3GsB,EAAO,KAAK,IAAIA,EAAM2F,EAAK,CAAC,EAC5B1F,EAAO,KAAK,IAAIA,EAAM0F,EAAK,CAAC,EAE5BzF,EAAO,KAAK,IAAIA,EAAMyF,EAAK,EAAE,EAC7BxF,EAAO,KAAK,IAAIA,EAAMwF,EAAK,EAAE,EAE7BxN,EAAIqN,EAAK,OAAO,GAChBpN,EAAIoN,EAAK,OAAO,GAChB,KACJ,CAEA,IAAA,IAA0C,CACtC,IAAMhH,EAA6B,CAACrG,EAAGC,CAAC,EAClCqG,EAA8B,CAAC+G,EAAK,OAAO,GAAIA,EAAK,OAAO,EAAE,EAC7D9G,EAA2B,CAAC8G,EAAK,OAAO,GAAIA,EAAK,OAAO,EAAE,EAE1DG,EAAOE,GAAsBrH,EAAmBC,EAAoBC,CAAe,EAEzFsB,EAAO,KAAK,IAAIA,EAAM2F,EAAK,CAAC,EAC5B1F,EAAO,KAAK,IAAIA,EAAM0F,EAAK,CAAC,EAE5BzF,EAAO,KAAK,IAAIA,EAAMyF,EAAK,EAAE,EAC7BxF,EAAO,KAAK,IAAIA,EAAMwF,EAAK,EAAE,EAE7BxN,EAAIqN,EAAK,OAAO,GAChBpN,EAAIoN,EAAK,OAAO,GAEhB,KACJ,CAEA,IAAA,IAA6B,CAEzB,IAAM1B,EAAK0B,EAAK,OAAO,GACjBzB,EAAKyB,EAAK,OAAO,GACjBM,EAAWN,EAAK,OAAO,GACvBO,EAAeP,EAAK,OAAO,GAC3BQ,EAAYR,EAAK,OAAO,GACxBS,EAAOT,EAAK,OAAO,GACnBU,EAAOV,EAAK,OAAO,GAKnBG,EAAO9B,GAAkB1L,EAAGC,EAAG0L,EAAIC,EAAIoC,GAAiBL,CAAQ,EAAGC,IAAiB,EAAGC,IAAc,EAAGC,EAAMC,CAAI,EAExHlG,EAAO,KAAK,IAAIA,GAAM8B,EAAA6D,GAAA,KAAA,OAAAA,EAAM,IAAN,KAAA7D,EAAW,CAAC,EAClC7B,EAAO,KAAK,IAAIA,GAAM8B,EAAA4D,GAAA,KAAA,OAAAA,EAAM,IAAN,KAAA5D,EAAW,CAAC,EAElC7B,EAAO,KAAK,IAAIA,GAAMkF,EAAAO,GAAA,KAAA,OAAAA,EAAM,KAAN,KAAAP,EAAY,CAAC,EACnCjF,EAAO,KAAK,IAAIA,GAAMkF,EAAAM,GAAA,KAAA,OAAAA,EAAM,KAAN,KAAAN,EAAY,CAAC,EAEnClN,EAAIqN,EAAK,OAAO,GAChBpN,EAAIoN,EAAK,OAAO,GAChB,KACJ,CACJ,CAGJ,MAAO,CACH,EAAGjM,EAAiByG,EAAMhH,CAAa,EACvC,EAAGO,EAAiB0G,EAAMjH,CAAa,EACvC,EAAGO,EAAiB,KAAK,IAAI2G,EAAOF,CAAI,EAAGhH,CAAa,EACxD,EAAGO,EAAiB,KAAK,IAAI4G,EAAOF,CAAI,EAAGjH,CAAa,EACxD,GAAIO,EAAiB2G,EAAMlH,CAAa,EACxC,GAAIO,EAAiB4G,EAAMnH,CAAa,CAC5C,CACJ,EG5ZA,SAASoN,EAAQC,EAAK,CAGpB,OAAOD,EAAwB,OAAO,QAArB,YAA2C,OAAO,OAAO,UAA1B,SAAqC,SAAUC,EAAK,CAClG,OAAO,OAAOA,CAChB,EAAI,SAAUA,EAAK,CACjB,OAAOA,GAAqB,OAAO,QAArB,YAA+BA,EAAI,cAAgB,QAAUA,IAAQ,OAAO,UAAY,SAAW,OAAOA,CAC1H,EAAGD,EAAQC,CAAG,CAChB,CAKA,IAAIC,GAAW,OACXC,GAAY,OAChB,SAASC,EAAUC,EAAOC,EAAM,CAK9B,GAJAD,EAAQA,GAAgB,GACxBC,EAAOA,GAAQ,CAAC,EAGZD,aAAiBD,EACnB,OAAOC,EAGT,GAAI,EAAE,gBAAgBD,GACpB,OAAO,IAAIA,EAAUC,EAAOC,CAAI,EAElC,IAAIC,EAAMC,GAAWH,CAAK,EAC1B,KAAK,eAAiBA,EAAO,KAAK,GAAKE,EAAI,EAAG,KAAK,GAAKA,EAAI,EAAG,KAAK,GAAKA,EAAI,EAAG,KAAK,GAAKA,EAAI,EAAG,KAAK,QAAU,KAAK,MAAM,IAAM,KAAK,EAAE,EAAI,IAAK,KAAK,QAAUD,EAAK,QAAUC,EAAI,OACnL,KAAK,cAAgBD,EAAK,aAMtB,KAAK,GAAK,IAAG,KAAK,GAAK,KAAK,MAAM,KAAK,EAAE,GACzC,KAAK,GAAK,IAAG,KAAK,GAAK,KAAK,MAAM,KAAK,EAAE,GACzC,KAAK,GAAK,IAAG,KAAK,GAAK,KAAK,MAAM,KAAK,EAAE,GAC7C,KAAK,IAAMC,EAAI,EACjB,CACAH,EAAU,UAAY,CACpB,OAAQ,UAAkB,CACxB,OAAO,KAAK,cAAc,EAAI,GAChC,EACA,QAAS,UAAmB,CAC1B,MAAO,CAAC,KAAK,OAAO,CACtB,EACA,QAAS,UAAmB,CAC1B,OAAO,KAAK,GACd,EACA,iBAAkB,UAA4B,CAC5C,OAAO,KAAK,cACd,EACA,UAAW,UAAqB,CAC9B,OAAO,KAAK,OACd,EACA,SAAU,UAAoB,CAC5B,OAAO,KAAK,EACd,EACA,cAAe,UAAyB,CAEtC,IAAIG,EAAM,KAAK,MAAM,EACrB,OAAQA,EAAI,EAAI,IAAMA,EAAI,EAAI,IAAMA,EAAI,EAAI,KAAO,GACrD,EACA,aAAc,UAAwB,CAEpC,IAAIA,EAAM,KAAK,MAAM,EACjBE,EAAOC,EAAOC,EAAOC,EAAGC,EAAGC,EAC/B,OAAAL,EAAQF,EAAI,EAAI,IAChBG,EAAQH,EAAI,EAAI,IAChBI,EAAQJ,EAAI,EAAI,IACZE,GAAS,OAASG,EAAIH,EAAQ,MAAWG,EAAI,KAAK,KAAKH,EAAQ,MAAS,MAAO,GAAG,EAClFC,GAAS,OAASG,EAAIH,EAAQ,MAAWG,EAAI,KAAK,KAAKH,EAAQ,MAAS,MAAO,GAAG,EAClFC,GAAS,OAASG,EAAIH,EAAQ,MAAWG,EAAI,KAAK,KAAKH,EAAQ,MAAS,MAAO,GAAG,EAC/E,MAASC,EAAI,MAASC,EAAI,MAASC,CAC5C,EACA,SAAU,SAAkB9P,EAAO,CACjC,OAAA,KAAK,GAAK+P,GAAW/P,CAAK,EAC1B,KAAK,QAAU,KAAK,MAAM,IAAM,KAAK,EAAE,EAAI,IACpC,IACT,EACA,MAAO,UAAiB,CACtB,IAAIgQ,EAAMC,GAAS,KAAK,GAAI,KAAK,GAAI,KAAK,EAAE,EAC5C,MAAO,CACL,EAAGD,EAAI,EAAI,IACX,EAAGA,EAAI,EACP,EAAGA,EAAI,EACP,EAAG,KAAK,EACV,CACF,EACA,YAAa,UAAuB,CAClC,IAAIA,EAAMC,GAAS,KAAK,GAAI,KAAK,GAAI,KAAK,EAAE,EACxC/O,EAAI,KAAK,MAAM8O,EAAI,EAAI,GAAG,EAC5B5M,EAAI,KAAK,MAAM4M,EAAI,EAAI,GAAG,EAC1BE,EAAI,KAAK,MAAMF,EAAI,EAAI,GAAG,EAC5B,OAAO,KAAK,IAAM,EAAI,OAAS9O,EAAI,KAAOkC,EAAI,MAAQ8M,EAAI,KAAO,QAAUhP,EAAI,KAAOkC,EAAI,MAAQ8M,EAAI,MAAQ,KAAK,QAAU,GAC/H,EACA,MAAO,UAAiB,CACtB,IAAI5M,EAAM6M,GAAS,KAAK,GAAI,KAAK,GAAI,KAAK,EAAE,EAC5C,MAAO,CACL,EAAG7M,EAAI,EAAI,IACX,EAAGA,EAAI,EACP,EAAGA,EAAI,EACP,EAAG,KAAK,EACV,CACF,EACA,YAAa,UAAuB,CAClC,IAAIA,EAAM6M,GAAS,KAAK,GAAI,KAAK,GAAI,KAAK,EAAE,EACxCjP,EAAI,KAAK,MAAMoC,EAAI,EAAI,GAAG,EAC5BF,EAAI,KAAK,MAAME,EAAI,EAAI,GAAG,EAC1BD,EAAI,KAAK,MAAMC,EAAI,EAAI,GAAG,EAC5B,OAAO,KAAK,IAAM,EAAI,OAASpC,EAAI,KAAOkC,EAAI,MAAQC,EAAI,KAAO,QAAUnC,EAAI,KAAOkC,EAAI,MAAQC,EAAI,MAAQ,KAAK,QAAU,GAC/H,EACA,MAAO,SAAe+M,EAAY,CAChC,OAAOC,GAAS,KAAK,GAAI,KAAK,GAAI,KAAK,GAAID,CAAU,CACvD,EACA,YAAa,SAAqBA,EAAY,CAC5C,MAAO,IAAM,KAAK,MAAMA,CAAU,CACpC,EACA,OAAQ,SAAgBE,EAAY,CAClC,OAAOC,GAAU,KAAK,GAAI,KAAK,GAAI,KAAK,GAAI,KAAK,GAAID,CAAU,CACjE,EACA,aAAc,SAAsBA,EAAY,CAC9C,MAAO,IAAM,KAAK,OAAOA,CAAU,CACrC,EACA,MAAO,UAAiB,CACtB,MAAO,CACL,EAAG,KAAK,MAAM,KAAK,EAAE,EACrB,EAAG,KAAK,MAAM,KAAK,EAAE,EACrB,EAAG,KAAK,MAAM,KAAK,EAAE,EACrB,EAAG,KAAK,EACV,CACF,EACA,YAAa,UAAuB,CAClC,OAAO,KAAK,IAAM,EAAI,OAAS,KAAK,MAAM,KAAK,EAAE,EAAI,KAAO,KAAK,MAAM,KAAK,EAAE,EAAI,KAAO,KAAK,MAAM,KAAK,EAAE,EAAI,IAAM,QAAU,KAAK,MAAM,KAAK,EAAE,EAAI,KAAO,KAAK,MAAM,KAAK,EAAE,EAAI,KAAO,KAAK,MAAM,KAAK,EAAE,EAAI,KAAO,KAAK,QAAU,GACvO,EACA,gBAAiB,UAA2B,CAC1C,MAAO,CACL,EAAG,KAAK,MAAME,EAAQ,KAAK,GAAI,GAAG,EAAI,GAAG,EAAI,IAC7C,EAAG,KAAK,MAAMA,EAAQ,KAAK,GAAI,GAAG,EAAI,GAAG,EAAI,IAC7C,EAAG,KAAK,MAAMA,EAAQ,KAAK,GAAI,GAAG,EAAI,GAAG,EAAI,IAC7C,EAAG,KAAK,EACV,CACF,EACA,sBAAuB,UAAiC,CACtD,OAAO,KAAK,IAAM,EAAI,OAAS,KAAK,MAAMA,EAAQ,KAAK,GAAI,GAAG,EAAI,GAAG,EAAI,MAAQ,KAAK,MAAMA,EAAQ,KAAK,GAAI,GAAG,EAAI,GAAG,EAAI,MAAQ,KAAK,MAAMA,EAAQ,KAAK,GAAI,GAAG,EAAI,GAAG,EAAI,KAAO,QAAU,KAAK,MAAMA,EAAQ,KAAK,GAAI,GAAG,EAAI,GAAG,EAAI,MAAQ,KAAK,MAAMA,EAAQ,KAAK,GAAI,GAAG,EAAI,GAAG,EAAI,MAAQ,KAAK,MAAMA,EAAQ,KAAK,GAAI,GAAG,EAAI,GAAG,EAAI,MAAQ,KAAK,QAAU,GACrW,EACA,OAAQ,UAAkB,CACxB,OAAI,KAAK,KAAO,EACP,cAEL,KAAK,GAAK,EACL,GAEFC,GAASJ,GAAS,KAAK,GAAI,KAAK,GAAI,KAAK,GAAI,EAAI,IAAM,EAChE,EACA,SAAU,SAAkBK,EAAa,CACvC,IAAIC,EAAa,IAAMC,GAAc,KAAK,GAAI,KAAK,GAAI,KAAK,GAAI,KAAK,EAAE,EACnEC,EAAmBF,EACnBG,EAAe,KAAK,cAAgB,qBAAuB,GAC/D,GAAIJ,EAAa,CACf,IAAItN,EAAIgM,EAAUsB,CAAW,EAC7BG,EAAmB,IAAMD,GAAcxN,EAAE,GAAIA,EAAE,GAAIA,EAAE,GAAIA,EAAE,EAAE,CAAA,CAE/D,MAAO,8CAAgD0N,EAAe,iBAAmBH,EAAa,gBAAkBE,EAAmB,GAC7I,EACA,SAAU,SAAkBE,EAAQ,CAClC,IAAIC,EAAY,CAAC,CAACD,EAClBA,EAASA,GAAU,KAAK,QACxB,IAAIE,EAAkB,GAClBC,EAAW,KAAK,GAAK,GAAK,KAAK,IAAM,EACrCC,EAAmB,CAACH,GAAaE,IAAaH,IAAW,OAASA,IAAW,QAAUA,IAAW,QAAUA,IAAW,QAAUA,IAAW,QAAUA,IAAW,QACrK,OAAII,EAGEJ,IAAW,QAAU,KAAK,KAAO,EAC5B,KAAK,OAAO,EAEd,KAAK,YAAY,GAEtBA,IAAW,QACbE,EAAkB,KAAK,YAAY,GAEjCF,IAAW,SACbE,EAAkB,KAAK,sBAAsB,IAE3CF,IAAW,OAASA,IAAW,UACjCE,EAAkB,KAAK,YAAY,GAEjCF,IAAW,SACbE,EAAkB,KAAK,YAAY,EAAI,GAErCF,IAAW,SACbE,EAAkB,KAAK,aAAa,EAAI,GAEtCF,IAAW,SACbE,EAAkB,KAAK,aAAa,GAElCF,IAAW,SACbE,EAAkB,KAAK,OAAO,GAE5BF,IAAW,QACbE,EAAkB,KAAK,YAAY,GAEjCF,IAAW,QACbE,EAAkB,KAAK,YAAY,GAE9BA,GAAmB,KAAK,YAAY,EAC7C,EACA,MAAO,UAAiB,CACtB,OAAO7B,EAAU,KAAK,SAAS,CAAC,CAClC,EACA,mBAAoB,SAA4BgC,EAAIC,EAAM,CACxD,IAAIhC,EAAQ+B,EAAG,MAAM,KAAM,CAAC,IAAI,EAAE,OAAO,CAAC,EAAE,MAAM,KAAKC,CAAI,CAAC,CAAC,EAC7D,OAAA,KAAK,GAAKhC,EAAM,GAChB,KAAK,GAAKA,EAAM,GAChB,KAAK,GAAKA,EAAM,GAChB,KAAK,SAASA,EAAM,EAAE,EACf,IACT,EACA,QAAS,UAAmB,CAC1B,OAAO,KAAK,mBAAmBiC,GAAU,SAAS,CACpD,EACA,SAAU,UAAoB,CAC5B,OAAO,KAAK,mBAAmBC,GAAW,SAAS,CACrD,EACA,OAAQ,UAAkB,CACxB,OAAO,KAAK,mBAAmBC,GAAS,SAAS,CACnD,EACA,WAAY,UAAsB,CAChC,OAAO,KAAK,mBAAmBC,GAAa,SAAS,CACvD,EACA,SAAU,UAAoB,CAC5B,OAAO,KAAK,mBAAmBC,GAAW,SAAS,CACrD,EACA,UAAW,UAAqB,CAC9B,OAAO,KAAK,mBAAmBC,GAAY,SAAS,CACtD,EACA,KAAM,UAAgB,CACpB,OAAO,KAAK,mBAAmBC,GAAO,SAAS,CACjD,EACA,kBAAmB,SAA2BR,EAAIC,EAAM,CACtD,OAAOD,EAAG,MAAM,KAAM,CAAC,IAAI,EAAE,OAAO,CAAC,EAAE,MAAM,KAAKC,CAAI,CAAC,CAAC,CAC1D,EACA,UAAW,UAAqB,CAC9B,OAAO,KAAK,kBAAkBQ,GAAY,SAAS,CACrD,EACA,WAAY,UAAsB,CAChC,OAAO,KAAK,kBAAkBC,GAAa,SAAS,CACtD,EACA,cAAe,UAAyB,CACtC,OAAO,KAAK,kBAAkBC,GAAgB,SAAS,CACzD,EACA,gBAAiB,UAA2B,CAC1C,OAAO,KAAK,kBAAkBC,GAAkB,SAAS,CAC3D,EAKA,MAAO,UAAiB,CACtB,OAAO,KAAK,kBAAkBC,GAAQ,CAAC,CAAC,CAAC,CAC3C,EACA,OAAQ,UAAkB,CACxB,OAAO,KAAK,kBAAkBA,GAAQ,CAAC,CAAC,CAAC,CAC3C,CACF,EAIA7C,EAAU,UAAY,SAAUC,EAAOC,EAAM,CAC3C,GAAIN,EAAQK,CAAK,GAAK,SAAU,CAC9B,IAAI6C,EAAW,CAAC,EAChB,QAAS/P,KAAKkN,EACRA,EAAM,eAAelN,CAAC,IACpBA,IAAM,IACR+P,EAAS/P,GAAKkN,EAAMlN,GAEpB+P,EAAS/P,GAAKgQ,EAAoB9C,EAAMlN,EAAE,GAIhDkN,EAAQ6C,CAAAA,CAEV,OAAO9C,EAAUC,EAAOC,CAAI,CAC9B,EAiBA,SAASE,GAAWH,EAAO,CACzB,IAAIE,EAAM,CACR,EAAG,EACH,EAAG,EACH,EAAG,CACL,EACI,EAAI,EACJnM,EAAI,KACJ8M,EAAI,KACJ7M,EAAI,KACJ+O,EAAK,GACLrB,EAAS,GACb,OAAI,OAAO1B,GAAS,WAClBA,EAAQgD,GAAoBhD,CAAK,GAE/BL,EAAQK,CAAK,GAAK,WAChBiD,EAAejD,EAAM,CAAC,GAAKiD,EAAejD,EAAM,CAAC,GAAKiD,EAAejD,EAAM,CAAC,GAC9EE,EAAMgD,GAASlD,EAAM,EAAGA,EAAM,EAAGA,EAAM,CAAC,EACxC+C,EAAK,GACLrB,EAAS,OAAO1B,EAAM,CAAC,EAAE,OAAO,EAAE,IAAM,IAAM,OAAS,OAC9CiD,EAAejD,EAAM,CAAC,GAAKiD,EAAejD,EAAM,CAAC,GAAKiD,EAAejD,EAAM,CAAC,GACrFjM,EAAI+O,EAAoB9C,EAAM,CAAC,EAC/Ba,EAAIiC,EAAoB9C,EAAM,CAAC,EAC/BE,EAAMiD,GAASnD,EAAM,EAAGjM,EAAG8M,CAAC,EAC5BkC,EAAK,GACLrB,EAAS,OACAuB,EAAejD,EAAM,CAAC,GAAKiD,EAAejD,EAAM,CAAC,GAAKiD,EAAejD,EAAM,CAAC,IACrFjM,EAAI+O,EAAoB9C,EAAM,CAAC,EAC/BhM,EAAI8O,EAAoB9C,EAAM,CAAC,EAC/BE,EAAMkD,GAASpD,EAAM,EAAGjM,EAAGC,CAAC,EAC5B+O,EAAK,GACLrB,EAAS,OAEP1B,EAAM,eAAe,GAAG,IAC1B,EAAIA,EAAM,IAGd,EAAIU,GAAW,CAAC,EACT,CACL,GAAIqC,EACJ,OAAQ/C,EAAM,QAAU0B,EACxB,EAAG,KAAK,IAAI,IAAK,KAAK,IAAIxB,EAAI,EAAG,CAAC,CAAC,EACnC,EAAG,KAAK,IAAI,IAAK,KAAK,IAAIA,EAAI,EAAG,CAAC,CAAC,EACnC,EAAG,KAAK,IAAI,IAAK,KAAK,IAAIA,EAAI,EAAG,CAAC,CAAC,EACnC,CACF,CACF,CAaA,SAASgD,GAASjR,EAAGiC,EAAGC,EAAG,CACzB,MAAO,CACL,EAAGgN,EAAQlP,EAAG,GAAG,EAAI,IACrB,EAAGkP,EAAQjN,EAAG,GAAG,EAAI,IACrB,EAAGiN,EAAQhN,EAAG,GAAG,EAAI,GACvB,CACF,CAMA,SAAS2M,GAAS7O,EAAGiC,EAAGC,EAAG,CACzBlC,EAAIkP,EAAQlP,EAAG,GAAG,EAClBiC,EAAIiN,EAAQjN,EAAG,GAAG,EAClBC,EAAIgN,EAAQhN,EAAG,GAAG,EAClB,IAAId,EAAM,KAAK,IAAIpB,EAAGiC,EAAGC,CAAC,EACxBf,EAAM,KAAK,IAAInB,EAAGiC,EAAGC,CAAC,EACpBtC,EACFkC,EACAC,GAAKX,EAAMD,GAAO,EACpB,GAAIC,GAAOD,EACTvB,EAAIkC,EAAI,MACH,CACL,IAAI2D,EAAIrE,EAAMD,EAEd,OADAW,EAAIC,EAAI,GAAM0D,GAAK,EAAIrE,EAAMD,GAAOsE,GAAKrE,EAAMD,GACvCC,EAAK,CACX,KAAKpB,EACHJ,GAAKqC,EAAIC,GAAKuD,GAAKxD,EAAIC,EAAI,EAAI,GAC/B,MACF,KAAKD,EACHrC,GAAKsC,EAAIlC,GAAKyF,EAAI,EAClB,MACF,KAAKvD,EACHtC,GAAKI,EAAIiC,GAAKwD,EAAI,EAClB,KACJ,CACA7F,GAAK,CAAA,CAEP,MAAO,CACL,EAAGA,EACH,EAAGkC,EACHsP,CACF,CACF,CAMA,SAASD,GAASvR,EAAGkC,EAAGC,EAAG,CACzB,IAAI,EAAGE,EAAGC,EACVtC,EAAIsP,EAAQtP,EAAG,GAAG,EAClBkC,EAAIoN,EAAQpN,EAAG,GAAG,EAClBC,EAAImN,EAAQnN,EAAG,GAAG,EAClB,SAASI,EAAQC,EAAGC,EAAGC,EAAG,CAGxB,OAFIA,EAAI,IAAGA,GAAK,GACZA,EAAI,IAAGA,GAAK,GACZA,EAAI,EAAI,EAAUF,GAAKC,EAAID,GAAK,EAAIE,EACpCA,EAAI,EAAI,EAAUD,EAClBC,EAAI,EAAI,EAAUF,GAAKC,EAAID,IAAM,EAAI,EAAIE,GAAK,EAC3CF,CACT,CACA,GAAIN,IAAM,EACR,EAAIG,EAAIC,EAAIH,MACP,CACL,IAAIM,EAAIN,EAAI,GAAMA,GAAK,EAAID,GAAKC,EAAID,EAAIC,EAAID,EACxCM,EAAI,EAAIL,EAAIM,EAChB,EAAIF,EAAQC,EAAGC,EAAGzC,EAAI,EAAI,CAAC,EAC3BqC,EAAIE,EAAQC,EAAGC,EAAGzC,CAAC,EACnBsC,EAAIC,EAAQC,EAAGC,EAAGzC,EAAI,EAAI,CAAC,CAAA,CAE7B,MAAO,CACL,EAAG,EAAI,IACP,EAAGqC,EAAI,IACP,EAAGC,EAAI,GACT,CACF,CAMA,SAASyM,GAAS3O,EAAGiC,EAAGC,EAAG,CACzBlC,EAAIkP,EAAQlP,EAAG,GAAG,EAClBiC,EAAIiN,EAAQjN,EAAG,GAAG,EAClBC,EAAIgN,EAAQhN,EAAG,GAAG,EAClB,IAAId,EAAM,KAAK,IAAIpB,EAAGiC,EAAGC,CAAC,EACxBf,EAAM,KAAK,IAAInB,EAAGiC,EAAGC,CAAC,EACpBtC,EACFkC,EACA8M,EAAIxN,EACFqE,EAAIrE,EAAMD,EAEd,GADAW,EAAIV,IAAQ,EAAI,EAAIqE,EAAIrE,EACpBA,GAAOD,EACTvB,EAAI,MACC,CACL,OAAQwB,EAAK,CACX,KAAKpB,EACHJ,GAAKqC,EAAIC,GAAKuD,GAAKxD,EAAIC,EAAI,EAAI,GAC/B,MACF,KAAKD,EACHrC,GAAKsC,EAAIlC,GAAKyF,EAAI,EAClB,MACF,KAAKvD,EACHtC,GAAKI,EAAIiC,GAAKwD,EAAI,EAClB,KACJ,CACA7F,GAAK,CAAA,CAEP,MAAO,CACL,EAAGA,EACH,EAAGkC,EACH,EAAG8M,CACL,CACF,CAMA,SAASsC,GAAStR,EAAGkC,EAAG8M,EAAG,CACzBhP,EAAIsP,EAAQtP,EAAG,GAAG,EAAI,EACtBkC,EAAIoN,EAAQpN,EAAG,GAAG,EAClB8M,EAAIM,EAAQN,EAAG,GAAG,EAClB,IAAI/N,EAAI,KAAK,MAAMjB,CAAC,EAClByR,EAAIzR,EAAIiB,EACRuB,EAAIwM,GAAK,EAAI9M,GACbO,EAAIuM,GAAK,EAAIyC,EAAIvP,GACjBQ,EAAIsM,GAAK,GAAK,EAAIyC,GAAKvP,GACvBwP,EAAMzQ,EAAI,EACVb,EAAI,CAAC4O,EAAGvM,EAAGD,EAAGA,EAAGE,EAAGsM,CAAC,EAAE0C,GACvBrP,EAAI,CAACK,EAAGsM,EAAGA,EAAGvM,EAAGD,EAAGA,CAAC,EAAEkP,GACvBpP,EAAI,CAACE,EAAGA,EAAGE,EAAGsM,EAAGA,EAAGvM,CAAC,EAAEiP,GACzB,MAAO,CACL,EAAGtR,EAAI,IACP,EAAGiC,EAAI,IACP,EAAGC,EAAI,GACT,CACF,CAMA,SAAS6M,GAAS/O,EAAGiC,EAAGC,EAAG4M,EAAY,CACrC,IAAItM,EAAM,CAAC+O,EAAK,KAAK,MAAMvR,CAAC,EAAE,SAAS,EAAE,CAAC,EAAGuR,EAAK,KAAK,MAAMtP,CAAC,EAAE,SAAS,EAAE,CAAC,EAAGsP,EAAK,KAAK,MAAMrP,CAAC,EAAE,SAAS,EAAE,CAAC,CAAC,EAG/G,OAAI4M,GAActM,EAAI,GAAG,OAAO,CAAC,GAAKA,EAAI,GAAG,OAAO,CAAC,GAAKA,EAAI,GAAG,OAAO,CAAC,GAAKA,EAAI,GAAG,OAAO,CAAC,GAAKA,EAAI,GAAG,OAAO,CAAC,GAAKA,EAAI,GAAG,OAAO,CAAC,EAC5HA,EAAI,GAAG,OAAO,CAAC,EAAIA,EAAI,GAAG,OAAO,CAAC,EAAIA,EAAI,GAAG,OAAO,CAAC,EAEvDA,EAAI,KAAK,EAAE,CACpB,CAMA,SAASyM,GAAUjP,EAAGiC,EAAGC,EAAGgC,EAAG8K,EAAY,CACzC,IAAIxM,EAAM,CAAC+O,EAAK,KAAK,MAAMvR,CAAC,EAAE,SAAS,EAAE,CAAC,EAAGuR,EAAK,KAAK,MAAMtP,CAAC,EAAE,SAAS,EAAE,CAAC,EAAGsP,EAAK,KAAK,MAAMrP,CAAC,EAAE,SAAS,EAAE,CAAC,EAAGqP,EAAKC,GAAoBtN,CAAC,CAAC,CAAC,EAG7I,OAAI8K,GAAcxM,EAAI,GAAG,OAAO,CAAC,GAAKA,EAAI,GAAG,OAAO,CAAC,GAAKA,EAAI,GAAG,OAAO,CAAC,GAAKA,EAAI,GAAG,OAAO,CAAC,GAAKA,EAAI,GAAG,OAAO,CAAC,GAAKA,EAAI,GAAG,OAAO,CAAC,GAAKA,EAAI,GAAG,OAAO,CAAC,GAAKA,EAAI,GAAG,OAAO,CAAC,EACpKA,EAAI,GAAG,OAAO,CAAC,EAAIA,EAAI,GAAG,OAAO,CAAC,EAAIA,EAAI,GAAG,OAAO,CAAC,EAAIA,EAAI,GAAG,OAAO,CAAC,EAE1EA,EAAI,KAAK,EAAE,CACpB,CAKA,SAAS8M,GAActP,EAAGiC,EAAGC,EAAGgC,EAAG,CACjC,IAAI1B,EAAM,CAAC+O,EAAKC,GAAoBtN,CAAC,CAAC,EAAGqN,EAAK,KAAK,MAAMvR,CAAC,EAAE,SAAS,EAAE,CAAC,EAAGuR,EAAK,KAAK,MAAMtP,CAAC,EAAE,SAAS,EAAE,CAAC,EAAGsP,EAAK,KAAK,MAAMrP,CAAC,EAAE,SAAS,EAAE,CAAC,CAAC,EAC7I,OAAOM,EAAI,KAAK,EAAE,CACpB,CAIAsL,EAAU,OAAS,SAAU2D,EAAQC,EAAQ,CAC3C,MAAI,CAACD,GAAU,CAACC,EAAe,GACxB5D,EAAU2D,CAAM,EAAE,YAAY,GAAK3D,EAAU4D,CAAM,EAAE,YAAY,CAC1E,EACA5D,EAAU,OAAS,UAAY,CAC7B,OAAOA,EAAU,UAAU,CACzB,EAAG,KAAK,OAAO,EACf,EAAG,KAAK,OAAO,EACf,EAAG,KAAK,OAAO,CACjB,CAAC,CACH,EAOA,SAASqC,GAAYpC,EAAO4D,EAAQ,CAClCA,EAASA,IAAW,EAAI,EAAIA,GAAU,GACtC,IAAI3P,EAAM8L,EAAUC,CAAK,EAAE,MAAM,EACjC,OAAA/L,EAAI,GAAK2P,EAAS,IAClB3P,EAAI,EAAI4P,EAAQ5P,EAAI,CAAC,EACd8L,EAAU9L,CAAG,CACtB,CACA,SAASoO,GAAUrC,EAAO4D,EAAQ,CAChCA,EAASA,IAAW,EAAI,EAAIA,GAAU,GACtC,IAAI3P,EAAM8L,EAAUC,CAAK,EAAE,MAAM,EACjC,OAAA/L,EAAI,GAAK2P,EAAS,IAClB3P,EAAI,EAAI4P,EAAQ5P,EAAI,CAAC,EACd8L,EAAU9L,CAAG,CACtB,CACA,SAASqO,GAAWtC,EAAO,CACzB,OAAOD,EAAUC,CAAK,EAAE,WAAW,GAAG,CACxC,CACA,SAASiC,GAASjC,EAAO4D,EAAQ,CAC/BA,EAASA,IAAW,EAAI,EAAIA,GAAU,GACtC,IAAI3P,EAAM8L,EAAUC,CAAK,EAAE,MAAM,EACjC,OAAA/L,EAAI,GAAK2P,EAAS,IAClB3P,EAAI,EAAI4P,EAAQ5P,EAAI,CAAC,EACd8L,EAAU9L,CAAG,CACtB,CACA,SAASiO,GAAUlC,EAAO4D,EAAQ,CAChCA,EAASA,IAAW,EAAI,EAAIA,GAAU,GACtC,IAAI1D,EAAMH,EAAUC,CAAK,EAAE,MAAM,EACjC,OAAAE,EAAI,EAAI,KAAK,IAAI,EAAG,KAAK,IAAI,IAAKA,EAAI,EAAI,KAAK,MAAM,IAAM,EAAE0D,EAAS,IAAI,CAAC,CAAC,EAC5E1D,EAAI,EAAI,KAAK,IAAI,EAAG,KAAK,IAAI,IAAKA,EAAI,EAAI,KAAK,MAAM,IAAM,EAAE0D,EAAS,IAAI,CAAC,CAAC,EAC5E1D,EAAI,EAAI,KAAK,IAAI,EAAG,KAAK,IAAI,IAAKA,EAAI,EAAI,KAAK,MAAM,IAAM,EAAE0D,EAAS,IAAI,CAAC,CAAC,EACrE7D,EAAUG,CAAG,CACtB,CACA,SAASiC,GAAQnC,EAAO4D,EAAQ,CAC9BA,EAASA,IAAW,EAAI,EAAIA,GAAU,GACtC,IAAI3P,EAAM8L,EAAUC,CAAK,EAAE,MAAM,EACjC,OAAA/L,EAAI,GAAK2P,EAAS,IAClB3P,EAAI,EAAI4P,EAAQ5P,EAAI,CAAC,EACd8L,EAAU9L,CAAG,CACtB,CAIA,SAASsO,GAAMvC,EAAO4D,EAAQ,CAC5B,IAAI3P,EAAM8L,EAAUC,CAAK,EAAE,MAAM,EAC7B8D,GAAO7P,EAAI,EAAI2P,GAAU,IAC7B,OAAA3P,EAAI,EAAI6P,EAAM,EAAI,IAAMA,EAAMA,EACvB/D,EAAU9L,CAAG,CACtB,CAOA,SAASwO,GAAYzC,EAAO,CAC1B,IAAI/L,EAAM8L,EAAUC,CAAK,EAAE,MAAM,EACjC,OAAA/L,EAAI,GAAKA,EAAI,EAAI,KAAO,IACjB8L,EAAU9L,CAAG,CACtB,CACA,SAAS2O,GAAO5C,EAAO+D,EAAQ,CAC7B,GAAI,MAAMA,CAAM,GAAKA,GAAU,EAC7B,MAAM,IAAI,MAAM,8CAA8C,EAKhE,QAHI9P,EAAM8L,EAAUC,CAAK,EAAE,MAAM,EAC7B/F,EAAS,CAAC8F,EAAUC,CAAK,CAAC,EAC1BzK,EAAO,IAAMwO,EACRjR,EAAI,EAAGA,EAAIiR,EAAQjR,IAC1BmH,EAAO,KAAK8F,EAAU,CACpB,GAAI9L,EAAI,EAAInB,EAAIyC,GAAQ,IACxB,EAAGtB,EAAI,EACP,EAAGA,EAAI,CACT,CAAC,CAAC,EAEJ,OAAOgG,CACT,CACA,SAAS0I,GAAiB3C,EAAO,CAC/B,IAAI/L,EAAM8L,EAAUC,CAAK,EAAE,MAAM,EAC7BnO,EAAIoC,EAAI,EACZ,MAAO,CAAC8L,EAAUC,CAAK,EAAGD,EAAU,CAClC,GAAIlO,EAAI,IAAM,IACd,EAAGoC,EAAI,EACP,EAAGA,EAAI,CACT,CAAC,EAAG8L,EAAU,CACZ,GAAIlO,EAAI,KAAO,IACf,EAAGoC,EAAI,EACP,EAAGA,EAAI,CACT,CAAC,CAAC,CACJ,CACA,SAASuO,GAAWxC,EAAOgE,EAASC,EAAQ,CAC1CD,EAAUA,GAAW,EACrBC,EAASA,GAAU,GACnB,IAAIhQ,EAAM8L,EAAUC,CAAK,EAAE,MAAM,EAC7BkE,EAAO,IAAMD,EACbE,EAAM,CAACpE,EAAUC,CAAK,CAAC,EAC3B,IAAK/L,EAAI,GAAKA,EAAI,GAAKiQ,EAAOF,GAAW,GAAK,KAAO,IAAK,EAAEA,GAC1D/P,EAAI,GAAKA,EAAI,EAAIiQ,GAAQ,IACzBC,EAAI,KAAKpE,EAAU9L,CAAG,CAAC,EAEzB,OAAOkQ,CACT,CACA,SAASzB,GAAe1C,EAAOgE,EAAS,CACtCA,EAAUA,GAAW,EAOrB,QANIrD,EAAMZ,EAAUC,CAAK,EAAE,MAAM,EAC7BnO,EAAI8O,EAAI,EACV5M,EAAI4M,EAAI,EACRE,EAAIF,EAAI,EACNwD,EAAM,CAAC,EACPC,EAAe,EAAIJ,EAChBA,KACLG,EAAI,KAAKpE,EAAU,CACjB,EAAGlO,EACH,EAAGkC,EACH,EAAG8M,CACL,CAAC,CAAC,EACFA,GAAKA,EAAIuD,GAAgB,EAE3B,OAAOD,CACT,CAKApE,EAAU,IAAM,SAAU2D,EAAQC,EAAQC,EAAQ,CAChDA,EAASA,IAAW,EAAI,EAAIA,GAAU,GACtC,IAAIS,EAAOtE,EAAU2D,CAAM,EAAE,MAAM,EAC/BY,EAAOvE,EAAU4D,CAAM,EAAE,MAAM,EAC/BtP,EAAIuP,EAAS,IACbW,EAAO,CACT,GAAID,EAAK,EAAID,EAAK,GAAKhQ,EAAIgQ,EAAK,EAChC,GAAIC,EAAK,EAAID,EAAK,GAAKhQ,EAAIgQ,EAAK,EAChC,GAAIC,EAAK,EAAID,EAAK,GAAKhQ,EAAIgQ,EAAK,EAChC,GAAIC,EAAK,EAAID,EAAK,GAAKhQ,EAAIgQ,EAAK,CAClC,EACA,OAAOtE,EAAUwE,CAAI,CACvB,EAQAxE,EAAU,YAAc,SAAU2D,EAAQC,EAAQ,CAChD,IAAI1K,EAAK8G,EAAU2D,CAAM,EACrBvK,EAAK4G,EAAU4D,CAAM,EACzB,OAAQ,KAAK,IAAI1K,EAAG,aAAa,EAAGE,EAAG,aAAa,CAAC,EAAI,MAAS,KAAK,IAAIF,EAAG,aAAa,EAAGE,EAAG,aAAa,CAAC,EAAI,IACrH,EAYA4G,EAAU,WAAa,SAAU2D,EAAQC,EAAQa,EAAO,CACtD,IAAIC,EAAc1E,EAAU,YAAY2D,EAAQC,CAAM,EAClDe,EAAYC,EAGhB,OAFAA,EAAM,GACND,EAAaE,GAAmBJ,CAAK,EAC7BE,EAAW,MAAQA,EAAW,KAAM,CAC1C,IAAK,UACL,IAAK,WACHC,EAAMF,GAAe,IACrB,MACF,IAAK,UACHE,EAAMF,GAAe,EACrB,MACF,IAAK,WACHE,EAAMF,GAAe,EACrB,KACJ,CACA,OAAOE,CACT,EAWA5E,EAAU,aAAe,SAAU8E,EAAWC,EAAW9C,EAAM,CAC7D,IAAI+C,EAAY,KACZC,EAAY,EACZP,EACAQ,EAAuBC,EAAOC,EAClCnD,EAAOA,GAAQ,CAAC,EAChBiD,EAAwBjD,EAAK,sBAC7BkD,EAAQlD,EAAK,MACbmD,EAAOnD,EAAK,KACZ,QAASlP,EAAI,EAAGA,EAAIgS,EAAU,OAAQhS,IACpC2R,EAAc1E,EAAU,YAAY8E,EAAWC,EAAUhS,EAAE,EACvD2R,EAAcO,IAChBA,EAAYP,EACZM,EAAYhF,EAAU+E,EAAUhS,EAAE,GAGtC,OAAIiN,EAAU,WAAW8E,EAAWE,EAAW,CAC7C,MAAOG,EACP,KAAMC,CACR,CAAC,GAAK,CAACF,EACEF,GAEP/C,EAAK,sBAAwB,GACtBjC,EAAU,aAAa8E,EAAW,CAAC,OAAQ,MAAM,EAAG7C,CAAI,EAEnE,EAKA,IAAIoD,EAAQrF,EAAU,MAAQ,CAC5B,UAAW,SACX,aAAc,SACd,KAAM,MACN,WAAY,SACZ,MAAO,SACP,MAAO,SACP,OAAQ,SACR,MAAO,MACP,eAAgB,SAChB,KAAM,MACN,WAAY,SACZ,MAAO,SACP,UAAW,SACX,YAAa,SACb,UAAW,SACX,WAAY,SACZ,UAAW,SACX,MAAO,SACP,eAAgB,SAChB,SAAU,SACV,QAAS,SACT,KAAM,MACN,SAAU,SACV,SAAU,SACV,cAAe,SACf,SAAU,SACV,UAAW,SACX,SAAU,SACV,UAAW,SACX,YAAa,SACb,eAAgB,SAChB,WAAY,SACZ,WAAY,SACZ,QAAS,SACT,WAAY,SACZ,aAAc,SACd,cAAe,SACf,cAAe,SACf,cAAe,SACf,cAAe,SACf,WAAY,SACZ,SAAU,SACV,YAAa,SACb,QAAS,SACT,QAAS,SACT,WAAY,SACZ,UAAW,SACX,YAAa,SACb,YAAa,SACb,QAAS,MACT,UAAW,SACX,WAAY,SACZ,KAAM,SACN,UAAW,SACX,KAAM,SACN,MAAO,SACP,YAAa,SACb,KAAM,SACN,SAAU,SACV,QAAS,SACT,UAAW,SACX,OAAQ,SACR,MAAO,SACP,MAAO,SACP,SAAU,SACV,cAAe,SACf,UAAW,SACX,aAAc,SACd,UAAW,SACX,WAAY,SACZ,UAAW,SACX,qBAAsB,SACtB,UAAW,SACX,WAAY,SACZ,UAAW,SACX,UAAW,SACX,YAAa,SACb,cAAe,SACf,aAAc,SACd,eAAgB,MAChB,eAAgB,MAChB,eAAgB,SAChB,YAAa,SACb,KAAM,MACN,UAAW,SACX,MAAO,SACP,QAAS,MACT,OAAQ,SACR,iBAAkB,SAClB,WAAY,SACZ,aAAc,SACd,aAAc,SACd,eAAgB,SAChB,gBAAiB,SACjB,kBAAmB,SACnB,gBAAiB,SACjB,gBAAiB,SACjB,aAAc,SACd,UAAW,SACX,UAAW,SACX,SAAU,SACV,YAAa,SACb,KAAM,SACN,QAAS,SACT,MAAO,SACP,UAAW,SACX,OAAQ,SACR,UAAW,SACX,OAAQ,SACR,cAAe,SACf,UAAW,SACX,cAAe,SACf,cAAe,SACf,WAAY,SACZ,UAAW,SACX,KAAM,SACN,KAAM,SACN,KAAM,SACN,WAAY,SACZ,OAAQ,SACR,cAAe,SACf,IAAK,MACL,UAAW,SACX,UAAW,SACX,YAAa,SACb,OAAQ,SACR,WAAY,SACZ,SAAU,SACV,SAAU,SACV,OAAQ,SACR,OAAQ,SACR,QAAS,SACT,UAAW,SACX,UAAW,SACX,UAAW,SACX,KAAM,SACN,YAAa,SACb,UAAW,SACX,IAAK,SACL,KAAM,SACN,QAAS,SACT,OAAQ,SACR,UAAW,SACX,OAAQ,SACR,MAAO,SACP,MAAO,MACP,WAAY,SACZ,OAAQ,MACR,YAAa,QACf,EAGIqB,GAAWrB,EAAU,SAAWsF,GAAKD,CAAK,EAM9C,SAASC,GAAKhC,EAAG,CACf,IAAIiC,EAAU,CAAC,EACf,QAASxS,KAAKuQ,EACRA,EAAE,eAAevQ,CAAC,IACpBwS,EAAQjC,EAAEvQ,IAAMA,GAGpB,OAAOwS,CACT,CAGA,SAAS5E,GAAWvK,EAAG,CACrB,OAAAA,EAAI,WAAWA,CAAC,GACZ,MAAMA,CAAC,GAAKA,EAAI,GAAKA,EAAI,KAC3BA,EAAI,GAECA,CACT,CAGA,SAASgL,EAAQoE,EAAGlS,EAAK,CACnBmS,GAAeD,CAAC,IAAGA,EAAI,QAC3B,IAAIE,EAAiBC,GAAaH,CAAC,EASnC,OARAA,EAAI,KAAK,IAAIlS,EAAK,KAAK,IAAI,EAAG,WAAWkS,CAAC,CAAC,CAAC,EAGxCE,IACFF,EAAI,SAASA,EAAIlS,EAAK,EAAE,EAAI,KAI1B,KAAK,IAAIkS,EAAIlS,CAAG,EAAI,KACf,EAIFkS,EAAIlS,EAAM,WAAWA,CAAG,CACjC,CAGA,SAASwQ,EAAQ8B,EAAK,CACpB,OAAO,KAAK,IAAI,EAAG,KAAK,IAAI,EAAGA,CAAG,CAAC,CACrC,CAGA,SAASC,EAAgBD,EAAK,CAC5B,OAAO,SAASA,EAAK,EAAE,CACzB,CAIA,SAASH,GAAeD,EAAG,CACzB,OAAO,OAAOA,GAAK,UAAYA,EAAE,QAAQ,GAAG,GAAK,IAAM,WAAWA,CAAC,IAAM,CAC3E,CAGA,SAASG,GAAaH,EAAG,CACvB,OAAO,OAAOA,GAAM,UAAYA,EAAE,QAAQ,GAAG,GAAK,EACpD,CAGA,SAAS/B,EAAK/L,EAAG,CACf,OAAOA,EAAE,QAAU,EAAI,IAAMA,EAAI,GAAKA,CACxC,CAGA,SAASqL,EAAoByC,EAAG,CAC9B,OAAIA,GAAK,IACPA,EAAIA,EAAI,IAAM,KAETA,CACT,CAGA,SAAS9B,GAAoB/L,EAAG,CAC9B,OAAO,KAAK,MAAM,WAAWA,CAAC,EAAI,GAAG,EAAE,SAAS,EAAE,CACpD,CAEA,SAASmO,GAAoBhU,EAAG,CAC9B,OAAO+T,EAAgB/T,CAAC,EAAI,GAC9B,CACA,IAAIiU,EAAW,UAAY,CAEzB,IAAIC,EAAc,gBAGdC,EAAa,uBAGbC,EAAW,MAAQD,EAAa,QAAUD,EAAc,IAKxDG,EAAoB,cAAgBD,EAAW,aAAeA,EAAW,aAAeA,EAAW,YACnGE,EAAoB,cAAgBF,EAAW,aAAeA,EAAW,aAAeA,EAAW,aAAeA,EAAW,YACjI,MAAO,CACL,SAAU,IAAI,OAAOA,CAAQ,EAC7B,IAAK,IAAI,OAAO,MAAQC,CAAiB,EACzC,KAAM,IAAI,OAAO,OAASC,CAAiB,EAC3C,IAAK,IAAI,OAAO,MAAQD,CAAiB,EACzC,KAAM,IAAI,OAAO,OAASC,CAAiB,EAC3C,IAAK,IAAI,OAAO,MAAQD,CAAiB,EACzC,KAAM,IAAI,OAAO,OAASC,CAAiB,EAC3C,KAAM,uDACN,KAAM,uDACN,KAAM,uEACN,KAAM,sEACR,CACF,EAAE,EAKF,SAASlD,EAAejD,EAAO,CAC7B,MAAO,CAAC,CAAC8F,EAAS,SAAS,KAAK9F,CAAK,CACvC,CAKA,SAASgD,GAAoBhD,EAAO,CAClCA,EAAQA,EAAM,QAAQH,GAAU,EAAE,EAAE,QAAQC,GAAW,EAAE,EAAE,YAAY,EACvE,IAAIsG,EAAQ,GACZ,GAAIhB,EAAMpF,GACRA,EAAQoF,EAAMpF,GACdoG,EAAQ,WACCpG,GAAS,cAClB,MAAO,CACL,EAAG,EACH,EAAG,EACH,EAAG,EACH,EAAG,EACH,OAAQ,MACV,EAOF,IAAIqG,EACJ,OAAIA,EAAQP,EAAS,IAAI,KAAK9F,CAAK,GAC1B,CACL,EAAGqG,EAAM,GACT,EAAGA,EAAM,GACT,EAAGA,EAAM,EACX,GAEEA,EAAQP,EAAS,KAAK,KAAK9F,CAAK,GAC3B,CACL,EAAGqG,EAAM,GACT,EAAGA,EAAM,GACT,EAAGA,EAAM,GACT,EAAGA,EAAM,EACX,GAEEA,EAAQP,EAAS,IAAI,KAAK9F,CAAK,GAC1B,CACL,EAAGqG,EAAM,GACT,EAAGA,EAAM,GACT,EAAGA,EAAM,EACX,GAEEA,EAAQP,EAAS,KAAK,KAAK9F,CAAK,GAC3B,CACL,EAAGqG,EAAM,GACT,EAAGA,EAAM,GACT,EAAGA,EAAM,GACT,EAAGA,EAAM,EACX,GAEEA,EAAQP,EAAS,IAAI,KAAK9F,CAAK,GAC1B,CACL,EAAGqG,EAAM,GACT,EAAGA,EAAM,GACT,EAAGA,EAAM,EACX,GAEEA,EAAQP,EAAS,KAAK,KAAK9F,CAAK,GAC3B,CACL,EAAGqG,EAAM,GACT,EAAGA,EAAM,GACT,EAAGA,EAAM,GACT,EAAGA,EAAM,EACX,GAEEA,EAAQP,EAAS,KAAK,KAAK9F,CAAK,GAC3B,CACL,EAAG4F,EAAgBS,EAAM,EAAE,EAC3B,EAAGT,EAAgBS,EAAM,EAAE,EAC3B,EAAGT,EAAgBS,EAAM,EAAE,EAC3B,EAAGR,GAAoBQ,EAAM,EAAE,EAC/B,OAAQD,EAAQ,OAAS,MAC3B,GAEEC,EAAQP,EAAS,KAAK,KAAK9F,CAAK,GAC3B,CACL,EAAG4F,EAAgBS,EAAM,EAAE,EAC3B,EAAGT,EAAgBS,EAAM,EAAE,EAC3B,EAAGT,EAAgBS,EAAM,EAAE,EAC3B,OAAQD,EAAQ,OAAS,KAC3B,GAEEC,EAAQP,EAAS,KAAK,KAAK9F,CAAK,GAC3B,CACL,EAAG4F,EAAgBS,EAAM,GAAK,GAAKA,EAAM,EAAE,EAC3C,EAAGT,EAAgBS,EAAM,GAAK,GAAKA,EAAM,EAAE,EAC3C,EAAGT,EAAgBS,EAAM,GAAK,GAAKA,EAAM,EAAE,EAC3C,EAAGR,GAAoBQ,EAAM,GAAK,GAAKA,EAAM,EAAE,EAC/C,OAAQD,EAAQ,OAAS,MAC3B,GAEEC,EAAQP,EAAS,KAAK,KAAK9F,CAAK,GAC3B,CACL,EAAG4F,EAAgBS,EAAM,GAAK,GAAKA,EAAM,EAAE,EAC3C,EAAGT,EAAgBS,EAAM,GAAK,GAAKA,EAAM,EAAE,EAC3C,EAAGT,EAAgBS,EAAM,GAAK,GAAKA,EAAM,EAAE,EAC3C,OAAQD,EAAQ,OAAS,KAC3B,EAEK,EACT,CACA,SAASxB,GAAmB0B,EAAO,CAGjC,IAAIpB,EAAOC,EACX,OAAAmB,EAAQA,GAAS,CACf,MAAO,KACP,KAAM,OACR,EACApB,GAASoB,EAAM,OAAS,MAAM,YAAY,EAC1CnB,GAAQmB,EAAM,MAAQ,SAAS,YAAY,EACvCpB,IAAU,MAAQA,IAAU,QAC9BA,EAAQ,MAENC,IAAS,SAAWA,IAAS,UAC/BA,EAAO,SAEF,CACL,MAAOD,EACP,KAAMC,CACR,CACF,CC/oCO,IAAMoB,GAAkB,CAAClQ,EAAoBC,IAAgC,CAEhF,GAAM,CAAE,QAAA9F,CAAQ,EAAI8F,EAEdC,EAAyB,CAAC,EAE5BiQ,EACAC,EAEEC,EAAUrQ,EAAQ,QAClBsQ,EAAUtQ,EAAQ,QAClBuQ,EAAWvQ,EAAQ,SACnBwQ,EAAWxQ,EAAQ,SACnByQ,EAAWzQ,EAAQ,SAEnB0Q,EAAW1Q,EAAQ,SAEzB,QAAQvD,EAAG,EAAGA,EAAGuD,EAAQ,gBAAiBvD,IAAK,CAE3C,IAAMkU,EAAMC,EAAUP,EAASC,CAAO,EAChCO,EAAwB,CAACF,EAAKA,CAAG,EAGvC,GAAG3Q,EAAQ,aAAeA,EAAQ,YAAY,OAAS,EAAE,CAGrDmQ,EAAczE,EAAuB1L,EAAQ,WAAW,EACxD,IAAM6I,EAAOiI,GAAYX,CAAW,EAEjCtH,IACCuH,EAAU,CACNS,EAAa,GAAKhI,EAAK,EACvBgI,EAAa,GAAKhI,EAAK,CAC3B,EAAA,CAIR,IAAIc,EAED3J,EAAQ,iBAAmBA,EAAQ,gBAAgB,OAAS,EAC3D2J,EAAQ+B,EAAuB1L,EAAQ,eAAe,EAItD2J,EAAQoH,GAAkB,EAI9B,IAAMC,EADStH,EAAUC,CAAK,EACL,MAAM,EAE/BzJ,EAAU,KAAK,CACX,OAAQ,CACJ0Q,EAAU,EAAGzW,EAAQ,KAAK,EAC1ByW,EAAU,EAAGzW,EAAQ,MAAM,CAC/B,EACA,MAAO,CACHyW,EAAUL,EAAUC,CAAQ,EAC5BI,EAAUL,EAAUC,CAAQ,CAChC,EACA,KAAMK,EAEN,MAAAlH,EACA,UAAW,CAACqH,EAAU,EAAGA,EAAU,EAAGA,EAAU,EAAGA,EAAU,CAAC,EAG9D,YAAAb,EACA,QAAAC,EAGA,SAAU,EACV,uBAAwBa,GAAiB,EAGzC,OAAQP,EAAWD,GAAY,EAC/B,eAAgB/E,EAAuB,CAAC,GAAI,CAAC,CAAC,EAG9C,QAASkF,EAAU,EAAG,CAAC,EACvB,iBAAkBlF,EAAuB,CAAC,GAAI,CAAC,CAAC,CACpD,CAAC,CAAA,CAGL,OAAOxL,CACX,EAEagR,GAAe,CAACC,EAAqBnR,EAAoBC,IAA8B,CAEhG,GAAM,CAAE,QAAA9F,CAAQ,EAAI8F,EAEdmR,EAAOC,EAAA,CAAA,EAAKF,CAAAA,EAEZ,CAACzV,EAAIC,CAAE,EAAawV,EAAS,OAC7BG,EAAiB,CAAC,GAAGH,EAAS,KAAK,EAsBzC,IApBGzV,EAAKvB,EAAQ,OAASuB,EAAK,KAC1B4V,EAAM,GAAK,CAACA,EAAM,KAGnB3V,EAAKxB,EAAQ,QAAUwB,EAAK,KAC3B2V,EAAM,GAAK,CAACA,EAAM,IAGtBF,EAAK,MAAQE,EACbF,EAAK,OAAS,CAAC1V,EAAK0V,EAAK,MAAM,GAAIzV,EAAKyV,EAAK,MAAM,EAAE,EAElDpR,EAAQ,SACJmR,EAAS,uBACRC,EAAK,UAAY,KAAK,GAAK,IAG3BA,EAAK,UAAY,KAAK,GAAK,KAIhCpR,EAAQ,WAAW,CAClB,IAAMuR,EAAYvR,EAAQ,UACpByQ,EAAWzQ,EAAQ,SACnB0Q,EAAW1Q,EAAQ,SAEtBoR,EAAK,eAAiB,EACrBA,EAAK,OAASG,EAGdH,EAAK,OAASG,EAGfH,EAAK,MAAQX,IACZW,EAAK,MAAQX,EACbW,EAAK,eAAiB,IAGvBA,EAAK,MAAQV,IACZU,EAAK,MAAQV,EACbU,EAAK,eAAiB,EAAA,CAI9B,GAAGpR,EAAQ,UAAU,CACjB,IAAMwR,EAAcxR,EAAQ,YAEzBoR,EAAK,iBAAmB,EACvBA,EAAK,SAAWI,EAGhBJ,EAAK,SAAWI,EAGjBJ,EAAK,QAAU,IACdA,EAAK,MAAQ,EACbA,EAAK,iBAAmB,IAGzBA,EAAK,QAAU,IACdA,EAAK,QAAU,EACfA,EAAK,iBAAmB,EAAA,CAIhC,OAAOA,CACX,EAEaK,GAAe,CAACN,EAAqBnR,EAAoBC,IAAkB,CAEpF,GAAM,CAAE,IAAAvF,CAAI,EAAIuF,EAEhB,GAAG,CAACD,EAAQ,YAAY,CAEpBtF,EAAI,KAAK,EAET,GAAM,CAAE,KAAAoU,CAAK,EAAIqC,EACbvV,EAAIkT,EAAK,GAEV9O,EAAQ,aACPpE,GAAKuV,EAAS,OAGlB,IAAMO,EAAY1R,EAAQ,UACtBH,EACIsR,EAAS,UAAU,GACnBA,EAAS,UAAU,GACnBA,EAAS,UAAU,GACnBA,EAAS,OACb,EACAA,EAAS,MAEb/P,GAAO,CACH,GAAI+P,EAAS,OAAO,GACpB,GAAIA,EAAS,OAAO,GACpB,EAAAvV,EACA,UAAA8V,CACJ,EAAGhX,CAAG,EAENA,EAAI,QAAQ,EACZ,MAAA,CAGJ,GAAM,CAACa,EAAGC,CAAC,EAAI2V,EAAS,KAElBQ,EAAO,IAAI,OAAOR,EAAS,WAAW,EAC5CzW,EAAI,KAAK,EAET,IAAMkX,EAAYrW,EAAE,EACdsW,EAAarW,EAAE,EAEf,CAACE,EAAIC,CAAE,EAAI,CAACwV,EAAS,OAAO,GAAKS,EAAWT,EAAS,OAAO,GAAKU,CAAU,EACjFnX,EAAI,UAAUgB,EAAIC,CAAE,EAEjBwV,EAAS,UAERzW,EAAI,UAAUkX,EAAWC,CAAU,EACnCnX,EAAI,MAAM,GAAGyW,EAAS,OAAO,EAC7BzW,EAAI,UAAU,CAACkX,EAAW,CAACC,CAAU,GAGtC7R,EAAQ,SACPtF,EAAI,UAAUkX,EAAWC,CAAU,EACnCnX,EAAI,OAAOyW,EAAS,QAAQ,EAC5BzW,EAAI,UAAU,CAACkX,EAAW,CAACC,CAAU,GAGtC7R,EAAQ,aACPtF,EAAI,UAAUkX,EAAWC,CAAU,EACnCnX,EAAI,MAAMyW,EAAS,MAAOA,EAAS,KAAK,EACxCzW,EAAI,UAAU,CAACkX,EAAW,CAACC,CAAU,GAGtC7R,EAAQ,UACPtF,EAAI,UAAYmF,EACZsR,EAAS,UAAU,GACnBA,EAAS,UAAU,GACnBA,EAAS,UAAU,GACnBA,EAAS,OACb,EAGAzW,EAAI,UAAYyW,EAAS,MAG7BzW,EAAI,KAAKiX,CAAI,EACbjX,EAAI,QAAQ,CAChB,ECxPaoX,GAAsB,CAE/B,YAAa,IACb,aAAc,IAEd,gBAAiB,GACjB,gBAAiB,CAAC,EAElB,SAAU,GACV,SAAU,EAEV,QAAS,EACT,QAAS,GAGT,UAAW,GACX,kBAAmB,IACnB,gBAAiB,kBAGjB,SAAU,EACV,SAAU,GACV,UAAW,IAGX,YAAa,IACjB,EAKaC,GAAgB,CAACC,EAAqBC,IAC3CA,EACGZ,EAAAA,EAAA,CAAA,EAAKW,CAAAA,EAAaC,CAAAA,EADJZ,EAAA,CAAA,EAAKW,CAAAA,EC1BxBE,GAAS,CAAClS,EAAoBC,IAAkB,CAElD,GAAM,CAAE,QAAA9F,EAAS,IAAAO,CAAI,EAAIuF,EAGnBkS,EAAwB,CAC1B,EAAG,EACH,EAAG,EACH,EAAGhY,EAAQ,MACX,EAAGA,EAAQ,MACf,EAEG6F,EAAQ,YACPmS,EAAU,UAAYnS,EAAQ,YAG9BmS,EAAU,MAAQ,GAGtB3H,GAAK2H,EAAWzX,CAAG,EAGhBsF,EAAQ,WACPD,GAAgBC,EAASC,CAAK,EAIlC,QAAQxD,EAAG,EAAGA,EAAEwD,EAAM,UAAU,OAAQxD,IAAI,CACxC,IAAM0U,EAAWlR,EAAM,UAAUxD,GACjCgV,GAAaN,EAAUnR,EAASC,CAAK,EACrCA,EAAM,UAAUxD,GAAKyU,GAAaC,EAAUnR,EAASC,CAAK,CAAA,CAElE,EAKamS,GAAQH,GAAyB,CAE1C,IAAMjS,EAAU+R,GAAcD,GAAUG,CAAQ,EAChD,GAAG,CAACjS,EAAQ,aAAc,OAE1B,IAAM5E,EAAO4E,EAAQ,aAAa,sBAAsB,EAElDqS,EAAc,CAChB,MAAOjX,EAAK,MACZ,OAAQA,EAAK,MACjB,EAEM,CAAE,IAAAV,EAAK,QAAAP,CAAQ,EAAI0D,GAAOwU,CAAW,EAC3C,GAAG,CAAC3X,EAAK,OAETsF,EAAQ,aAAa,OAAO7F,CAAO,EAInC,IAAMmY,EADmB5I,EAAU1J,EAAQ,eAAe,EACjB,MAAM,EAEzCC,EAAgB,CAClB,mBAAoB,CAACqS,EAAgB,EAAGA,EAAgB,EAAGA,EAAgB,EAAGA,EAAgB,CAAC,EAC/F,UAAW,CAAC,EACZ,IAAA5X,EACA,QAAAP,CACJ,EAGA,OAAA8F,EAAM,UAAYiQ,GAAgBlQ,EAASC,CAAK,EAEpCsS,GAAQ,CAIhB,SAAU,IAAM,CACR7X,GACJwX,GAAOlS,EAASC,CAAK,CACzB,EACA,gBAAiB,GACjB,eAAgB,IAAM,CAClB,IAAM7E,EAAO4E,EAAQ,aAAa,sBAAsB,EACxD7F,EAAQ,MAAQiB,EAAK,MACrBjB,EAAQ,OAASiB,EAAK,OACtB8W,GAAOlS,EAASC,CAAK,CACzB,CACJ,CAAC,EAGG,MAAM,EAGH9F,CACX,EC1FA,OAAO,UAAYiY,GAEnB,IAAOI,GAAQJ,GCJf,IAAMK,GAAgB,IAAM,CAC1B,IAAMC,EAAe,SAAS,eAAe,cAAc,EACxD,CAACA,GAEJC,GAAU,CACR,aAAAD,EACA,gBAAiB,IAEjB,QAAS,GACT,QAAS,GAET,gBAAiB,CACf,UAAW,UAAW,UAAW,UACjC,UAAW,SACb,EACA,gBAAiB,UAGjB,YAAa,CACX,sJACA,iHACA,iOACF,EAGA,OAAQ,GAIR,WAAY,GACZ,SAAU,IACV,SAAU,GACV,UAAW,IACb,CAAC,CACH,EAEME,GAAO,IAAM,CAEjB,GADiB,SAAS,eAAe,cAAc,EAC1C,CACXH,GAAc,EAKd,MACF,CAEAI,GAAe,EACfC,EAAe,EACfC,GAAoB,EACpBC,GAAqB,CACvB,EAEA,SAAS,iBAAiB,mBAAoB,IAAM,CAClDJ,GAAK,CACP,CAAC",
  "names": ["COLLAPSIBLE_STORAGE_KEY", "initMenuScroll", "$menu", "path", "$link", "getStateFromStorage", "data", "menu", "ex", "saveStateToStorage", "$titles", "$title", "id", "opened", "restoreCollapsible", "menuItem", "toggle", "saveToStorage", "_a", "$arrow", "initMenuCollapsible", "isOpened", "initMobileMenu", "$btn", "evt", "$sideMenu", "$close", "MODE_STORAGE_KEY", "handleDarkLightModes", "mode", "$moveToDarkBtn", "$moveToLightBtn", "moveToDark", "moveToLight", "setAttributes", "$canvas", "attributes", "attr", "value", "key", "setContextProps", "props", "ctx", "prop", "canvas", "stroke", "fill", "line", "x1", "y1", "x2", "y2", "rect", "x", "y", "w", "h", "circle", "cx", "cy", "r", "startAngleRad", "endAngleRad", "Te", "setDecimalPlaces", "num", "decimalPlaces", "coefficient", "__pow", "vSub", "vector1", "vector2", "vector", "i", "vLength", "sum", "v2Distance", "diff", "getRandom", "min", "max", "getRandomInt", "getRandomBoolean", "getRandomItemFromArray", "array", "randomIndex", "getRandomHexColor", "hslColor", "getRandomHSLColor", "hslToHex", "s", "l", "hsl", "g", "b", "hue2rgb", "p", "q", "t", "toHex", "hex", "animate", "_duration", "startTime", "animationId", "elapsed", "previousTimeStamp", "animating", "observer", "stop", "restart", "start", "pause", "resume", "step", "timeStamp", "getResult", "observerHandler", "_entries", "_observer", "getElapsedTime", "isAnimating", "getStartTime", "getPercent", "getResizeObserver", "rgbaToString", "a", "drawConnections", "options", "state", "particles", "connectionRgbColor", "maxConnectionSize", "particle1", "j", "particle2", "distance", "gr", "opacity", "u", "Le", "degreesToRadians", "degrees", "res", "isNumber", "linearEquation", "equation", "quadraticEquation", "c", "d", "discriminant", "t1", "t2", "v2QuadraticBezierCurve", "startControlPoint", "centerControlPoint", "endControlPoint", "temp1", "temp2", "temp3", "v2CubicBezierCurve", "center1ControlPoint", "center2ControlPoint", "temp4", "v2QuadraticBezierCurveExtrema", "a1", "b1", "res1", "a2", "b2", "res2", "v2CubicBezierCurveExtrema", "c1", "equation1", "c2", "equation2", "v2QuadraticBezierBBox", "extrema", "minX", "minY", "maxX", "maxY", "percent", "point", "v2CubicBezierBBox", "NUMBER_REGEX", "scan", "pathData", "result", "current", "col", "isEnd", "addKeywordToken", "tokenType", "addNumberToken", "addError", "msg", "matchNumber", "scanToken", "char", "matchRes", "parse", "scanResult", "tokens", "errors", "error", "token", "areArcFlagsValid", "_a", "_b", "val4", "val5", "parseCommand", "paramsCount", "nextParamsTokenType", "isRelative", "params", "nextTokens", "nextCommand", "nextParams", "parseNext", "pathDataToAbsolute", "commands", "mx", "my", "savedX", "savedY", "maximizeAbsolutePath", "prev", "parsePath", "getAngle", "bx", "by", "PI2", "formatBBox", "xmin", "xmax", "ymin", "ymax", "getArcBoundingBox", "rx", "ry", "angleRad", "largeArc", "sweep", "x1prime", "y1prime", "radicant", "cxPrime", "cyPrime", "ratio", "factor", "txMin", "txMax", "tyMin", "tyMax", "tmpY", "tmpX", "angle1", "angle2", "otherArc", "getPathBBox", "_c", "_d", "parsed", "abs", "item", "centerControlPoint1", "centerControlPoint2", "bbox", "Fn", "Zn", "angleDeg", "largeArcFlag", "sweepFlag", "endX", "endY", "Jt", "_typeof", "obj", "trimLeft", "trimRight", "tinycolor", "color", "opts", "rgb", "inputToRGB", "RsRGB", "GsRGB", "BsRGB", "R", "G", "B", "boundAlpha", "hsv", "rgbToHsv", "v", "rgbToHsl", "allow3Char", "rgbToHex", "allow4Char", "rgbaToHex", "bound01", "hexNames", "secondColor", "hex8String", "rgbaToArgbHex", "secondHex8String", "gradientType", "format", "formatSet", "formattedString", "hasAlpha", "needsAlphaFormat", "fn", "args", "_lighten", "_brighten", "_darken", "_desaturate", "_saturate", "_greyscale", "_spin", "_analogous", "_complement", "_monochromatic", "_splitcomplement", "polyad", "newColor", "convertToPercentage", "ok", "stringInputToObject", "isValidCSSUnit", "rgbToRgb", "hsvToRgb", "hslToRgb", "o", "f", "mod", "pad2", "convertDecimalToHex", "color1", "color2", "amount", "clamp01", "hue", "number", "results", "slices", "part", "ret", "modification", "rgb1", "rgb2", "rgba", "wcag2", "readability", "wcag2Parms", "out", "validateWCAG2Parms", "baseColor", "colorList", "bestColor", "bestScore", "includeFallbackColors", "level", "size", "names", "flip", "flipped", "n", "isOnePointZero", "processPercent", "isPercentage", "val", "parseIntFromHex", "convertHexToDecimal", "matchers", "CSS_INTEGER", "CSS_NUMBER", "CSS_UNIT", "PERMISSIVE_MATCH3", "PERMISSIVE_MATCH4", "named", "match", "parms", "createParticles", "svgPathData", "svgSize", "minSize", "maxSize", "minSpeed", "maxSpeed", "maxScale", "minScale", "rnd", "V", "particleSize", "re", "po", "tColorRGB", "mn", "moveParticle", "particle", "copy", "__spreadValues", "speed", "scaleStep", "opacityStep", "drawParticle", "fillStyle", "path", "halfWidth", "halfHeight", "DEFAULTS", "mergeSettings", "defaults", "settings", "redraw", "rectProps", "init", "canvasProps", "tConnectionsRGB", "qo", "core_default", "initAnimation", "$placeholder", "Qt", "init", "initMobileMenu", "initMenuScroll", "initMenuCollapsible", "handleDarkLightModes"]
}
